#!/bin/bash
RAXMLSERIAL=/home/diag/opt/raxml/7.4.2/bin/raxmlHPC
PARSIMONATOR=/home/pfeiffer/Parsimonator-1.0.2/parsimonator-SSE3
RAXMLLIGHT=/home/pfeiffer/RAxML-Light-1.0.9/raxmlLight-PTHREADS
bsearches=100
rsearches=20
BMAX=500
RMAX=100
usebest=""
serialqueue=shared
parsqueue=normal
searchqueue=normal
parscores=1
searchcores=8
parscoresperjob=32
searchcoresperjob=32
parshours=1
searchhours=1

# This must be specified on the command line
# account=use320
submit=""

substitution_model=GTRCAT
bseed=12345
pseed=12345
auto=autoMRE
save_memory=""
EMAIL=""
url=""
idfile=jobid.txt
logfile=submit_log.txt
donefile=done.txt

generate_bootstrap_replicas() {
    cat > ${sequence_file}.generate_replicas.run << EOF
#!/bin/bash
#PBS -q $serialqueue
#PBS -j oe
#PBS -W umask=0007
#PBS -l nodes=1:ppn=1
#PBS -l walltime=1:00:00
#PBS -A $account
#PBS -v QOS=2
$EMAIL
start=\$(date +%s)
echo -e " \$start s : start time for job to generate bootstrap replicas"
cd \$PBS_O_WORKDIR
$RAXMLSERIAL -s $sequence_file -m $substitution_model -n BS -f j -b $bseed -N $bsearches
# Store original sequence file as (N+1)th bootstrap replica file
cp $sequence_file $sequence_file.BS$bsearches
echo "Cleaning up"
rm -v ${sequence_file}.generate_replicas.run 
end=\$(date +%s)
elapsed=\$((end - start))
echo -e " \$end s : end time for job to generate bootstrap replicas"
echo -e " \$elapsed s : elapsed time for job to generate bootstrap replicas"
qstat -f \$PBS_JOBID | grep Job
qstat -f \$PBS_JOBID | grep resources
date
# This file was automagically generated by $0 $cmdlineargs
EOF
}

generate_parsimony_trees() {
    istart=$1
    iend=$2
    boot=$3
    run_file=$4
    cat > $run_file << EOF
#!/bin/bash
#PBS -q $parsqueue
#PBS -j oe
#PBS -l nodes=1:ppn=$parscoresperjob
#PBS -l walltime=${parshours}:00:00
#PBS -A $account
#PBS -v QOS=2
$EMAIL
#MOREOPTS
start=\$(date +%s)
echo -e " \$start s : start time for job to generate parsimony trees"
cd \$PBS_O_WORKDIR
for (( i=$istart; i<=$iend; i++ )) ; do
    seed=\$(($pseed + 10000 * \$i))
    if [ $boot = 1 ] ; then
        $PARSIMONATOR -s ${sequence_file}.BS\$i -n PB\$i -p \$seed &
    else
        $PARSIMONATOR -s $sequence_file -n PR\$i -p \$seed &
    fi
done
wait
echo "Cleaning up"
rm -v $run_file
end=\$(date +%s)
elapsed=\$((end - start))
echo -e " \$end s : end time for job to generate parsimony trees"
echo -e " \$elapsed s : elapsed time for job to generate parsimony trees"
# This file was automagically generated by $0 $cmdlineargs
EOF
}

do_searches() {
    istart=$1
    iend=$2
    boot=$3
    run_file=$4
    cat > $run_file << EOF
#!/bin/bash
#PBS -q $searchqueue
#PBS -j oe
#PBS -W umask=0007
#PBS -l nodes=1:ppn=$searchcoresperjob
#PBS -l walltime=${searchhours}:00:00
#PBS -A $account
#PBS -v QOS=2
$EMAIL
#MOREOPTS
start=\$(date +%s)
if [ $boot = 1 ] ; then
    echo -e " \$start s : start time for job to do bootstrap searches"
else
    echo -e " \$start s : start time for job to do regular searches"
fi
cd \$PBS_O_WORKDIR
for (( i=$istart; i<=$iend; i++ )) ; do
    if [ $boot = 1 ] ; then
        $RAXMLLIGHT -s ${sequence_file}.BS\$i -m $substitution_model -t RAxML_parsimonyTree.PB\${i}.0 -n LB\$i -T $searchcores -D $save_memory &
    else
        if [ ! $usebest ] ; then
            start_tree=RAxML_parsimonyTree.PR\${i}.0
        else
# Select one of $rsearches best trees from bootstrap searches
            start_tree=\$(grep Likelihood RAxML_info.LB* | awk '{print \$3,\$1;}' | sort -n | tail -$rsearches | sed -n "\$((i + 1))p" | sed 's/.*RAxML_info.LB\([0-9]*\).*/RAxML_result.LB\1/')
        fi
        $RAXMLLIGHT -s $sequence_file -m $substitution_model -t \$start_tree -n LR\$i -T $searchcores $save_memory &
    fi
done
wait
echo "Cleaning up"
for (( i=$istart; i<=$iend; i++ )) ; do
    if [ $boot = 1 ] ; then
        rm -v RAxML_binaryCheckpoint.LB\${i}_*
    else
        rm -v RAxML_binaryCheckpoint.LR\${i}_*
    fi
done
rm -v $run_file
end=\$(date +%s)
elapsed=\$((end - start))
if [ $boot = 1 ] ; then
    echo -e " \$end s : end time for job to do bootstrap searches"
    echo -e " \$elapsed s : elapsed time for job to do bootstrap searches"
else
    echo -e " \$end s : end time for job to do regular searches"
    echo -e " \$elapsed s : elapsed time for job to do regular searches"
fi
qstat -f \$PBS_JOBID | grep Job
qstat -f \$PBS_JOBID | grep resources
date
# This file was automagically generated by $0 $cmdlineargs
EOF
}

test_bootstopping_convergence() {
    cat > ${sequence_file}.test_bootstopping.run << EOF
#!/bin/bash
#PBS -q $serialqueue
#PBS -j oe
#PBS -W umask=0007
#PBS -l nodes=1:ppn=1
#PBS -l walltime=1:00:00
#PBS -A $account
#PBS -v QOS=2
$EMAIL
#MOREOPTS
start=\$(date +%s)
echo -e " \$start s : start time for job to test bootstopping convergence"
cd \$PBS_O_WORKDIR
cat RAxML_result.LB* >> ${sequence_file}.SUP
$RAXMLSERIAL -s $sequence_file -m $substitution_model -n TEST -I $auto -z ${sequence_file}.SUP
echo "Cleaning up"
rm -v ${sequence_file}.SUP
rm -v ${sequence_file}.test_bootstopping.run
end=\$(date +%s)
elapsed=\$((end - start))
echo -e " \$end s : end time for job to test bootstopping convergence"
echo -e " \$elapsed s : elapsed time for job to test bootstopping convergence"
qstat -f \$PBS_JOBID | grep Job
qstat -f \$PBS_JOBID | grep resources
date
# This file was automagically generated by $0 $cmdlineargs
EOF
}

calculate_support_values() {
    cat > ${sequence_file}.calculate_support.run << EOF
#!/bin/bash
#PBS -q $serialqueue
#PBS -j oe
#PBS -W umask=0007
#PBS -l nodes=1:ppn=1
#PBS -l walltime=1:00:00
#PBS -A $account
#PBS -v QOS=2
$EMAIL
#MOREOPTS
start=\$(date +%s)
echo -e " \$start s : start time for job to calculate support values"
cd \$PBS_O_WORKDIR
cat RAxML_result.LB* >> ${sequence_file}.SUP
echo -e "\nLikelihood of the trees from the regular searches is:"
grep Likelihood RAxML_info.LR*
# Select best tree from regular searches
best_likelihood=\$(grep Likelihood RAxML_info.LR* | awk '{print \$3}' | sort -n | tail -1)
best_tree=\$(grep Likelihood RAxML_info.LR* | awk '{print \$3, \$1}' | sort -n | tail -1 | sed 's/.*RAxML_info.LR\([0-9]*\).*/RAxML_result.LR\1/')
echo -e "\nBest likelihood is \$best_likelihood"
echo -e "Best tree is in file \$best_tree"
$RAXMLSERIAL -s $sequence_file -m $substitution_model -n SUP -f b -t \$best_tree -z ${sequence_file}.SUP
echo "Cleaning up"
rm -v ${sequence_file}.SUP
rm -v ${sequence_file}.calculate_support.run
end=\$(date +%s)
elapsed=\$((end - start))
echo -e " \$end s : end time for job to calculate support values"
echo -e " \$elapsed s : elapsed time for job to calculate support values"
qstat -f \$PBS_JOBID | grep Job
qstat -f \$PBS_JOBID | grep resources
date
# This file was automagically generated by $0 $cmdlineargs
EOF
}

# Note that in the generated *.summarize.run script, the url code
# will either look like:
# if [ ]; then curl &status=DONE; fi
# or
# if [ http://www.phylo.org/portal2?taskid ] ; then curl http://www.phylo.org ... etc
# In the first case, the blank url evaluates to false and we don't try to execute the curl on the bogus url.
# In the 2nd case, the test is true (as it would be for any non-blank text between []) and we
# do execute the curl command - you should say an "OK" from curl in the *summarize.run.o* stdout file.
summarize_usage() {
    cat > ${sequence_file}.summarize_usage.run << EOF
#!/bin/bash
#PBS -q $serialqueue
#PBS -j oe
#PBS -W umask=0007
#PBS -l nodes=1:ppn=1
#PBS -l walltime=0:10:00
#PBS -A $account
#PBS -v QOS=2
$EMAIL
#MOREOPTS
cd \$PBS_O_WORKDIR
./${sequence_file}.summarize_usage.pl --parscoresperjob $parscoresperjob --searchcoresperjob $searchcoresperjob *.run.*
echo "Cleaning up"
if [ $bsearches \> 0 ] ; then
    tar cj --remove-files -f ${sequence_file}.BS.tar.bz2 ${sequence_file}.BS*
fi
tar cj --remove-files -f RAxML_info.tar.bz2 RAxML_info.*
tar cj --remove-files -f RAxML_log.tar.bz2 RAxML_log.*
tar cj --remove-files -f RAxML_parsimonyTree.tar.bz2 RAxML_parsimonyTree.*
tar cj --remove-files -f RAxML_result.tar.bz2 RAxML_result.*

if [ $donefile ] ; then
    echo Job finished at `date` >> $donefile
fi
if [  $url ] ; then
    curl $url\&status=DONE
fi

rm -v ${sequence_file}.summarize_usage.run
rm -v ${sequence_file}.summarize_usage.pl
qstat -f \$PBS_JOBID | grep Job
qstat -f \$PBS_JOBID | grep resources
date
# This file was automagically generated by $0 $cmdlineargs
EOF



    cat > ${sequence_file}.summarize_usage.pl << EOF
#!/usr/bin/perl
use Getopt::Long;
GetOptions ("parscoresperjob=i" => \\\$parscoresperjob, "searchcoresperjob=i" => \\\$searchcoresperjob);
\$irep     = 0;
\$ipars    = 0;
\$ibsearch = 0;
\$itest    = 0;
\$irsearch = 0;
\$isup     = 0;
\$trep     = 0;
\$tpars    = 0;
\$tbsearch = 0;
\$ttest    = 0;
\$trsearch = 0;
\$tsup     = 0;
\$tmin     = 1e20;
\$tmax     = 0;
while (defined(\$line = <>)) {
  if (\$line =~ /elapsed time/) {
    @fields = split /\s+/, \$line;
    if (\$line =~ /replicas/) {
      \$irep++;
      \$trep += \$fields[1];
    }
    if (\$line =~ /parsimony/) {
      \$ipars++;
      \$tpars += \$fields[1];
    }
    if (\$line =~ /bootstrap search/) {
      \$ibsearch++;
      \$tbsearch += \$fields[1];
    }
    if (\$line =~ /test/) {
      \$itest++;
      \$ttest += \$fields[1];
    }
    if (\$line =~ /regular search/) {
      \$irsearch++;
      \$trsearch += \$fields[1];
    }
    if (\$line =~ /support/) {
      \$isup++;
      \$tsup += \$fields[1];
    }
  }
  if (\$line =~ /start time/) {
    @fields = split /\s+/, \$line;
    \$tmin = \$fields[1] < \$tmin ? \$fields[1] : \$tmin;
  }
  if (\$line =~ /end time/) {
    @fields = split /\s+/, \$line;
    \$tmax = \$fields[1] > \$tmax ? \$fields[1] : \$tmax;
  }
}
\$isum = \$irep + \$ipars + \$ibsearch + \$itest + \$irsearch + \$isup;
\$usum = (\$trep + \$parscoresperjob*\$tpars + \$searchcoresperjob*\$tbsearch + \$ttest + \$searchcoresperjob*\$trsearch + \$tsup);
printf "                              Cores      Usage      Usage\n";
printf "Step                  Jobs     /job   (core-s)   (core-h)\n\n";
printf "Bootstrap replicas %7.0f        1 %10.0f %10.1f\n", \$irep, \$trep, \$trep/3600;
printf "Parsimony trees    %7.0f %8.0f %10.0f %10.1f\n", \$ipars, \$parscoresperjob, \$parscoresperjob*\$tpars, \$parscoresperjob*\$tpars/3600;
printf "Boostrap searches  %7.0f %8.0f %10.0f %10.1f\n", \$ibsearch, \$searchcoresperjob, \$searchcoresperjob*\$tbsearch, \$searchcoresperjob*\$tbsearch/3600;
printf "Bootstopping test  %7.0f        1 %10.0f %10.1f\n", \$itest, \$ttest, \$ttest/3600;
printf "Regular searches   %7.0f %8.0f %10.0f %10.1f\n", \$irsearch, \$searchcoresperjob, \$searchcoresperjob*\$trsearch, \$searchcoresperjob*\$trsearch/3600;
printf "Support values     %7.0f        1 %10.0f %10.1f\n\n", \$isup, \$tsup, \$tsup/3600;
printf "Total              %7.0f          %10.0f %10.1f\n\n", \$isum, \$usum, \$usum/3600;
printf "Overall elapsed time     = %8.0f s\n", \$tmax-\$tmin;
printf "                         = %8.1f h\n", (\$tmax-\$tmin)/3600;
# This file was automagically generated by $0 $cmdlineargs
EOF
chmod 755 ${sequence_file}.summarize_usage.pl
}

usage() {
    cat << EOF
$0 is a bash script that generates a bunch of other scripts
that perform a comprehensive analysis with RAxML-Light. Some
command-line options are similar to standard RAxML. 

Additional options are:
--bsearches          number of bootstrap searches on replica alignments
--rsearches          number of regular searches on original alignment
--usebest            use best trees found in bootstrap searches
                     for regular searches on original alignment
--serialqueue        queue for serial jobs
--parsqueue          queue for parsimony jobs
--searchqueue        queue for search jobs
--parscores          number of cores to generate a parsimony tree
--searchcores        number of cores to do a search
--parscoresperjob    maximum number of cores per parsimony job
--searchcoresperjob  maximum number of cores per search job
--parshours          maximum wall-clock time in hours for a parsimony job
--searchhours        maximum wall-clock time in hours for a search job
--account            account number
--submit             submit jobs after writing run files
--email              where to send job completion emails

RAxML options are:
-s  sequence file name
-m  substitution model
-b  seed for generating bootstrap replicas
-I  test for bootstopping convergence

Parsimonator options are:
-p  seed for generating first parsimony tree in a sequence of searches

RAxML-Light options are:
-S  save memory

N.B.
The starting DNA/amino acid sequence is stored as bootstrap replica N
(because the bootstrap replicas start at 0 and end at N-1)

EOF
}

cmdlineargs=$*
while [ "$1" ] ; do
    case $1 in
    -h|--help)
        shift; usage; exit 0;;
    -s)
        shift; sequence_file=$1;;
    -m)
        shift; substitution_model=$1;;
    -b)
        shift; bseed=$1;;
    -p)
        shift; pseed=$1;;
    -I)
        shift; auto=$1;;
    -S)
        save_memory=-S;;
    --bsearches)
        shift; bsearches=$1;;
    --rsearches)
        shift; rsearches=$1;;
    --usebest)
        usebest=1;;
    --serialqueue)
        shift; serialqueue=$1;;
    --parsqueue)
        shift; parsqueue=$1;;
    --searchqueue)
        shift; searchqueue=$1;;
    --parscores)
        shift; parscores=$1;;
    --searchcores)
        shift; searchcores=$1;;
    --parscoresperjob)
        shift; parscoresperjob=$1;;
    --searchcoresperjob)
        shift; searchcoresperjob=$1;;
    --parshours)
        shift; parshours=$1;;
    --searchhours)
        shift; searchhours=$1;;
    --account)
        shift; account=$1;;
    --url)
        shift; url=$1;;
    --email)
        shift; EMAIL=$(cat <<-EOF
        #PBS -m ae
        #PBS -M $1
EOF)
        ;;
    --submit)
        submit=1;;
    esac
    shift
done
# check input
if [ -z "$sequence_file" ] ; then
    echo "You must provide a sequence file via -s option"
    exit 1
fi
if (( bsearches <= 0 && rsearches <= 0 )) ; then
    echo "At least one of bsearches or rsearches must be > 0"
    exit 1
fi
if (( bsearches > BMAX )) ; then
    echo "bsearches must be <= BMAX"
    exit 1
fi
if (( rsearches > RMAX )) ; then
    echo "rsearches must be <= RMAX"
    exit 1
fi
if (( usebest && rsearches > bsearches )) ; then
    echo "If usebest option is selected, then rsearches must be <= bsearches"
    exit 1
fi
# generate bootstrap replicas
if (( bsearches > 0 )) ; then
    generate_bootstrap_replicas
    if [ $submit ] ; then
        bsrep_jid=$(qsub ${sequence_file}.generate_replicas.run)
        echo "Submitted job to generate bootstrap replicas ($bsrep_jid)" >> $logfile
        echo $bsrep_jid >> $idfile
    fi
# generate parsimony trees for bootstrap searches
    istart=0
    parstreesperjob=$((parscoresperjob / parscores))
    while (( istart < bsearches )) ; do
        iend=$((istart + parstreesperjob - 1))
        if (( iend >= bsearches )) ; then
            iend=$((bsearches - 1))
        fi
        run_file=${sequence_file}.parsimonator.PB${istart}.run
        generate_parsimony_trees $istart $iend 1 $run_file
        istart=$((iend + 1))
        if [ $submit ] ; then
            sed -i 's/MOREOPTS/PBS -W depend=afterok:'$bsrep_jid'/' $run_file
            parsimonator_jid=$(qsub $run_file)
            echo "Submitted job to generate parsimony trees from replica alignments ($parsimonator_jid:$istart)" >> $logfile
            echo $parsimonator_jid >> $idfile
            all_PB_runs="$parsimonator_jid:$all_PB_runs"
        fi
    done
# do bootstrap searches
    istart=0
    searchesperjob=$((searchcoresperjob / searchcores))
    while (( istart < bsearches )) ; do
        iend=$((istart + searchesperjob - 1))
        if (( iend >= bsearches )) ; then
            iend=$((bsearches - 1))
        fi
        run_file=${sequence_file}.raxmlLight.LB${istart}.run
        do_searches $istart $iend 1 $run_file
        istart=$((iend + 1))
        if [ $submit ] ; then
            sed -i 's/MOREOPTS/PBS -W depend=afterok:'$all_PB_runs'/' $run_file
            raxml_light_jid=$(qsub $run_file)
            all_boot_runs="$raxml_light_jid:$all_boot_runs"
            all_light_runs="$raxml_light_jid:$all_light_runs"
            echo "Submitted job to do bootstrap searches on replica alignments ($raxml_light_jid:$istart)" >> $logfile
            echo $raxml_light_jid >> $idfile

        fi
    done
###
# test bootstopping convergence
    test_bootstopping_convergence
    if [ $submit ] ; then
        sed -i 's/MOREOPTS/PBS -W depend=afterok:'$all_boot_runs'/' ${sequence_file}.test_bootstopping.run
        bootstop_conv_jid=$(qsub ${sequence_file}.test_bootstopping.run)
        echo "Submitted job to test bootstopping convergence ($bootstop_conv_jid)" >> $logfile
        echo $bootstop_conv_jid >> $idfile
    fi
fi
# generate parsimony trees for regular searches if not using best bootstrap trees
if (( rsearches > 0 )) ; then
    if [ ! $usebest ] ; then
        istart=0
        parstreesperjob=$((parscoresperjob / parscores))
        while (( istart < rsearches )) ; do
            iend=$((istart + parstreesperjob - 1))
            if (( iend >= rsearches )) ; then
                iend=$((rsearches - 1))
            fi
            run_file=${sequence_file}.parsimonator.PR${istart}.run
            generate_parsimony_trees $istart $iend 0 $run_file
            istart=$((iend + 1))
            if [ $submit ] ; then
                parsimonator_jid=$(qsub $run_file)
                echo "Submitted job to generate parsimony trees from original alignment ($parsimonator_jid:$istart)" >> $logfile
                echo $parsimonator_jid >> $idfile   
                all_PR_runs="$parsimonator_jid:$all_PR_runs"
            fi
        done

    fi
# do regular searches
    istart=0
    searchesperjob=$((searchcoresperjob / searchcores))
    while (( istart < rsearches )) ; do
        iend=$((istart + searchesperjob - 1))
        if (( iend >= rsearches )) ; then
            iend=$((rsearches - 1))
        fi
        run_file=${sequence_file}.raxmlLight.LR${istart}.run
        do_searches $istart $iend 0 $run_file
        istart=$((iend + 1))
        if [ $submit ] ; then
            if [ ! $usebest ] ; then
                sed -i 's/MOREOPTS/PBS -W depend=afterok:'$all_PR_runs'/' $run_file
            else
                sed -i 's/MOREOPTS/PBS -W depend=afterok:'$all_boot_runs'/' $run_file
            fi
            raxml_light_jid=$(qsub $run_file)
            all_light_runs="$raxml_light_jid:$all_light_runs"
            echo "Submitted job to do regular searches on original alignment ($raxml_light_jid:$istart)" >> $logfile
            echo $raxml_light_jid >> $idfile    
        fi
    done
fi
# calculate support values
if (( bsearches > 0 && rsearches > 0 )) ; then
    calculate_support_values
    if [ $submit ] ; then
        sed -i 's/MOREOPTS/PBS -W depend=afterok:'$all_light_runs'/' ${sequence_file}.calculate_support.run
        support_jid=$(qsub ${sequence_file}.calculate_support.run)
        echo "Submitted job to calculate support values ($support_jid)" >> $logfile
        echo $support_jid >> $idfile    
    fi
fi
# summarize usage
summarize_usage
if [ $submit ] ; then
    if (( bsearches > 0 && rsearches > 0 )) ; then
        sed -i 's/MOREOPTS/PBS -W depend=afterok:'$support_jid'/' ${sequence_file}.summarize_usage.run
    else
        sed -i 's/MOREOPTS/PBS -W depend=afterok:'$all_light_runs'/' ${sequence_file}.summarize_usage.run
    fi
    summarize_jid=$(qsub ${sequence_file}.summarize_usage.run)
    echo "Submitted job to summarize usage ($summarize_jid)" >> $logfile
    echo $summarize_jid >> $idfile  
    echo $summarize_jid
    
    # Create a script that will cancel all the jobs that were submitted.  The cipres portal will
    # invoke this when a user deletes the task.  We cat $donefile on error to return a message to
    # the portal.  Have to build the cancelJobs script in pieces because we don't want $retval
    # expanded, we literally want '$retval' so we have to use 'EOF', but we do want variables
    # like $donefile to be replaced with their values in cancelJobs.
    cat > ./cancelJobs << EOF
#!/bin/bash
echo Cancelling jobs at `date` >> $donefile
echo "Note that this may try to cancel jobs that are already done, generating an expected error." >> $donefile
cat $idfile | xargs qdel >> $donefile 2>&1
EOF
    cat >> ./cancelJobs << 'EOF'
retval=$?
if [  $retval != 0 ]; then
EOF
    cat >> ./cancelJobs << EOF
    cat $donefile
fi
echo "Running qstat immediately after qdel:" >> $donefile
cat $idfile | xargs qstat >> $donefile 2>&1
EOF

    cat >> ./cancelJobs << 'EOF'
exit $retval
EOF

chmod 744 ./cancelJobs

fi
