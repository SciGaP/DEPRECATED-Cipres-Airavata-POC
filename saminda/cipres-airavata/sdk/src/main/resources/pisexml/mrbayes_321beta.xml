<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE pise SYSTEM "http://www.phylo.org/dev/rami/PARSER/pise2.dtd">
<pise>
	<head>
		<title>MrBayes 3.2.1 (BETA) on XSEDE</title>
		<version>3.2.1</version>
		<description>Tree Inference Using Bayesian Analysis - run on XSEDE</description>
		<authors>John P. Huelsenbeck and Fred Ronquist</authors>
		<reference>
			Huelsenbeck, J. P. and F. Ronquist. 2001. MRBAYES: Bayesian inference of phylogeny. Bioinformatics 17:754-755. 
		</reference>
		<reference>
			Ronquist, F. and J. P. Huelsenbeck. 2003. MRBAYES 3: Bayesian phylogenetic inference under mixed models. Bioinformatics 19:1572-1574. .
		</reference>
		<reference>Ronquist, F., Teslenko, M., van der Mark, P., Ayres, D.L., Darling, A., HÃ¶hna, S., Larget, B., Liu, L., Suchard, M.A., and Huelsenbeck, J.P. 2012 MrBayes 3.2: Efficient Bayesian Phylogenetic Inference and Model Choice Across a Large Model Space 
Syst Biol 61 (3): 539-542 doi:10.1093/sysbio/sys029 
</reference>
		<category>Phylogeny / Alignment</category>
	</head>
	<command>mrbayes_321beta</command>
<!--
*****************************************************************************************************************************************
Created by Mark Miller for CIPRES2, 1_22_2013 or thereabouts.
	Modified to include all MB commands possible from the interface around 7/26/2013
*****************************************************************************************************************************************
-->
<!--new commands missing in MB 3.2 that arent supported yet -->
<!-- Calibrate
This command dates a terminal or interior node in the tree. The format is
calibrate <node_name> = <age_prior>
where <node_name> is the name of a defined interior constraint node or the
name of a terminal node (tip) and <age_prior> is a prior probability distribution
on the age of the node. The latter can either be a fixed date, a uniform
probability distribution between a minimum and a maximum age, or an offset
exponential distribution with a minimum age and a rate parameter. The
format is:
calibrate <node_name> = fixed(<age>)
calibrate <node_name> = uniform(<min_age>,<max_age>)
calibrate <node_name> = offsetexponential(<min_age>,<rate>)
For instance, assume that we had three fossil terminals in our analyses named
'FossilA', 'FossilB', and 'FossilC'. Assume further that we want to fix the
3
age of FossilA to 100.0 million years, we think that FossilB is somewhere
between 100.0 and 200.0 million years old, and that FossilC is at least 300.0
million years old, possibly older but relatively unlikely to be more than
400.0 million years old. Then we might use the commands:
calibrate FossilA = fixed(100) FossilB = uniform(100,200)
calibrate FossilC = offsetexponential(300,0.01)
Note that it is possible to give more than one calibration for each
'calibrate' statement. The offset exponential distribution has its expectation
at the minimum age plus the inverse of the rate parameter. That is, the
offsetexponential(300,0.01) has the minimum 300 , the expectation 400 =
= 300 + 1/0.01 and the mode < 400, so that most of the probability distribution
is on values smaller than 400.
To actually use the calibrations to obtain dated trees, you also need to set
a clock model using relevant 'brlenspr' and 'nodeagepr' options of the 'prset'
command. You may also want to examine the 'clockvarpr' and 'clockratepr' options.
Furthermore, you need to activate the relevant constraint(s) using
'topologypr', if you use any dated interior nodes in the tree.
You may wish to remove a calibration from an interior or terminal node, which
has previously been calibrated. You can do that using
calibrate <node_name> = unconstrained--> 

<!-- Charstat
This command shows the status of all the characters. The correct usage is
charstat
After typing "charstat", the character number, whether it is excluded
or included, and the partition identity are shown. The output is paused
every 100 characters. This pause can be turned off by setting autoclose
to "yes" (set autoclose=yes). I dont think this is useful for our users.-->	
	
<!--   Comparetree                                                                   
                                                                                 
   This command compares the trees in two files, called "filename1" and        
   "filename2". It will output a bivariate plot of the split frequencies       
   as well as plots of the tree distance as a function of the generation. The    
   plots can be used to get a quick indication of whether two runs have con-     
   verged onto the same set of trees. The "Comparetree" command will also      
   produce a ".parts" file and a ".dists" file (these file endings are added 
   to the end of the "Outputname"). The ".parts" file contains the paired    
   split frequencies from the two tree samples; the ".dists" file contains the 
   tree distance values. Note that the "Sumt" command provides a different     
   set of convergence diagnostics tools that you may also want to explore. Un-   
   like "Comparetree", "Sumt" can compare more than two tree samples and     
   will calculate consensus trees and split frequencies from the pooled samples. 
                                                                                 
   Parameter       Options                  Current Setting                      
   ****************************************************************                     
   Filename1       <name>            *****       temp.t                                   
   Filename2       <name>                   temp.t                                   
   Outputname      <name>                   temp.comp                                   
   Burnin          <number>                 0                                   
                                               -->
<!-- Constraint
This command defines a tree constraint. The format for the constraint
command is
constraint <name> [hard|negative|partial] = <taxon list> [:<taxon list>]
There are three types of constraint implemented in MrBayes. The type of the
constraint is specified by using one of the three keywords 'hard', 'negative',
or 'partial' right after the name of the constraint. If no type is specified,
then the constraint is assumed to be 'hard'.
In a rooted tree, a 'hard' constraint forces the taxa in the list to form a
monophyletic group. In an unrooted tree, the taxon split that separates the
taxa in the list from other taxa is forced to be present. The interpretation
of this depends on whether the tree is rooted on a taxon outside the list or
a taxon in the list. If the outgroup is excluded , the taxa in the list are
assumed to form a monophyletic group, but if the outgroup is included, it is
the taxa that are not in the list that are forced together.
A 'negative' constraint bans all the trees that have the listed taxa in the
same subtree. In other words, it is the opposite of a hard constraint.
A 'partial' or backbone constraint is defined in terms of two sets of taxa
separated by a colon character. The constraint forces all taxa in the first
list to form a monophyletic group that does not include any taxon in the
second list. Taxa that are not included in either list can be placed in any
position on the tree, either inside or outside the constrained group. In an
unrooted tree, the two taxon lists can be switched with each other with no
effect. For a rooted tree, it is the taxa in the first list that have to be
monophyletic, that is, these taxa must share a common ancestor not shared with
any taxon in the second list. The taxa in the second list may or may not fall
in a monophyletic group depending on the rooting of the tree.
A list of taxa can be specified using a taxset, taxon names, taxon numbers, or
any combination of the above, sepatated by spaces. The constraint is treated
as an absolute requirement of trees, that is, trees that are not compatible
with the constraint have zero prior (and hence zero posterior) probabilty.
If you are interested in inferring ancestral states for a particular node,
you need to 'hard' constrain that node first using the 'constraint' command.
The same applies if you wish to calibrate an interior node in a dated
analysis. For more information on how to infer ancestral states, see the help
for the 'report' command. For more on dating, see the 'calibrate' command.
It is important to note that simply defining a constraint using this
command is not sufficient for the program to actually implement the
constraint in an analysis. You must also enforce the constraints using
'prset topologypr = constraints (<list of constraints>)'. For more information
on this, see the help on the 'prset' command.
Examples:
constraint myclade = Homo Pan Gorilla
Defines a hard constraint forcing Homo, Pan, and Gorilla to form a monophyletic
group or a split that does not include any other taxa.
constraint forbiddenclade negative = Homo Pan Gorilla
6
Defines a negative constraint that associates all trees where Homon, Pan, and
Gorilla form a monophyletic group with zero posterior probability. In other
words, such trees will not be sampled during MCMC.
constraint backbone partial = Homo Gorilla : Mus
Defines a partial constraint that keeps Mus outside of the clade defined by
the most recent common ancestor of Homo and Gorilla. Other taxa are allowed to
sit anywhere in the tree.
To define a more complex constraint tree, simply combine constraints into a
list when issuing the 'prset topologypr' command.-->
<!-- Delete
This command deletes taxa from the analysis. The correct usage is:
delete <name and/or number and/or taxset> ...
A list of the taxon names or taxon numbers (labelled 1 to ntax in the order
in the matrix) or taxset(s) can be used. For example, the following:
delete 1 2 Homo_sapiens
deletes taxa 1, 2, and the taxon labelled Homo_sapiens from the analysis. -->
	
<!-- Include
This command includes characters that were previously excluded from the
analysis. The correct usage is
include <number> <number> <number>
or
include <number> - <number>
or
include <charset>
or some combination thereof. Moreover, you can use the specifier "\" to
include every nth character. For example, the following
include 1-100\3
would include every third character. As a specific example,
include 2 3 10-14 22
includes sites 2, 3, 10, 11, 12, 13, 14, and 22 from the analysis. Also,
include all
includes all of the characters in the analysis. Including all of the
characters (even if many of them are bad) is a very total-evidence-like
thing to do. Doing this will make a certain group of people very happy.
On the other hand, simply using this program would make those same people
unhappy. -->
	
	
<!-- For all cases, each set of conditions with a dependency on nruns nchains must be 
	duplicated to allow for submission of these parms in the mb block, or the interface -->
	


<!-- Adapted to run on MB 3.2.1 Gordon 

I have only been able to get MrBayes 3.2.1 to work with MPI, the rules for running it are
very simple.

. Calculate np = nruns*nchains, which is the number of MPI processes.

. If np <= 8, run in the shared queue.

. If np >8 but <= 16, run in the normal queue.

. If np > 16, tell the user to make np smaller.

That's it.

The code runs with OpenMPI, not MVAPICH2, from my /home directory.  A sample PBS file is appended,
and the input and output files are at /oasis/projects/nsf/use320/pfeiffer/MrBayes-3.2.1_gordon/Mike/mpi8.10kgen

A significant new feature in the new version of MrBayes is checkpoint/restart.  

A checkpoint file with suffix ckp is written periodically.  The default frequency is 100,000 
generations and is controlled by checkfreq in the mcmc block of the nex file.
	
To restart, the ckp file as well as the mcmc, p, and t files need to be input along with the
nex file.  You should consider how best to handle this.

In my sample script, I redirect the stdout file to one with the prefix log. 
In this case I use >> for redirection to allow the file to be updated rather than overwritten
upon restart. This would require that the stdout file be input upon restart, but maybe you run
differently via the gateway.  If you do run the same way as I do, then >> can be used for the
initial run as well. In addition, the user needs to add append=yes to the mcmc block in the nex
file, but only for the restart run.  

	Also, if the original run completed the number of generations specified, then that number needs
to be increased in the nex file.

I think users should be encouraged to become familiar with checkpoint/restart.  This could allow
them to specify a smaller number of generations for a run than they might have done previously,
especially since the new version of MrBayes often converges faster. If the run has converged
sufficiently, they are done.  Otherwise, they could restart and run longer until they get
convergence or find that they need more data.

* Let me know if you have any questions.

*******************************************************************************
	Here is the script
*******************************************************************************
#!/bin/bash
#PBS -N mpi8.10kgen
#PBS -q shared
#PBS -l nodes=1:ppn=8:native:noflash
#PBS -v QOS=10
#PBS -l walltime=1:00:00
#PBS -m abe
#PBS -M pfeiffer@sdsc.edu
#PBS -V
#PBS -A use320
cd $PBS_O_WORKDIR
source /etc/profile.d/modules.sh
module unload mvapich2_ib
module load openmpi_ib
mpirun -hostfile $PBS_NODEFILE -np 8 /home/pfeiffer/gordon/MrBayes-3.2.1/mb infile.nex >> log.mpi8.10kgen.txt qstat -f $PBS_JOBID | grep Job qstat -f $PBS_JOBID | grep resources

-->
	
<!-- this section defines a file scheduler.conf that accompanies the command line to the TG 
resource. It instructs the machine how to run the job. Unlike the raxml interface, the individual
lines of the file are broken up. This is necessary because of the $mrbayesblockquery element,
which affects individual lines in this file --> 

	<parameters>
<!--  on gordon   -->
					<parameter ismandatory="1" ishidden="1" type="String">
						<name>mbmpi_321</name>
						<attributes>
							<format>
								<language>perl</language>	
								<code>"<![CDATA[mb_3.2.1_mpiwrapper paramfile.txt]]>"</code>
							</format>
							<group>0</group>
						</attributes>
					</parameter>	
		
<!-- this sets the mpi process value when the values nruns/nchains are set in the MB block -->
		<parameter type="Integer" ishidden="1" >
					<name>mpi_processes_conf</name>
					<attributes>
						<group>3</group>
						<paramfile>scheduler.conf</paramfile>
						<precond>
							<language>perl</language>
							<code>$mrbayesblockquery</code>
						</precond>
						<format>
							<language>perl</language>
							<code>	"jobtype=mpi\\n" .
									"mpi_processes=" .  $nchains_specified * $nruns_specified  . "\\n"</code>
						</format>
					</attributes>
				</parameter>
		
<!-- this sets the mpi process value when the nruns/nchains values are set in the interface -->
		<parameter type="Integer" ishidden="1" >
					<name>mpi_processes_conf2</name>
					<attributes>
						<group>3</group>
						<paramfile>scheduler.conf</paramfile>
						<precond>
							<language>perl</language>
							<code>!$mrbayesblockquery</code>
						</precond>
						<format>
							<language>perl</language>
							<code>	"jobtype=mpi\\n" .
									"mpi_processes=" .  $nchainsval * $nrunsval  . "\\n"</code>
						</format>
					</attributes>
				</parameter>

<!-- always run on one node -->												
				<parameter type="String" ishidden="1" >
					<name>number_nodes</name>
					<attributes>
						<group>2</group>
						<paramfile>scheduler.conf</paramfile>
						<format>
							<language>perl</language>
							<code>"nodes=1\\n"</code>
						</format>
					</attributes>
				</parameter>		
		
<!-- This begins the parameter settings, all are compiled into a big file for delivery in batch mode -->	
		<parameter ismandatory="1" isinput="1" type="Sequence">
			<name>infile</name>
			<attributes>
				<prompt>Input File (must be in Nexus format) (-execute)</prompt>
				<paramfile>paramfile.txt</paramfile>
				<format>
					<language>perl</language>
					<code>"execute infile.nex\\n"</code>
				</format>
				<group>2</group>
				<filenames>infile.nex</filenames>
			</attributes>
		</parameter>
		
<!-- First, set the autoclose feature:set autoclose=<yes/no>  If autoclose is set to yes, then the program will not prompt you during the course of executing a file. -->

		<parameter issimple="1" ismandatory="1" ishidden="1" type="String">
			<name>setopts</name>
			<attributes>
				<prompt></prompt>
				<paramfile>paramfile.txt</paramfile>
				<format>
					<language>perl</language>
					<code>"set autoclose=yes\\n"</code>
				</format>
				<group>1</group>
			</attributes>
		</parameter>

<!-- Next, set the nowarn option. the program will issue a prompt when overwriting an output file that is already present -->

		<parameter issimple="1" ismandatory="1" ishidden="1" type="String">
			<name>setwarnopts</name>
			<attributes>
				<paramfile>paramfile.txt</paramfile>
				<prompt></prompt>
				<format>
					<language>perl</language>
					<code>"set nowarnings=yes\\n"</code>
				</format>
				<group>1</group>
			</attributes>
		</parameter>
				
<!--Fourth, set the quitonerror feature to yes so the program will quit when an error is encountered, after printing an error message. If quitonerror=no (the default setting) then the program will wait for additional commands from the command line after printing the error message. -->
<!--  this parameter is broken in mrbayes 3.1.2
		<parameter issimple="1" ismandatory="1" ishidden="1" type="String">
			<name>setquitopts</name>
			<attributes>
				<paramfile>paramfile.txt</paramfile>
				<prompt></prompt>
				<format>
					<language>perl</language>
					<code>"set quitonerror=yes\\n"</code>
				</format>
				<group>1</group>
			</attributes>
		</parameter> -->
		
<!--format log start/stop filename=<name> append/replace specfiy the name of the output file, Start/Stop logging of output to a file. Use Append/Replace to append or replace existing file. 
Set to append here out of uncertainty, we want to capture everything at first.-->
<!--		<parameter issimple="1" ishidden="0" type="Switch">
			<name>logfileon</name>
			<attributes>
				<prompt>Append to log file</prompt>
				<paramfile>paramfile.txt</paramfile>
				<format>
					<language>perl</language>
					<code> ($value)? "log start filename=mrbayeslog.out append\\n" : "log start filename=mrbayeslog.out replace\\n" </code>
				</format>
				<vdef>
					<value>1</value>				
				</vdef>
				<group>4</group>
			</attributes>
		</parameter> -->
		
<!-- The quit command forces MrBayes to terminate. With previous versions of MrBayes there were problems with infinite loops when the quit command was not included at the end of the file. This problem has been solved in version 3.1, however we advise you to still use the quit command.  (???)  -->
		<parameter ishidden="1" type="String">
			<name>mrbayes_closeout</name>
			<attributes>
				<format>
					<language>perl</language>
					<code>"quit\\n"</code>
				</format>
				<paramfile>paramfile.txt</paramfile>
				<group>99</group>
			</attributes>
		</parameter>
		
<!--    return all results                -->		
		<parameter type="Results">
			<name>ALL_FILES</name>
			<attributes>
				<filenames>*</filenames>
			</attributes>
		</parameter> 

<!--    all runs produce this file                -->
<!-- this file is not produced on globus run tools
		<parameter ishidden="1" type="Results">
			<name>log_file</name>
			<attributes>
				<filenames>log.txt</filenames>
			</attributes>
		</parameter> -->
 	
<!-- visible parameters -->		
<!-- This section provides visible queries that help configure the interface  -->
	<!-- turn off all interfaceoptions when a MrBayes block is present -->
				<parameter issimple="1" ismandatory="1" type="Switch">
					<name>mrbayesblockquery</name>
					<attributes>
						<group>1</group>
						<prompt>My Data Contains a MrBayes Data Block (CHECK THIS OR MrBayes BLOCK ENTRIES WILL BE OVERWRITTEN!!!)</prompt>
						<format>
							<language>perl</language>
							<code>($value)? "":""</code>
						</format>	
						<vdef>
							<value>0</value>
						</vdef>
						<comment>
							<value>This interface allows you to configure MrBayes from the command line, or from a MrBayes block in your data file. 
							However, you must choose one or the other.  So, if you have a MrBayes Block in your data, you should configure the entire 
							run in that block (see the MrBayes manual for help on how to do this). It is our belief that MrBayes is sufficiently complex
							in its command structure and use that if you want to analyse multiple partitions and multiple datatypes you should do it in 
							the Nexus file structure. The current interface supports multiple data partitions ONLY in the Nexus file. If you need more 
							options than we provide, please let us know: http://www.ngbw.org/ngbugz. Other options are not included in this interface 
							because they (and any complex MrBayes runs) are much better handled in the MrBayes block of your data file, are more useful 
							for interactive running, or are not appropriate for batch runs. These include: Ctype, Link, Unlink, Delete, Include, 
							Restore, Props, Plot, and Comparetree, the prset option Aarevmatpropts is not supported; the lset Ploidy option does not 
							seem to be working in MrBayes 3.1.2. Any parameters requiring printing to the screen are not supported for obvious reasons. 
							Importantly, unlike the command line version, it is not possible to upload a MrBayes block file that calls a separate data 
							file with your matrix.
							</value>
						</comment>
					</attributes>
				</parameter>	
			
				<parameter issimple="1" ismandatory="1" type="Switch">
					<name>set_autoclose_confirm</name>
					<attributes>
						<group>1</group>
						<prompt>I confirm that there is not an "autoclose = no" statement in my MrBayes block</prompt>
						<precond>
							<language>perl</language>
							<code>$mrbayesblockquery</code>
						</precond>
						<format>
							<language>perl</language>
							<code>($value)? "":""</code>
						</format>
						<ctrls>
							<ctrl>
								<message>Please acknowledge that there is not a "set autoclose = no" statement in the MrBayes block of your Nexus file</message>
								<language>perl</language>
								<code>!$set_autoclose_confirm</code>
							</ctrl>
						</ctrls>	
						<vdef>
							<value>0</value>
						</vdef>
						<comment>
							<value>Putting an "autoclose = no" statement in your MrBayes block will cause catastrophic failure of the job, and may impact others. Please be careful. 
							</value>
						</comment>
					</attributes>
				</parameter>

				<parameter type="Integer" issimple="1" >
					<name>nruns_specified</name>
					<attributes>
						<group>1</group>
						<prompt>My MrBayes Block specifies nruns=</prompt>
						<paramfile>scheduler.conf</paramfile>
						<precond>
							<language>perl</language>
							<code>$mrbayesblockquery</code>
						</precond>
						<vdef>
							<value>2</value>
						</vdef>
						<comment>
							<value>The values entered for nruns and nchains influence the number of cpu's that can be used in parallel.  Please enter the value you specified for 
							nruns in the MrBayes block of the Nexus file.  If you didn't specify a value for nruns, please leave this field at its default value of 2.
							</value>
						</comment>
						<ctrls>					
<!-- Determine nruns, the number of runs, and nchains, the number of chains, Check that np is a multiple of 2 and <= 16.
If not, ask the user to change parameters to ensure that. -->
<!-- we should repeat these statements below for values entered in the interface -->
							
							<ctrl>
								<message>Please enter value for nruns</message>
								<language>perl</language>
								<code>!$nruns_specified</code>
							</ctrl>
							<ctrl>
								<message>The value of nruns must be greater than 0</message>
								<language>perl</language>
								<code>$nruns_specified &lt; 1</code>
							</ctrl>
							<ctrl>
								<message>nruns x nchains must be a multiple of 2</message>
								<language>perl</language>
								<code>((($nruns_specified * $nchains_specified) % 2) != 0)</code>
							</ctrl>
							<ctrl>
								<message>nruns x nchains must be less than or equal to 16.</message>
								<language>perl</language>
								<code>($nruns_specified * $nchains_specified &gt; 17) </code>
							</ctrl>
						</ctrls>
					</attributes>
				</parameter>

				<parameter type="Integer" issimple="1" >
					<name>nchains_specified</name>
					<attributes>
						<group>1</group>
						<prompt>My MrBayes Block specifies nchains=</prompt>
						<paramfile>scheduler.conf</paramfile>
						<precond>
							<language>perl</language>
							<code>$mrbayesblockquery</code>
						</precond>
						<vdef>
							<value>4</value>
						</vdef>
						<comment>
							<value>The value entered for nruns and nchains influences the number of cpu's that can be used in parallel.  Enter the value you specified 
							for nchains in the MrBayes block of the nexus file.  If you didn't specify a value for nchains, please leave this field at its default value of 4.
							</value>
						</comment>
<!-- we should repeat these statements below for values entered in the interface -->
						<ctrls>
							<ctrl>
								<message>Please enter value for nchains</message>
								<language>perl</language>
								<code>!$nchains_specified</code>
							</ctrl>
							<ctrl>
								<message>The value of nchains must be greater than 0</message>
								<language>perl</language>
								<code>$nchains_specified &lt; 1</code>
							</ctrl>
							<ctrl>
								<message>The value for nchains must be 1 or greater. The recommended value is at least 4.</message>
								<language>perl</language>
								<code>$nchains_specified &lt; 1</code>
							</ctrl>
							<ctrl>
								<message>nruns x nchains must be less than or equal to 16.</message>
								<language>perl</language>
								<code>($nruns_specified * $nchains_specified &gt; 17) </code>
							</ctrl>
							<ctrl>
								<message>nruns x nchains must be a multiple of 2</message>
								<language>perl</language>
								<code>((($nruns_specified * $nchains_specified) % 2) != 0)</code>
							</ctrl>
						</ctrls>
						<!-- this is for values entered in the mb block -->
						<warns>
							<warn>
								<message>The job will run on 2 processors as configured. If it runs for the entire configured time, it will consume 2 x $runtime cpu hours</message>
								<language>perl</language>
								<code>$mrbayesblockquery &amp;&amp; $nchains_specified * $nruns_specified == 2</code>
							</warn>
							<warn>
								<message>The job will run on 4 processors as configured. If it runs for the entire configured time, it will consume 4 x $runtime cpu hours</message>
								<language>perl</language>
								<code>$mrbayesblockquery &amp;&amp; $nchains_specified * $nruns_specified == 4</code>
							</warn>
							<warn>
								<message>The job will run on 6 processors as configured. If it runs for the entire configured time, it will consume 6 x $runtime cpu hours</message>
								<language>perl</language>
								<code>$mrbayesblockquery &amp;&amp; $nchains_specified * $nruns_specified == 6</code>
							</warn>
							<warn>
								<message>The job will run on 8 processors as configured. If it runs for the entire configured time, it will consume 8 x $runtime cpu hours</message>
								<language>perl</language>
								<code>$mrbayesblockquery &amp;&amp; $nchains_specified * $nruns_specified == 8</code>
							</warn>
							<warn>
								<message>The job will run on 16 processors as configured. If it runs for the entire configured time, it will consume 16 x $runtime cpu hours</message>
								<language>perl</language>
								<code>$mrbayesblockquery &amp;&amp; $nchains_specified * $nruns_specified &gt; 8 </code>
							</warn>
						</warns> 
					</attributes>
				</parameter>

<!--how many generations -->
<!--	I commented this out for now, will re-add if it causes problems	
				<parameter type="Integer" issimple="1" >
					<name>ngen_specified</name>
					<attributes>
						<group>1</group>
						<prompt>How many generations will your job run?</prompt>
						<ctrls>
							<ctrl>
								<message>Please enter a value for the number of generations specified</message>
								<language>perl</language>
								<code>!defined $ngen_specified</code>
							</ctrl>
						</ctrls>
						<comment>
<value>The number of samples produced is used to warn about possible issues with output file size.</value>
						</comment>
					</attributes>
				</parameter> -->

<!-- Sampling frequency. Gen times sampling frequency is used to warn about .t file size -->
<!--				<parameter issimple="1" ismandatory="1" type="Integer">
					<name>sample_freq</name>
					<attributes>
						<group>1</group>
						<prompt>What is the sample frequency for your data set?</prompt>
						<vdef>
							<value>100</value>
						</vdef>
						<ctrls>
							<ctrl>
								<message>Please enter a value for the sample frequency</message>
								<language>perl</language>
								<code>!defined $sample_freq</code>
							</ctrl>
						</ctrls>
						<warns>
							<warn>
								<message>The number of samplings you requested is greater than 50,000. This may cause your output files to exceed the allowed limit of 500 GB. Please consider editing your input file to request a lower sample frequency.</message>
								<language>perl</language>
								<code>$ngen_specified  &gt; 50000 * $sample_freq </code>		
							</warn>
						</warns>
					</attributes>
				</parameter> -->
				
<!-- this was added by mamiller, so a user can specify they are using a partition -->
			
<!--	not used currently			<parameter issimple="1" ismandatory="1" type="Switch">
					<name>is_partitioned</name>
					<attributes>
						<group>0</group>
						<prompt>My data set is partitioned</prompt>
						<vdef>
							<value>0</value>
						</vdef>
						<comment>
							<value>This option will help the application determine how to run the job</value>
						</comment>
					</attributes>
				</parameter> -->
				
<!-- this sets the max run time -->
				<parameter type="Float" issimple="1" ismandatory="1">
					<name>runtime</name> 
					<attributes>
						<group>1</group>
						<paramfile>scheduler.conf</paramfile>
						<prompt>Maximum Hours to Run (click here for help setting this correctly)</prompt>
						<vdef><value>0.5</value></vdef>
						<ctrls>
							<ctrl>
								<message>The maximum hours to run must be less than 168</message>
								<language>perl</language>
								<code>$runtime &gt; 168.0</code>
							</ctrl>
							<ctrl>
								<message>Please enter a positive number for the maximum runtime</message>
								<language>perl</language>
								<code>$runtime &lt; 0</code>
							</ctrl>
							<ctrl>
								<message>Please specify a maximum runtime</message>
								<language>perl</language>
								<code>!defined $runtime </code>
							</ctrl>
						</ctrls>
						<format>
							<language>perl</language>
							<code>"runhours=$value\\n"</code>
						</format>

<!-- xxxxxxxx added by mamiller to provide feedback on number of cpu hrs to be consumed -->
						<comment>
<value>Estimate the maximum time your job will need to run. We recommend testing initially with a &lt; 0.5hr test run because Jobs set for 0.5 h or less depedendably run immediately in the "debug" queue. 
Once you are sure the configuration is correct, you then increase the time. The reason is that jobs &gt; 0.5 h are submitted to the "normal" queue, where jobs configured for 1 or a few hours times may
run sooner than jobs configured for the full 168 hours. 
</value>
						</comment>
					</attributes>
				</parameter>

<!-- let the user specify data to control options; this doesn't do anything yet, because I was having trouble with preconds as it is.
	however, it should make it easier to configure the run form the interface by greying out irrelevant options -->		
<!--				<parameter issimple="1" ismandatory="1" type="Excl">
			<name>flagdatatype</name>
			<attributes>
				<prompt>My Data Type Is (only one data type through the web form, see help below)</prompt>
				<format>
					<language>perl</language>
					<code>($value)? "" : ""</code>
				</format>
				<vdef>
					<value>dna</value>
					</vdef>	
				<vlist>
					<value>dna</value>
					<label>nucleic acid</label>
					<value>protein</value>
					<label>protein</label>
					<value>standard</value>
					<label>standard</label>
					<value>other</value>
					<label>other</label>
				</vlist>
				<comment>
<value>Setting this flag helps us eliminate uneeded options</value>
				</comment>
			</attributes>
		</parameter> -->
<!-- simple set params -->		
					<parameter type="Integer" issimple="1">
						<name>seed</name>
						<attributes>
							<prompt>Set the Seed Number Set seed=</prompt>
							<paramfile>paramfile.txt</paramfile>
							<precond>
								<language>perl</language>
								<code>!$mrbayesblockquery</code>
							</precond>
							<vdef>
								<value>1116355510</value>
							</vdef>
							<format>
								<language>perl</language>
								<code>(defined $value) ? "set seed=$value\\n":""</code>
							</format>
							<group>1</group>
							<comment>
<value>Sets the seed number for the random number generator. The random number seed is initialized haphazardly at the beginning of each MrBayes session. This option allows you to set the seed to some specific value, thereby allowing you to exactly repeat an analysis. If the analysis uses swapping between cold and heated chains, you must also set the swap seed (see below) to exactly repeat the analysis.
</value>
							</comment>
						</attributes>
					</parameter>
					<parameter type="Integer" issimple="1">
						<name>swapseed</name>
						<attributes>
							<prompt>Set the Swapseed=</prompt>
							<paramfile>paramfile.txt</paramfile>
							<precond>
								<language>perl</language>
								<code>!$mrbayesblockquery</code>
							</precond>
							<vdef>
								<value>1116355510</value>
							</vdef>
							<format>
								<language>perl</language>
								<code>(defined $value) ? "set swapseed=$value\\n":""</code>
							</format>
							<group>1</group>
							<comment>
								<value>Sets the seed used for generating the swapping sequence when Metropolis-coupled heated chains are used. By deafult, this seed is generated at the beginning of each MrBayes session. This option allows you to set the seed to some specific value, thereby allowing you to exactly repeat a swap sequence.                     
</value>
							</comment>
						</attributes>
					</parameter>
		
					<parameter type="Switch" issimple="1">
						<name>scientific</name>
						<attributes>
							<prompt>Use scientific notation</prompt>
							<paramfile>paramfile.txt</paramfile>
							<precond>
								<language>perl</language>
								<code>!$mrbayesblockquery</code>
							</precond>
							<vdef>
								<value>0</value>
							</vdef>
							<format>
								<language>perl</language>
								<code>(defined $value) ? "set scientific=Yes\\n":"set scientific=No\\n"</code>
							</format>
							<group>1</group>
							<comment>
								<value>Write output in scientific notation (higher precision). Otherwise, use fixed format (easier for humans to read).                    
</value>
							</comment>
						</attributes>
					</parameter>
		
					<parameter type="Integer" issimple="1">
						<name>precision</name>
						<attributes>
							<prompt>How many decimals should we print?</prompt>
							<paramfile>paramfile.txt</paramfile>
							<precond>
								<language>perl</language>
								<code>!$mrbayesblockquery</code>
							</precond>
							<vdef>
								<value>15</value>
							</vdef>
							<format>
								<language>perl</language>
								<code>(defined $value) ? "set precision = $value\\n":""</code>
							</format>
							<group>1</group>
							<ctrls>
								<ctrl>
									<message>Please set the precsion to a number between 3 and 15. 15 is the default.</message>
									<language>perl</language>
									<code>$value &lt; 3</code>
								</ctrl>
								<ctrl>
									<message>Please set the precsion to a number between 3 and 15. 15 is the default.</message>
									<language>perl</language>
									<code>$value &gt; 15</code>
								</ctrl>
							</ctrls>
							<comment>
								<value>Set the number of decimals to print your results in. Values of 3-15 are permitted.                    
</value>
							</comment>
						</attributes>
					</parameter>
<!-- If you put the following line into the text-file that you generate, 
	above the place where you read the user's .nex file, it should set it to use beagle:
The next question: Is Beagle even included in the LD_LIBRARY_PATH when you run MrBayes currently?
"""
set usebeagle=yes beagleprecision=double beaglesse=yes beaglescaling=dynamic beagleopenmp=no beaglethreads=no; 

"""

-->
<!-- added for MB 3.2 -->		
					<parameter type="Switch" issimple="1">
						<name>set_beagle_params</name>
						<attributes>
							<prompt>Run BEAGLE</prompt>
							<paramfile>paramfile.txt</paramfile>
							<format>
								<language>perl</language>
								<code>$value ? "set usebeagle=yes beagleprecision=double beaglesse=yes beaglescaling=dynamic beagleopenmp=no beaglethreads=no\\n":""</code>
							</format>
							<vdef>
								<value>1</value>
							</vdef>
							<group>1</group>
							<comment>
								<value>With this command, "outgroup 3" assigns the third taxon in the matrix to be the outgroup. Similarly, "outgroup Homo_sapiens" assings the taxon "Homo_sapiens" to be the outgroup (assuming that there is a taxon named "Homo_sapiens" in the matrix). Only a single taxon can be assigned to be the outgroup.
	</value>
							</comment>
						</attributes>
					</parameter>
		
<!-- added for MB 3.2 -->		
					<parameter type="String" issimple="1">
						<name>set_outgroup</name>
						<attributes>
							<prompt>Specify (only) one outgroup</prompt>
							<paramfile>paramfile.txt</paramfile>
							<precond>
								<language>perl</language>
								<code>!$mrbayesblockquery</code>
							</precond>
							<format>
								<language>perl</language>
								<code>(defined $value) ? "outgroup=$value\\n":""</code>
							</format>
							<group>1</group>
							<comment>
								<value>With this command, "outgroup 3" assigns the third taxon in the matrix to be the outgroup. Similarly, "outgroup Homo_sapiens" assings the taxon "Homo_sapiens" to be the outgroup (assuming that there is a taxon named "Homo_sapiens" in the matrix). Only a single taxon can be assigned to be the outgroup.
	</value>
							</comment>
						</attributes>
					</parameter>
		
<!-- simple set params -->
		
		<parameter type="Paragraph">
			<paragraph>
				<name>lsetopts</name>
				<prompt>Likelihood Model Parameters</prompt>
				<!--*******************************************************************************************
All of the parameters in this section must be preceded by the string lset
***********************************************************************************************-->
				<!--<precond>
						<language>perl</language>
						<code>!$mrbayesblockquery</code>
		</precond> -->
				<parameters>
					<!-- this section is for adding the applyto command, not quite ready for this yet.....-->
					<!--	<parameter ismandatory="1" type="Excl">
					<name>applylsetopts1</name>
					<attributes>
						<prompt>Apply these parameters to Entire Data Set, or Partition 1</prompt>
						<format>
							<language>perl</language>
							<code>"applyto=(1)\\n"</code>
						</format> 
						<group>5</group>
					</attributes>
				</parameter>     -->
					<parameter ismandatory="1" type="Excl">
						<name>nstopts</name>
						<attributes>
							<prompt>Set the number of substitution types (Nst=)</prompt>
							<precond>
								<language>perl</language>
								<code>!$mrbayesblockquery</code>
							</precond>
							<paramfile>paramfile.txt</paramfile>
							<format>
								<language>perl</language>
								<code>"lset Nst= $value\\n"</code>
							</format>
							<vdef>
								<value>1</value>
							</vdef>
							<vlist>
								<value>1</value>
								<label>1</label>
								<value>2</value>
								<label>2</label>
								<value>6</value>
								<label>6</label>
<!-- added for mb 3.2 -->
								<value>mixed</value>
								<label>mixed</label>
							</vlist>
							<group>5</group>
							<comment>
								<value>Sets the number of substitution types: "1" constrains all of the rates to be the same (e.g., a JC69 or F81 model); "2" allows transitions and transversions to have potentially different rates (e.g., a K80 or HKY85 model); "6" allows all rates to be different, subject to the constraint of time-reversibility (e.g., a GTR model).                                              
</value>
							</comment>
						</attributes>
					</parameter>
					<parameter ismandatory="1" type="Excl">
						<name>nucmodelopts</name>
						<attributes>
							<prompt>Set the nucleotide substitution model (Nucmodel=)</prompt>
							<paramfile>paramfile.txt</paramfile>
							<precond>
								<language>perl</language>
								<code>!$mrbayesblockquery</code>
							</precond>
							<format>
								<language>perl</language>
								<code>"lset Nucmodel= $value\\n"</code>
							</format>
							<vdef>
								<value>4by4</value>
							</vdef>
							<vlist>
								<value>4by4</value>
								<label>4 X 4</label>
								<value>doublet</value>
								<label>doublet</label>
								<value>codon</value>
								<label>codon</label>
<!--added for mb 3.2-->
								<value>protein</value>
								<label>protein</label>
							</vlist>
							<group>5</group>
							<comment>
								<value>This parameter specifies the general form of the nucleotide substitution model. The options are "4by4" [the standard model of DNA substitution in which there are only four states (A,C,G,T/U)],   "doublet" (a model appropriate for modelling the stem regions of ribosomal genes where the state space is the 16 doublets of nucleotides), and "codon" (the substitution model is expanded around triplets of nucleotides--a codon).</value>
							</comment>
						</attributes>
					</parameter>
					
					<parameter ismandatory="1" type="Excl">
						<name>codonopts</name>
						<attributes>
							<prompt>Set the Codon translation table (Codon=)</prompt>
							<paramfile>paramfile.txt</paramfile>
							<format>
								<language>perl</language>
								<code>"lset Code= $value\\n"</code>
							</format>
							<precond>
								<language>perl</language>
								<code>$nucmodelopts eq "codon" &amp;&amp; !$mrbayesblockquery</code>
							</precond>
							<vdef>
								<value>Universal</value>
							</vdef>
							<vlist>
								<value>universal</value>
								<label>Universal</label>
								<value>vertmt</value>
								<label>Vertebrate Mitochondria</label>
								<value>mycoplasma</value>
								<label>Mycoplasma</label>
								<value>ciliates</value>
								<label>Ciliates</label>
								<value>metmt</value>
								<label>Non-vertebrate Metazoan Mitochondria</label>
								<value>yeast</value>
								<label>Yeast</label>
							</vlist>
							<group>5</group>
						</attributes>
					</parameter>
					
					<parameter ismandatory="1" type="Excl">
						<name>omegavaropts</name>
						<attributes>
							<prompt>Allow the nonsynonymous/synonymous rate ratio (omega) (Omegavar=)</prompt>
							<paramfile>paramfile.txt</paramfile>
							<precond>
								<language>perl</language>
								<code>!$mrbayesblockquery &amp;&amp; $nucmodelopts eq "codon"</code>
							</precond>
							<format>
								<language>perl</language>
								<code>"lset omegavar= $value\\n"</code>
							</format>
							<vdef>
								<value>equal</value>
							</vdef>
							<vlist>
								<value>equal</value>
								<label>equal</label>
								<value>Ny98</value>
								<label>Ny98</label>
								<value>M3</value>
								<label>M3</label>
							</vlist>
							<group>5</group>
							<comment>
								<value>Allows the nonsynonymous/synonymous rate ratio (omega) to vary across codons. Ny98 assumes that there are three classes, with potentially different omega values (omega1, omega2, omega3): omega2 = 1; omega1 is less than 1 but greater than 0; and omega3 is greater than 1. Like the Ny98 model,  the M3 model has three omega classes. However, their values are  less constrained, with omega1 less than omega2, which is less than omega3. The default (omegavar = equal) has no variation on omega across sites.</value>
							</comment>
						</attributes>
					</parameter>
<!-- our version of mrbayes does not know this command -->
				<parameter ismandatory="1" type="Excl">
					<name>ploidyopts</name>
					<attributes>
						<prompt>Set the ploidy (Ploidy=)</prompt>
						<format>
							<language>perl</language>
							<code>"Ploidy= $value\\n"</code>
						</format>
						<precond>
							<language>perl</language>
							<code>$brlenspropts eq "clock:coalescence"</code>
						</precond>
						<vdef>
							<value>Diploid</value>
						</vdef>
						<vlist>
							<value>Diploid</value>
							<label>Diploid</label>
							<value>Haploid</value>
							<label>Haploid</label>
							<value>zlinked</value>
							<label>zlinked</label>
						</vlist>
						<group>5</group>
						<comment>
<value>This option is used when a coalescence prior is used on trees.                                                 
</value>
						</comment>
					</attributes>
				</parameter> 
					<parameter ismandatory="1" type="Excl">
						<name>rateopts</name>
						<attributes>
							<prompt>Set the model for among-site rate variation (Rates=)</prompt>
							<paramfile>paramfile.txt</paramfile>
							<precond>
								<language>perl</language>
								<code>!$mrbayesblockquery</code>
							</precond>
							<format>
								<language>perl</language>
								<code>"lset Rates= $value\\n"</code>
							</format>
							<vdef>
								<value>equal</value>
							</vdef>
							<vlist>
								<value>equal</value>
								<label>equal</label>
								<value>gamma</value>
								<label>gamma</label>
								<value>adgamma</value>
								<label>adgamma</label>
								<value>propinv</value>
								<label>propinv</label>
								<value>invgamma</value>
								<label>invgamma</label>
							</vlist>
							<group>5</group>
							<comment>
								<value>In general, the rate at a site is considered to be an unknown random variable. Valid options are: equal:No rate variation across sites; gamma: The rate at a site is drawn from a gamma distribution. The gamma distribution has a single parameter that describes how much rates vary; adgamma:  Autocorrelated rates across sites. The marginal rate distribution is gamma, but adjacent sites have correlated rates; propinv  -- A proportion of the sites are invariable; invgamma -- A proportion of the sites are invariable while the rate for the remaining sites are drawn from a gamma distribution.Note that MrBayes versions 2.0 and earlier supported options that allowed site specific rates (e.g., ssgamma). In versions 3.0 and later, site specific rates are allowed, but set using the 'prset ratepr' command for each partition.                    
</value>
							</comment>
						</attributes>
					</parameter>
					<parameter type="Integer">
						<name>Ngammacatopts</name>
						<attributes>
							<prompt>Set number of rate categories for gamma distribution (Ngammacat=)</prompt>
							<paramfile>paramfile.txt</paramfile>
							<precond>
								<language>perl</language>
								<code>!$mrbayesblockquery &amp;&amp; $rateopts eq "gamma"</code>
							</precond>
							<format>
								<language>perl</language>
								<code>"lset Ngammacat= $value\\n"</code>
							</format>
							<vdef>
								<value>4</value>
							</vdef>
							<group>5</group>
							<comment>
								<value>The Ngammacat parameter sets the number of rate categories for the gamma distribution. The gamma distribution is continuous. However, it is virtually impossible to calculate likelihoods under the continuous gamma distribution. Hence, an approximation to the continuous gamma is used; the gamma distribution is broken into ncat categories of equal weight (1/ncat). The mean rate for each category represents the rate for the entire cateogry. This option allows you to specify how many rate categories to use when approximating the gamma. The approximation is better as ncat is increased. In practice, "ncat=4" does a reasonable job of approximating the continuous gamma.                               
</value>
							</comment>
						</attributes>
					</parameter>
					<parameter type="Integer">
						<name>Nbetacatopts</name>
						<attributes>
							<prompt>Set number of rate categories for beta distribution (Nbetacat=)</prompt>
							<paramfile>paramfile.txt</paramfile>
							<precond>
								<language>perl</language>
								<code>!$mrbayesblockquery</code>
							</precond>
							<format>
								<language>perl</language>
								<code>"lset Nbetacat= $value\\n"</code>
							</format>
							<vdef>
								<value>5</value>
							</vdef>
							<group>5</group>
							<comment>
								<value>A symmetric beta distribution is used to model the stationary frequencies when morphological data are used. This option specifies how well the beta distribution will be approximated.</value>
							</comment>
						</attributes>
					</parameter>
					<parameter type="Switch">
						<name>Covarionopts</name>
						<attributes>
							<prompt>Force the use of covarion-like model (4X4 dna model, or protein) (Covarion=)</prompt>
							<paramfile>paramfile.txt</paramfile>
							<!-- precond for 4x4 model (dna) or protein model-->
							<!--			<precond>
worried about this
							<language>perl</language>
			 			<code>$nucmodelopts eq "4by4" || $aamodelpropts !=""</code>
						</precond> -->
							<precond>
								<language>perl</language>
								<code>!$mrbayesblockquery</code>
							</precond>
							<format>
								<language>perl</language>
								<code>($value)? "lset Covarion = Yes\\n":""</code>
							</format>
							<vdef>
								<value>0</value>
							</vdef>
							<group>5</group>
							<comment>
								<value>This forces the use of a covarion-like model of substitution for nucleotide or amino acid data (it is not used for other data types).The valid options are "yes"  and "no". The covarion model allows the rate at a site to change over its evolutionary history. Specifically, the site is either on or off. When it is off, no substitutions are possible. When the process is on, substitutions occur according to a specified substitution model (specified using the other lset options).                                                    
</value>
							</comment>
						</attributes>
					</parameter>
					
					<parameter ismandatory="1" type="Excl">
						<name>codingopts</name>
						<attributes>
							<prompt>Specify how characters were sampled (Coding=)</prompt>
							<paramfile>paramfile.txt</paramfile>
							<precond>
								<language>perl</language>
								<code>!$mrbayesblockquery</code>
							</precond>
							<format>
								<language>perl</language>
								<code>"lset coding = $value\\n"</code>
							</format>
							<vdef>
								<value>all</value>
							</vdef>
							<vlist>
								<value>all</value>
								<label>All</label>
								<value>variable</value>
								<label>Variable</label>
								<value>noabsence</value>
								<label>No absence</label>
								<value>nopresence</value>
								<label>No presence</label>
							</vlist>
							<group>5</group>
<!-- this should have a precond to prevent use with the wrong data types.  -->
							<comment>
								<value>The Coding parameter specifies how characters were sampled. If all site patterns had the possibility of being sampled, then "all" should be specified (the default). Otherwise "variable" (only var   iable characters had the possibility of being sampled), "noabsence" (characters for which all taxa were coded as absent were not sampled), and "nopresence" (characters for which all taxa were coded as present were not sampled. "All" works for all data types. However, the others only work for morphological (all/variable) or restriction site (all/variable/noabsence/nopresence) data. </value>
							</comment>
						</attributes>
					</parameter>
					
					<parameter type="Switch">
						<name>Parsmodelopts</name>
						<attributes>
							<prompt>Force calculation under a Parsimony model (Parmodel=)</prompt>
							<paramfile>paramfile.txt</paramfile>
							<precond>
								<language>perl</language>
								<code>!$mrbayesblockquery</code>
							</precond>
							<vdef>
								<value>0</value>
							</vdef>
							<format>
								<language>perl</language>
								<code>($value)? "lset parsmodel = Yes\\n":""</code>
							</format>
							<group>5</group>
							<comment>
								<value>This forces calculation under the so-called parsimony model described by Tuffley and Steel (1998). The options are "yes" or "no". Note that the biological assumptions of this model are anything but parsimonious. In fact, this model assumes many more parameters than the next most complicated model implemented in this program. If you really believe that the parsimony model makes the biological assumptions described by Tuffley and Steel, then the parsimony method is miss-named.</value>
							</comment>
						</attributes>
					</parameter>
				</parameters>
			</paragraph>
		</parameter>

		<parameter type="Paragraph">
			<paragraph>
				<name>prsetparams</name>
				<prompt>Configure Priors</prompt>
				<parameters>
<!--*******************************************************************************************
All of the parameters in this section must be preceded by the string prset
***********************************************************************************************-->
					<!-- this section is for adding the applyto command, not quite ready for this yet -->
					<!--				<parameter ismandatory="1" type="Excl">
					<name>applyprsetopts1</name>
					<attributes>
						<prompt>Parameters for Unpartitioned Data Set, or Partition 1</prompt>
						<format>
							<language>perl</language>
							<code>"applyto=(1)\\n"</code>
						</format> 
					</attributes>
				</parameter>    -->
					<parameter ismandatory="1" type="Excl">
						<name>tratioopts</name>
						<attributes>
							<prompt>Transition/Transversion Rate Ratio; DNA only (Tratiopr=)</prompt>
							<paramfile>paramfile.txt</paramfile>
							<precond>
								<language>perl</language>
								<code>!$mrbayesblockquery</code>
							</precond>
							<!--						<precond>DNA Only</precond> -->
							<vdef>
								<value>beta</value>
							</vdef>
							<vlist>
								<value>beta</value>
								<label>beta</label>
								<value>fixed</value>
								<label>fixed</label>
							</vlist>
							<flist>
								<value>beta</value>
								<code>"prset Tratiopr = beta($betameanx, $betavary)\\n"</code>
								<value>fixed</value>
								<code>"preset Tratiopr = fixed($tratiofixed)\\n"</code>
							</flist>
							<group>10</group>
							<comment>
								<value>Tratiopr changes the prior probability of the transition/transversion ratio. It can be fixed (fixed), or set to a beta distribution with mean x and variance y (beta(x,y)).The program assumes that the transition and transversion rates are independent gamma-distributed random variables with the same scale parameter when beta is selected. If you want a diffuse prior that puts equal emphasis on transition/transversion rate ratios above 1.0 and below 1.0, then use a flat Beta, beta(1,1), which is the default. If you wish to concentrate this distribution more in the equal-rates region, then use a prior of the type beta(x,x), where the magnitude of x determines how much the prior is concentrated in the equal rates region. For instance, a beta(20,20) puts more    probability on rate ratios close to 1.0 than a beta(1,1). If you think it is likely that the transition/transversion rate ratio is 2.0, you can use a prior of the type beta(2x,x), where x determines how strongly the prior is concentrated on tratio values near 2.0. For instance, a beta(2,1) is much more diffuse than a beta(80,40) but both have the expected tratio 2.0 in the absence of data. The parameters of the      Beta can be interpreted as counts: if you have observed x transitions and y transversions, then a beta(x+1,y+1) is a good representation of this information. The fixed option allows you to fix the tratio to a particular value.</value>
							</comment>
						</attributes>
					</parameter>
					
					<parameter type="Float">
						<name>betameanx</name>
						<attributes>
							<prompt>Beta mean x</prompt>
							<precond>
								<language>perl</language>
								<code>!$mrbayesblockquery &amp;&amp; $tratioopts eq "beta"</code>
							</precond>
							<format>
								<language>perl</language>
								<code>""</code>
							</format>
							<vdef>
								<value>1.0</value>
							</vdef>
							<group>10</group>
						</attributes>
					</parameter>
					
					<parameter type="Float">
						<name>betavary</name>
						<attributes>
							<prompt>Beta variance y</prompt>
							<format>
								<language>perl</language>
								<code>""</code>
							</format>
							<precond>
								<language>perl</language>
								<code>!$mrbayesblockquery &amp;&amp; $tratioopts eq "beta"</code>
							</precond>
							<vdef>
								<value>1.0</value>
							</vdef>
							<group>10</group>
						</attributes>
					</parameter>
					
					<parameter type="Float">
						<name>tratiofixed</name>
						<attributes>
							<prompt>Fixed Transition/Transversion Ratio</prompt>
							<format>
								<language>perl</language>
								<code>""</code>
							</format>
							<precond>
								<language>perl</language>
								<code>!$mrbayesblockquery &amp;&amp; $tratioopts eq "fixed"</code>
							</precond>
							<vdef>
								<value>1.0</value>
							</vdef>
							<group>10</group>
						</attributes>
					</parameter>
					
					<parameter ismandatory="1" type="Excl">
						<name>revmatpropts</name>
						<attributes>
							<prompt>Substitution Rates of the GTR Model; Nucleic Data only (Revmatpr=)</prompt>
							<paramfile>paramfile.txt</paramfile>
							<precond>
								<language>perl</language>
								<code>!$mrbayesblockquery</code>
							</precond>
							<!--						<precond>DNA Only</precond> -->
							<vdef>
								<value>dirichlet</value>
							</vdef>
							<vlist>
								<value>dirichlet</value>
								<label>dirichlet</label>
								<value>fixed</value>
								<label>fixed</label>
							</vlist>
							<flist>
								<value>dirichlet</value>
								<code>"prset revmatpr = dirichlet($atocrate,$atograte,$atotrate,$ctograte,$ctotrate,$gtotrate)\\n"</code>
								<value>fixed</value>
								<code>"prset revmatpr = fixed($fixedatocrate,$fixedatograte,$fixedatotrate,$fixedctograte,$fixedctotrate,$fixedgtotrat)\\n"</code>
							</flist>
							<group>10</group>
							<comment>
								<value>
Revmatpr sets the prior for the substitution rates of the GTR model for nucleotide data. For Revmatpr=dirichlet, MrBayes assumes that the six substitution rates are independent gamma-distributed random variables with the same scale parameter. The six numbers in brackets each corresponds to a particular substitution type. Together, they determine the shape of the prior. The six rates are in the order A / C, A / G, A / T, C / G, C / T, and G / T. By default, dirichlet(1,1,1,1,1,1) is used, also referred to as a 'flat' Dirichlet. For a prior where the C / T rate is 5 times and the A / G rate 2 times higher, on average, than the transversion rates, which are all the same, then you should use a prior of the form dirichlet(x,2x,x,x,5x,x), where x determines how much the prior is focused on these particular rates. For more information, see Tratiopr. The fixed option allows you to fix the substitution rates to particular values.                            
</value>
							</comment>
						</attributes>
					</parameter>
					
						<!-- six conversion frequencies, for dirichlet ates -->
					<parameter type="Float">
						<name>atocrate</name>
						<attributes>
							<prompt>A/C rate</prompt>
							<format>
								<language>perl</language>
								<code>""</code>
							</format>
							<precond>
								<language>perl</language>
								<code>!$mrbayesblockquery &amp;&amp; $revmatpropts eq "dirichlet"</code>
							</precond>
							<vdef>
								<value>1.0</value>
							</vdef>
							<group>10</group>
						</attributes>
					</parameter>
					
					<parameter type="Float">
						<name>atograte</name>
						<attributes>
							<prompt>A/G rate</prompt>
							<format>
								<language>perl</language>
								<code>""</code>
							</format>
							<precond>
								<language>perl</language>
								<code>!$mrbayesblockquery &amp;&amp; $revmatpropts eq "dirichlet"</code>
							</precond>
							<vdef>
								<value>1.0</value>
							</vdef>
							<group>10</group>
						</attributes>
					</parameter>
					
					<parameter type="Float">
						<name>atotrate</name>
						<attributes>
							<prompt>A/T rate</prompt>
							<format>
								<language>perl</language>
								<code>""</code>
							</format>
							<precond>
								<language>perl</language>
								<code>!$mrbayesblockquery &amp;&amp; $revmatpropts eq "dirichlet"</code>
							</precond>
							<vdef>
								<value>1.0</value>
							</vdef>
							<group>10</group>
						</attributes>
					</parameter>
					
					<parameter type="Float">
						<name>ctograte</name>
						<attributes>
							<prompt>C/G rate</prompt>
							<format>
								<language>perl</language>
								<code>""</code>
							</format>
							<precond>
								<language>perl</language>
								<code>!$mrbayesblockquery &amp;&amp; $revmatpropts eq "dirichlet"</code>
							</precond>
							<vdef>
								<value>1.0</value>
							</vdef>
							<group>10</group>
						</attributes>
					</parameter>
					
					<parameter type="Float">
						<name>ctotrate</name>
						<attributes>
							<prompt>C/T rate</prompt>
							<format>
								<language>perl</language>
								<code>""</code>
							</format>
							<precond>
								<language>perl</language>
								<code>!$mrbayesblockquery &amp;&amp; $revmatpropts eq "dirichlet"</code>
							</precond>
							<vdef>
								<value>1.0</value>
							</vdef>
							<group>10</group>
						</attributes>
					</parameter>
					
					<parameter type="Float">
						<name>gtotrate</name>
						<attributes>
							<prompt>G/T Rate</prompt>
							<format>
								<language>perl</language>
								<code>""</code>
							</format>
							<precond>
								<language>perl</language>
								<code>!$mrbayesblockquery &amp;&amp; $revmatpropts eq "dirichlet"</code>
							</precond>
							<vdef>
								<value>1.0</value>
							</vdef>
							<group>10</group>
						</attributes>
					</parameter>
					
						<!-- these are the same frequencies, for fixed rates -->
					<parameter type="Float">
						<name>fixedatocrate</name>
						<attributes>
							<prompt>A/C rate</prompt>
							<format>
								<language>perl</language>
								<code>""</code>
							</format>
							<precond>
								<language>perl</language>
								<code>!$mrbayesblockquery &amp;&amp; $revmatpropts eq "fixed"</code>
							</precond>
							<vdef>
								<value>1.0</value>
							</vdef>
							<group>10</group>
						</attributes>
					</parameter>
					
					<parameter type="Float">
						<name>fixedatograte</name>
						<attributes>
							<prompt>A/G rate</prompt>
							<format>
								<language>perl</language>
								<code>""</code>
							</format>
							<precond>
								<language>perl</language>
								<code>!$mrbayesblockquery &amp;&amp; $revmatpropts eq "fixed"</code>
							</precond>
							<vdef>
								<value>1.0</value>
							</vdef>
							<group>10</group>
						</attributes>
					</parameter>
					
					<parameter type="Float">
						<name>fixedatotrate</name>
						<attributes>
							<prompt>A/T rate</prompt>
							<format>
								<language>perl</language>
								<code>""</code>
							</format>
							<precond>
								<language>perl</language>
								<code>!$mrbayesblockquery &amp;&amp; $revmatpropts eq "fixed"</code>
							</precond>
							<vdef>
								<value>1.0</value>
							</vdef>
							<group>10</group>
						</attributes>
					</parameter>
					
					<parameter type="Float">
						<name>fixedctograte</name>
						<attributes>
							<prompt>C/G rate</prompt>
							<format>
								<language>perl</language>
								<code>""</code>
							</format>
							<precond>
								<language>perl</language>
								<code>!$mrbayesblockquery &amp;&amp; $revmatpropts eq "fixed"</code>
							</precond>
							<vdef>
								<value>1.0</value>
							</vdef>
							<group>10</group>
						</attributes>
					</parameter>
					
					<parameter type="Float">
						<name>fixedctotrate</name>
						<attributes>
							<prompt>C/T rate</prompt>
							<format>
								<language>perl</language>
								<code>""</code>
							</format>
							<precond>
								<language>perl</language>
								<code>!$mrbayesblockquery &amp;&amp; $revmatpropts eq "fixed"</code>
							</precond>
							<vdef>
								<value>1.0</value>
							</vdef>
							<group>10</group>
						</attributes>
					</parameter>
					
					<parameter type="Float">
						<name>fixedgtotrate</name>
						<attributes>
							<prompt>G/T Rate</prompt>
							<format>
								<language>perl</language>
								<code>""</code>
							</format>
							<precond>
								<language>perl</language>
								<code>!$mrbayesblockquery &amp;&amp; $revmatpropts eq "fixed"</code>
							</precond>
							<vdef>
								<value>1.0</value>
							</vdef>
							<group>10</group>
						</attributes>
					</parameter>
					
	<!--amino acid models are established in prset,and not lset, for unknown reasons -->
					<parameter ismandatory="1" type="Excl">
						<name>aamodelpropts</name>
						<attributes>
							<prompt>Set the Rate Matrix for Amino Acids (Aamodelpr=)</prompt>
							<paramfile>paramfile.txt</paramfile>
							<precond>
								<language>perl</language>
								<code>!$mrbayesblockquery</code>
							</precond>
							<format>
								<language>perl</language>
								<code>("$value" ne "$vdef")? "prset aamodelpr=$value\\n" : ""</code>
							</format>
							<!--	Precond on protein data		 -->
							<vdef>
								<value>fixed(poisson)</value>
							</vdef>
							<vlist>
								<value>fixed(blosum)</value>
								<label>Blosum</label>
								<value>fixed(cprev)</value>
								<label>Cprev</label>
								<value>fixed(dayhoff)</value>
								<label>Dayhoff</label>
								<value>fixed(equalin)</value>
								<label>Equalin</label>
								<value>fixed(gtr)</value>
								<label>GTR</label>
								<value>fixed(jones)</value>
								<label>Jones</label>
								<value>mixed</value>
								<label>Mixed</label>
								<value>fixed(mtmam)</value>
								<label>Mtmam</label>
								<value>fixed(mtrev)</value>
								<label>Mtrev</label>
								<value>fixed(poisson)</value>
								<label>Poisson</label>
								<value>fixed(rtrev)</value>
								<label>Rtrev</label>
								<value>fixed(vt)</value>
								<label>Vt</label>
								<value>fixed(wag)</value>
								<label>Wag</label>
							</vlist>
							<group>10</group>
							<comment>
								<value>Aamodelpr sets the rate matrix for amino acid data.You choose a single fixed model, or choose mixed to average over the ten models by specifying "mixed".
In the latter case, the Markov chain will sample each model according to its probability. The sampled model is reported as an index: poisson(0), jones(1), dayhoff(2), mtrev(3), mtmam(4), wag(5), rtrev(6), cprev(7), vt(8), or blosum(9). The 'Sump' command summarizes the MCMC samples and calculates the posterior probability estimate for each of these models.  
</value>
							</comment>
						</attributes>
					</parameter>
					<!-- We do not support this parameter at present.				

<parameter ismandatory="1" type="Excl">
					<name>Aarevmatpropts</name>
					<attributes>
						<prompt>Rate Matrix for Amino Acid Data (Aarevmatprr=)</prompt>
						<format>
							<language>perl</language>
							<code>""</code>
						</format>
<precond>Amino Acid Only</precond>  
						<vdef>
							<value>dirichlet</value>
						</vdef>
						<vlist>
							<value>dirichlet</value>
							<label>dirichlet</label>
							<value>fixed</value>
							<label>fixed</label>
						</vlist>
						<group>10</group>
						<comment>
<value>This parameter sets the prior for the substitution rates of the GTR model for amino acid data. The options are dirichlet and fixed, the same as those for 'Revmatpr' except that they are defined over the 190 rates of the time-reversible GTR model for amino acids instead of over the 6 rates of the GTR model for nucleotides. The rates are in the order A / R,  A / N, etc to Y / V. In other words, amino acids are listed in alphabetic order based on their full name. The first amino acid (Alanine) is then combined in turn with all amino acids following it in the list, starting with amino acid 2 (Arginine) and finishing with amino acid 20 (Valine). The second amino acid (Arginine) is then combined in turn with all amino acids following it, starting with amino acid 3 (Asparagine) and finishing with amino acid 20 (Valine), and so on.         
</value>
						</comment>
					</attributes>
				</parameter>  -->
					<parameter ismandatory="1" type="Excl">
						<name>omegapropts</name>
						<attributes>
							<prompt>Nonsynonymous/Synonymous Rate Ratio (Omegapr=)</prompt>
							<paramfile>paramfile.txt</paramfile>
							<precond>
								<language>perl</language>
								<code>!$mrbayesblockquery &amp;&amp; $omegavaropts eq "equal" &amp;&amp; $nucmodelopts eq "codon" </code>
							</precond>
							<vdef>
								<value>uniform</value>
							</vdef>
							<vlist>
								<value>uniform</value>
								<label>uniform</label>
								<value>exponential</value>
								<label>exponential</label>
								<value>fixed</value>
								<label>fixed</label>
							</vlist>
							<flist>
								<value>uniform</value>
								<code>"prset omegapr = uniform($omegaprdir1,$omegaprdir2)\\n"</code>
								<value>exponential</value>
								<code>"prset omegapr = exponential($omegaprexponential)\\n"</code>
								<value>fixed</value>
								<code>"prset omegapr = fixed($omegafixed)\\n"</code>
							</flist>
							<group>10</group>
							<comment>
								<value>This parameter specifies the prior on the nonsynonymous/synonymous rate ratio. The options are:uniform, exponential, and fixed.
This parameter is used only when the nucleotide substitution model is set to codon, and there is no variation in omega across sites (i.e. omegavar=equal").                               
</value>
							</comment>
						</attributes>
					</parameter>
					<parameter type="Float">
						<name>omegaprdir1</name>
						<attributes>
							<prompt>Uniform Omega Rate1</prompt>
							<format>
								<language>perl</language>
								<code>""</code>
							</format>
							<precond>
								<language>perl</language>
								<code>!$mrbayesblockquery &amp;&amp; $omegapropts eq "uniform"</code>
							</precond>
							<vdef>
								<value>1.0</value>
							</vdef>
							<group>10</group>
						</attributes>
					</parameter>
					<parameter type="Float">
						<name>omegaprdir2</name>
						<attributes>
							<prompt>Uniform Omega Rate2</prompt>
							<precond>
								<language>perl</language>
								<code>!$mrbayesblockquery &amp;&amp; $omegapropts eq "uniform"</code>
							</precond>
							<format>
								<language>perl</language>
								<code>""</code>
							</format>
							<vdef>
								<value>1.0</value>
							</vdef>
							<group>10</group>
						</attributes>
					</parameter>
					<parameter type="Float">
						<name>omegaprexponential</name>
						<attributes>
							<prompt>Exponential Omega Rate</prompt>
							<precond>
								<language>perl</language>
								<code>!$mrbayesblockquery &amp;&amp; $omegapropts eq "exponential"</code>
							</precond>
							<format>
								<language>perl</language>
								<code>""</code>
							</format>
							<vdef>
								<value>1.0</value>
							</vdef>
							<group>10</group>
						</attributes>
					</parameter>
					<parameter type="Float">
						<name>omegafixed</name>
						<attributes>
							<prompt>Fixed Omega Rate</prompt>
							<format>
								<language>perl</language>
								<code>""</code>
							</format>
							<precond>
								<language>perl</language>
								<code>!$mrbayesblockquery &amp;&amp; $omegapropts eq "fixed"</code>
							</precond>
							<vdef>
								<value>1.0</value>
							</vdef>
							<group>10</group>
						</attributes>
					</parameter>
					
					<parameter ismandatory="1" type="Excl">
						<!-- guessed at the default values for many of these omega options. There is no documentation whatever for most of them -->
						<name>ny98omega1propts</name>
						<attributes>
							<prompt>Nonsynonymous/Synonymous Rate Ratio for sites under purifying selection (Ny98omega1pr=)</prompt>
							<paramfile>paramfile.txt</paramfile>
							<precond>
								<language>perl</language>
								<code>!$mrbayesblockquery &amp;&amp; $omegavaropts eq "Ny98"</code>
							</precond>
							<vdef>
								<value>beta</value>
							</vdef>
							<vlist>
								<value>beta</value>
								<label>beta</label>
								<value>fixed</value>
								<label>fixed</label>
							</vlist>
							<flist>
								<value>beta</value>
								<code>"prset Ny98omega1pr = beta($ny98omega1prbeta1,$ny98omega1prbeta2)\\n"</code>
								<value>fixed</value>
								<code>"prset Ny98omega1pr = fixed($ny98omega1prfix1)\\n"</code>
							</flist>
							<group>10</group>
							<comment>
								<value>This parameter is only in effect if the nucleotide substitution model is set to "codon" and where omega varies across sites using the model of Nielsen and Yang (1998) (i.e., Ny98). If fixing the parameter, you must specify a number between 0 and 1.                                                      
</value>
							</comment>
						</attributes>
					</parameter>
					
					<parameter type="Float">
						<name>ny98omega1prbeta1</name>
						<attributes>
							<prompt>Ny98omega1 Beta Rate 1</prompt>
							<format>
								<language>perl</language>
								<code>""</code>
							</format>
							<precond>
								<language>perl</language>
								<code>!$mrbayesblockquery &amp;&amp; $ny98omega1propts eq "beta"</code>
							</precond>
							<vdef>
								<value>1.0</value>
							</vdef>
							<group>10</group>
						</attributes>
					</parameter>
					
					<parameter type="Float">
						<name>ny98omega1prbeta2</name>
						<attributes>
							<prompt>Ny98omega1 Beta Rate 2</prompt>
							<format>
								<language>perl</language>
								<code>""</code>
							</format>
							<precond>
								<language>perl</language>
								<code>!$mrbayesblockquery &amp;&amp; $ny98omega1propts eq "beta"</code>
							</precond>
							<vdef>
								<value>1.0</value>
							</vdef>
							<group>10</group>
						</attributes>
					</parameter>
					
					<parameter type="Float">
						<name>ny98omega1prfix1</name>
						<attributes>
							<prompt>Fixed Ny98Omega1 Rate</prompt>
							<precond>
								<language>perl</language>
								<code>!$mrbayesblockquery &amp;&amp; $ny98omega1propts eq "fixed"</code>
							</precond>
							<format>
								<language>perl</language>
								<code>""</code>
							</format>
							<!--  					<ctrls>
							<ctrl>
								<message>The value entered must be between 0 and 1</message>
								<language>perl</language>
								<code>$ny98omega3pruni1 &gt;= 1 || $ny98omega3pruni1 &lt;= 0</code>
							</ctrl>
						</ctrls>  -->
							<vdef>
								<value>1.0</value>
							</vdef>
							<group>10</group>
						</attributes>
					</parameter>
					
					<parameter ismandatory="1" type="Excl">
						<!-- guessed at the default values for many of these omega options. There is no documentation whatever for most of them -->
						<name>ny98omega3propts</name>
						<attributes>
							<prompt>Nonsynonymous/Synonymous Rate Ratio for sites under positive selection (Ny98omega3pr=)</prompt>
							<paramfile>paramfile.txt</paramfile>
							<precond>
								<language>perl</language>
								<code>!$mrbayesblockquery &amp;&amp; $omegavaropts eq "Ny98"</code>
							</precond>
							<format>
								<language>perl</language>
								<code>""</code>
							</format>
							<vdef>
								<value>exponential</value>
							</vdef>
							<vlist>
								<value>uniform</value>
								<label>uniform</label>
								<value>exponential</value>
								<label>exponential</label>
								<value>fixed</value>
								<label>fixed</label>
							</vlist>
							<flist>
								<value>uniform</value>
								<code>"prset Ny98omega3pr = uniform($ny98omega3pruni1,$ny98omega3pruni2)\\n"</code>
								<value>exponential</value>
								<code>"prset Ny98omega3pr = exponential($ny98omega3prexp1)\\n"</code>
								<value>fixed</value>
								<code>"prset ny98omega3pr = fixed($ny98omega3prfix1)\\n"</code>
							</flist>
							<group>10</group>
							<comment>
								<value>This parameter specifies the prior on the nonsynonymous/synonymous rate ratio for positively selected sites. The options are:uniform, exponential, and fixed. This parameter is only in effect if the nucleotide substitution model is set to codon and where omega varies across sites according to the NY98 model. 
</value>
							</comment>
						</attributes>
					</parameter>
					<parameter type="Float">
						<name>ny98omega3pruni1</name>
						<attributes>
							<prompt>Ny98 Uniform Omega Rate 1 for Positive Selection</prompt>
							<format>
								<language>perl</language>
								<code>""</code>
							</format>
							<ctrls>
								<ctrl>
									<message>The value entered must be greater than or equal to 1</message>
									<language>perl</language>
									<code>$ny98omega3pruni1 &lt; 1</code>
								</ctrl>
							</ctrls>
							<precond>
								<language>perl</language>
								<code>!$mrbayesblockquery &amp;&amp; $ny98omega3propts eq "uniform"</code>
							</precond>
							<vdef>
								<value>1.0</value>
							</vdef>
							<group>10</group>
						</attributes>
					</parameter>
					
					<parameter type="Float">
						<name>ny98omega3pruni2</name>
						<attributes>
							<prompt>Ny98 Uniform Omega Rate 2 for Positive Selection</prompt>
							<format>
								<language>perl</language>
								<code>""</code>
							</format>
							<ctrls>
								<ctrl>
									<message>The value entered must be greater than or equal to 1</message>
									<language>perl</language>
									<code>$ny98omega3pruni2 &lt; 1</code>
								</ctrl>
								<!--				<ctrl>
								<message>The first value entered should be less than or equal to the second</message>
								<language>perl</language>
								<code>$ny98omega3pruni1 &gt;= $ny98omega3pruni2</code>
							</ctrl> -->
							</ctrls>
							<precond>
								<language>perl</language>
								<code>!$mrbayesblockquery &amp;&amp; $ny98omega3propts eq "uniform"</code>
							</precond>
							<vdef>
								<value>1.0</value>
							</vdef>
							<group>10</group>
						</attributes>
					</parameter>
					
					<parameter type="Float">
						<name>ny98omega3prexp1</name>
						<attributes>
							<prompt>Ny98 Exponential Omega Rate for Positive Selection</prompt>
							<group>10</group>
							<precond>
								<language>perl</language>
								<code>!$mrbayesblockquery &amp;&amp; $ny98omega3propts eq "exponential"</code>
							</precond>
							<vdef>
								<value>1.0</value>
							</vdef>
							<format>
								<language>perl</language>
								<code>""</code>
							</format>
							<ctrls>
								<ctrl>
									<message>The value entered must be greater than or equal to 1</message>
									<language>perl</language>
									<code>$ny98omega3prexp1 &lt; 1</code>
								</ctrl>
							</ctrls>
						</attributes>
					</parameter>
					
					<parameter type="Float">
						<name>ny98omega3prfix1</name>
						<attributes>
							<prompt>Ny98 Fixed Omega Rate for Positive Selection</prompt>
							<format>
								<language>perl</language>
								<code>""</code>
							</format>
							<precond>
								<language>perl</language>
								<code>!$mrbayesblockquery &amp;&amp; $ny98omega3pr eq "fixed"</code>
							</precond>
							<vdef>
								<value>1.0</value>
							</vdef>
							<group>10</group>
						</attributes>
					</parameter>
					
<!-- M3 omega pr opts added for mb 3.2-->
					<parameter ismandatory="1" type="Excl">
						<!-- guessed at the default values for many of these omega options. There is no documentation whatever for most of them -->
						<name>M3omega3propts</name>
						<attributes>
							<prompt>Nonsynonymous/Synonymous Rate Ratio for sites under the M3 model (M3omega1pr=)</prompt>
							<paramfile>paramfile.txt</paramfile>
							<precond>
								<language>perl</language>
								<code>!$mrbayesblockquery &amp;&amp; $omegavaropts eq "M3"</code>
							</precond>
							<format>
								<language>perl</language>
								<code>""</code>
							</format>
							<vdef>
								<value>exponential</value>
							</vdef>
							<vlist>
								<value>exponential</value>
								<label>exponential</label>
								<value>fixed</value>
								<label>fixed</label>
							</vlist>
							<flist>
								<value>exponential</value>
								<code>"prset M3omega3pr = exponential \\n"</code>
								<value>fixed</value>
								<code>"prset M3omega3pr = fixed($M3omega3prfix1,$M3omega3prfix2,$M3omega3prfix3)\\n"</code>
							</flist>
							<group>10</group>
							<comment>
								<value>This parameter specifies the prior on the nonsynonymous/synonymous rate ratio for positively selected sites. The options are:uniform, exponential, and fixed. This parameter is only in effect if the nucleotide substitution model is set to codon and where omega varies across sites according to the NY98 model. 
</value>
							</comment>
						</attributes>
					</parameter>
					
					<parameter type="Float">
						<name>M3omega3prfix1</name>
						<attributes>
							<prompt>M3 Fixed Omega Rate 1 for M3 Model</prompt>
							<format>
								<language>perl</language>
								<code>""</code>
							</format>
							<precond>
								<language>perl</language>
								<code>!$mrbayesblockquery &amp;&amp; $M3omega3pr eq "fixed"</code>
							</precond>
							<vdef>
								<value>1.0</value>
							</vdef>
							<group>10</group>
						</attributes>
					</parameter>
					
					<parameter type="Float">
						<name>M3omega3prfix2</name>
						<attributes>
							<prompt>M3 Fixed Omega Rate 2 for M3 Model</prompt>
							<format>
								<language>perl</language>
								<code>""</code>
							</format>
							<precond>
								<language>perl</language>
								<code>!$mrbayesblockquery &amp;&amp; $M3omega3pr eq "fixed"</code>
							</precond>
							<vdef>
								<value>1.0</value>
							</vdef>
							<group>10</group>
						</attributes>
					</parameter>	
					
					<parameter type="Float">
						<name>M3omega3prfix3</name>
						<attributes>
							<prompt>M3 Fixed Omega Rate 3 for M3 Model</prompt>
							<format>
								<language>perl</language>
								<code>""</code>
							</format>
							<precond>
								<language>perl</language>
								<code>!$mrbayesblockquery &amp;&amp; $M3omega3pr eq "fixed"</code>
							</precond>
							<vdef>
								<value>1.0</value>
							</vdef>
							<group>10</group>
						</attributes>
					</parameter>	
<!-- end m3 omega pr opts -->
			
					
					<parameter ismandatory="1" type="Excl">
						<name>codoncatfreqsopts</name>
						<attributes>
							<prompt>Frequencies of sites under Purifying, Neutral, and Positive Selection (Codoncatfreqs=)</prompt>
							<paramfile>paramfile.txt</paramfile>
							<precond>
								<language>perl</language>
								<code>$omegavaropts eq "Ny98" || $omegavaropts eq "M3"</code>
							</precond>
							<format>
								<language>perl</language>
								<code>""</code>
							</format>
							<vdef>
								<value>dirichlet</value>
							</vdef>
							<vlist>
								<value>dirichlet</value>
								<label>dirichlet</label>
								<value>fixed</value>
								<label>fixed</label>
							</vlist>
							<flist>
								<value>dirichlet</value>
								<code>"prset Codoncatfreqs = dirichlet($codoncatfreqsdir1,$codoncatfreqsdir2,$codoncatfreqsdir3)\\n"</code>
								<value>fixed</value>
								<code>"prset Codoncatfreqs = fixed($codoncatfreqsfix1,$codoncatfreqsfix2,$codoncatfreqsfix3)\\n"</code>
							</flist>
							<group>10</group>
							<comment>
								<value>Codoncatfreqs specifies the prior on frequencies of sites under purifying, neutral, and positive selection. The options are dirichlet and fixed. This parameter is relevant if the nucleotide substitution model is set to "codon" and where omega varies across sites using the models of Nielsen and Yang (1998), or Yang et al. (2000) i.e. Omegavar=Ny98 or M3. Note that the sum of the three frequencies must be 1.         
</value>
							</comment>
						</attributes>
					</parameter>
					
					<parameter type="Float">
						<name>codoncatfreqsdir1</name>
						<attributes>
							<prompt>Codoncatfreqs Dirichlet Parameter 1</prompt>
							<precond>
								<language>perl</language>
								<code>!$mrbayesblockquery &amp;&amp; $codoncatfreqsopts eq "dirichlet"</code>
							</precond>
							<format>
								<language>perl</language>
								<code>""</code>
							</format>
							<vdef>
								<value>1.0</value>
							</vdef>
							<group>10</group>
						</attributes>
					</parameter>
					<parameter type="Float">
						<name>codoncatfreqsdir2</name>
						<attributes>
							<prompt>Codoncatfreqs Dirichlet Parameter 2</prompt>
							<precond>
								<language>perl</language>
								<code>!$mrbayesblockquery &amp;&amp; $codoncatfreqsopts eq "dirichlet"</code>
							</precond>
							<format>
								<language>perl</language>
								<code>""</code>
							</format>
							<vdef>
								<value>1.0</value>
							</vdef>
							<group>10</group>
						</attributes>
					</parameter>
					<parameter type="Float">
						<name>codoncatfreqsdir3</name>
						<attributes>
							<prompt>Codoncatfreqs Dirichlet Parameter 3</prompt>
							<format>
								<language>perl</language>
								<code>""</code>
							</format>
							<precond>
								<language>perl</language>
								<code>!$mrbayesblockquery &amp;&amp; $codoncatfreqsopts eq "dirichlet"</code>
							</precond>
							<vdef>
								<value>1.0</value>
							</vdef>
							<group>10</group>
						</attributes>
					</parameter>
					<parameter type="Float">
						<name>codoncatfreqsfix1</name>
						<attributes>
							<prompt>Codoncatfreqs Fixed Parameter 1</prompt>
							<precond>
								<language>perl</language>
								<code>!$mrbayesblockquery &amp;&amp; $codoncatfreqsopts eq "fixed"</code>
							</precond>
							<group>10</group>
							<format>
								<language>perl</language>
								<code>""</code>
							</format>
						</attributes>
					</parameter>
					<parameter type="Float">
						<name>codoncatfreqsfix2</name>
						<attributes>
							<prompt>Codoncatfreqs Fixed Parameter 2</prompt>
							<precond>
								<language>perl</language>
								<code>!$mrbayesblockquery &amp;&amp; $codoncatfreqsopts eq "fixed"</code>
							</precond>
							<format>
								<language>perl</language>
								<code>""</code>
							</format>
							<group>10</group>
						</attributes>
					</parameter>
					<parameter type="Float">
						<name>codoncatfreqsfix3</name>
						<attributes>
							<prompt>Codoncatfreqs Fixed Parameter 3</prompt>
							<precond>
								<language>perl</language>
								<code>!$mrbayesblockquery &amp;&amp; $codoncatfreqsopts eq "fixed"</code>
							</precond>
							<group>10</group>
							<format>
								<language>perl</language>
								<code>""</code>
							</format>
							<!--  				<ctrls>
						<ctrl>
								<message>The sum of the fixed parameters must be 1</message>
								<language>perl</language>
								<code>$value + $codoncatfreqsfix2 + $codoncatfreqsfix1  = 1 </code>
						</ctrl>
					</ctrls> -->
						</attributes>
					</parameter>
					<parameter ismandatory="1" type="Excl">
						<name>statewfreqpropts</name>
						<attributes>
							<prompt>State Frequencies (Statefreqpr=); Assigning frequencies to each state is not supported</prompt>
							<precond>
								<language>perl</language>
								<code>!$mrbayesblockquery</code>
							</precond>
							<paramfile>paramfile.txt</paramfile>
							<vdef>
								<value>dirichlet</value>
							</vdef>
							<vlist>
								<value>dirichlet</value>
								<label>dirichlet</label>
								<value>fixed(equal)</value>
								<label>fixed (equal)</label>
								<value>fixed(empirical)</value>
								<label>fixed (empirical)</label>
							</vlist>
							<flist>
								<value>dirichlet</value>
								<code>"prset statefreqpr = dirichlet($statewfreqprdir1)\\n"</code>
								<value>fixed (equal)</value>
								<code>"prset statefreqpr = fixed(equal)\\n"</code>
								<value>fixed (empirical)</value>
								<code>"prset statefreqpr = fixed(empirical)\\n"</code>
							</flist>
							<group>10</group>
							<comment>
								<value>This parameter specifies the prior on the state frequencies. The options are dirichlet, fixed, with equal frequencies, and fixed with empirically determined frequencies.     
If you specify a single number, then the prior has all states equally probable with a variance related to the single parameter passed.                                                                                                       
</value>
							</comment>
						</attributes>
					</parameter>
					<parameter type="Float">
						<name>statewfreqprdir1</name>
						<attributes>
							<prompt>Statefreqs Dirichlet Parameter (A single number)</prompt>
							<precond>
								<language>perl</language>
								<code>!$mrbayesblockquery &amp;&amp; $statewfreqpropts eq "dirichlet"</code>
							</precond>
							<vdef>
								<value>1.0</value>
							</vdef>
							<group>10</group>
						</attributes>
					</parameter>
					<parameter ismandatory="1" type="Excl">
						<name>shapepropts</name>
						<attributes>
							<prompt>Gamma Shape Parameter (Shapepr=)</prompt>
							<precond>
								<language>perl</language>
								<code>!$mrbayesblockquery</code>
							</precond>
							<paramfile>paramfile.txt</paramfile>
							<!-- 		<precond>
							<language>perl</language>
							<code>$omegavaropts eq "Ny98" || $omegavaropts eq "M3"</code>
						</precond> -->
							<vdef>
								<value>uniform</value>
							</vdef>
							<vlist>
								<value>uniform</value>
								<label>uniform</label>
								<value>exponential</value>
								<label>exponential</label>
								<value>fixed</value>
								<label>fixed</label>
							</vlist>
							<flist>
								<value>dirichlet</value>
								<code>"prset shapepr = uniform($shapepruni1,$shapepruni2)\\n"</code>
								<value>exponential</value>
								<code>"prset shapepr = exponential($shapeprexp1)\\n"</code>
								<value>fixed</value>
								<code>"prset shapepr = fixed($shapeprfix1)\\n"</code>
							</flist>
							<group>10</group>
							<comment>
								<value>This parameter specifies the prior on the state frequencies. The options are dirichlet, fixed, with equal frequencies, and fixed with emirically determined frequencies.     
The dirichlet prior has all states equally probable with a variance related to the single parameter passed in.                                                    
</value>
							</comment>
						</attributes>
					</parameter>
					<parameter type="Float">
						<name>shapepruni1</name>
						<attributes>
							<prompt>Gamma Shape Uniform Parameter 1</prompt>
							<format>
								<language>perl</language>
								<code>""</code>
							</format>
							<precond>
								<language>perl</language>
								<code>!$mrbayesblockquery &amp;&amp; $shapepropts eq "uniform"</code>
							</precond>
							<vdef>
								<value>0.0</value>
							</vdef>
							<group>10</group>
						</attributes>
					</parameter>
					
					<parameter type="Float">
						<name>shapeprdir2</name>
						<attributes>
							<prompt>Gamma Shape Dirichlet Parameter 2</prompt>
							<format>
								<language>perl</language>
								<code>""</code>
							</format>
							<precond>
								<language>perl</language>
								<code>!$mrbayesblockquery &amp;&amp; $shapepropts eq "uniform"</code>
							</precond>
							<vdef>
								<value>50.0</value>
							</vdef>
							<group>10</group>
						</attributes>
					</parameter>
					<parameter type="Float">
						<name>shapeprexp1</name>
						<attributes>
							<prompt>Gamma Shape Exponential Parameter</prompt>
							<format>
								<language>perl</language>
								<code>""</code>
							</format>
							<precond>
								<language>perl</language>
								<code>!$mrbayesblockquery &amp;&amp; $shapepropts eq "exponential"</code>
							</precond>
							<vdef>
								<value>1.0</value>
							</vdef>
							<group>10</group>
						</attributes>
					</parameter>
					<parameter type="Float">
						<name>shapeprfix1</name>
						<attributes>
							<prompt>Gamma Shape Fixed Parameter</prompt>
							<format>
								<language>perl</language>
								<code>""</code>
							</format>
							<precond>
								<language>perl</language>
								<code>!$mrbayesblockquery &amp;&amp; $shapepropts eq "fixed"</code>
							</precond>
							<vdef>
								<value>1.0</value>
							</vdef>
							<group>10</group>
						</attributes>
					</parameter>
					
					<parameter ismandatory="1" type="Excl">
						<name>pinvarpropts</name>
						<attributes>
							<prompt>Proportion of Invariable Sites (Pinvarpr=)</prompt>
							<precond>
								<language>perl</language>
								<code>!$mrbayesblockquery</code>
							</precond>
							<paramfile>paramfile.txt</paramfile>
							<vdef>
								<value>uniform</value>
							</vdef>
							<vlist>
								<value>uniform</value>
								<label>uniform</label>
								<value>fixed</value>
								<label>fixed</label>
							</vlist>
							<flist>
								<value>uniform</value>
								<code>"prset pinvarpr = uniform($pinvarpruni1,$pinvarpruni2)\\n"</code>
								<value>fixed</value>
								<code>"prset pinvarpr = fixed($pinvarprfix1)\\n"</code>
							</flist>
							<group>10</group>
							<comment>
								<value>This parameter specifies the prior for the proportion of invariable sites. The options are uniform and fixed. The valid range for the parameters is between 0 and 1.
</value>
							</comment>
						</attributes>
					</parameter>
					<parameter type="Float">
						<name>pinvarpruni1</name>
						<attributes>
							<prompt>Invariable Sites, Uniform Parameter 1</prompt>
							<precond>
								<language>perl</language>
								<code>!$mrbayesblockquery &amp;&amp; $pinvarpropts eq "uniform"</code>
							</precond>
							<format>
								<language>perl</language>
								<code>""</code>
							</format>
							<!--  				<ctrls>
						<ctrl>
								<message>The valid range for pinvarpr parameters is between 0 and 1</message>
								<language>perl</language>
								<code>$value &gt; 1 || $value &lt; 0</code>
						</ctrl>
					</ctrls>-->
							<vdef>
								<value>0.0</value>
							</vdef>
							<group>10</group>
						</attributes>
					</parameter>
					<parameter type="Float">
						<name>pinvarpruni2</name>
						<attributes>
							<prompt>Invariable Sites, Uniform Parameter 2</prompt>
							<precond>
								<language>perl</language>
								<code>!$mrbayesblockquery &amp;&amp; $pinvarpropts eq "uniform"</code>
							</precond>
							<format>
								<language>perl</language>
								<code>""</code>
							</format>
							<vdef>
								<value>1.0</value>
							</vdef>
							<!--			<ctrls>
				  		<ctrl>
								<message>The valid range for pinvarpr parameters is between 0 and 1</message>
								<language>perl</language>
								<code>$value &gt; 1 || $value &lt; 0</code>
						</ctrl> 
						<ctrl>
								<message>The second parameter should be larger than the first</message>
								<language>perl</language>
								<code>$pinvarpruni1 &gt; $value</code>
						</ctrl> 
					</ctrls> -->
							<group>10</group>
						</attributes>
					</parameter>
					<parameter type="Float">
						<name>pinvarprfix1</name>
						<attributes>
							<prompt>Invariable Sites, Fixed Parameter</prompt>
							<precond>
								<language>perl</language>
								<code>!$mrbayesblockquery &amp;&amp; $pinvarpropts eq "fixed"</code>
							</precond>
							<format>
								<language>perl</language>
								<code>""</code>
							</format>
							<vdef>
								<value>1.0</value>
							</vdef>
							<group>10</group>
						</attributes>
					</parameter>
					
					<parameter ismandatory="1" type="Excl">
						<name>ratecorrpropts</name>
						<attributes>
							<prompt>Autocorrelation Parameter for Gamma Distribution for Among SIte Variation (Ratecorrpr=)</prompt>
							<paramfile>paramfile.txt</paramfile>
							<precond>
								<language>perl</language>
								<code>!$mrbayesblockquery</code>
							</precond>
							<vdef>
								<value>uniform</value>
							</vdef>
							<vlist>
								<value>uniform</value>
								<label>uniform</label>
								<value>fixed</value>
								<label>fixed</label>
							</vlist>
							<flist>
								<value>uniform</value>
								<code>"prset ratecorrpr = uniform($ratecorrpruni1,$ratecorrpruni2)\\n"</code>
								<value>fixed</value>
								<code>"prset ratecorrpr = fixed($ratecorrprfix1)\\n"</code>
							</flist>
							<group>10</group>
							<comment>
								<value>This parameter specifies the prior for the autocorrelation parameter of the autocorrelated gamma distribution for among-site rate variation. The options are uniform and fixed 
The parameter for uniform is between -1 and 1. The default setting is uniform, (-1, 1).
</value>
							</comment>
						</attributes>
					</parameter>
					<parameter type="Float">
						<name>ratecorrpruni1</name>
						<attributes>
							<prompt>Autocorrelation Uniform Parameter 1</prompt>
							<format>
								<language>perl</language>
								<code>""</code>
							</format>
							<precond>
								<language>perl</language>
								<code>!$mrbayesblockquery &amp;&amp; $ratecorrpropts eq "uniform"</code>
							</precond>
							<!-- 	 		<ctrls>
				 			<ctrl>
									<message>The value entered must be between -1 and 1</message>
									<language>perl</language>
									<code>$ratecorrpruni1 &lt; -1 || &gt; 1</code>
							</ctrl>
						</ctrls>  -->
							<vdef>
								<value>-1.0</value>
							</vdef>
							<group>10</group>
						</attributes>
					</parameter>
					<parameter type="Float">
						<name>ratecorrpruni2</name>
						<attributes>
							<prompt>Autocorrelation Uniform Parameter 2</prompt>
							<format>
								<language>perl</language>
								<code>""</code>
							</format>
							<precond>
								<language>perl</language>
								<code>!$mrbayesblockquery &amp;&amp; $ratecorrpropts eq "uniform"</code>
							</precond>
							<vdef>
								<value>1.0</value>
							</vdef>
							<!-- 	 		<ctrls>
							<ctrl>
									<message>The value entered must be between -1 and 1</message>
									<language>perl</language>
									<code>$ratecorrpruni2 &lt; -1 || &gt; 1</code>
							</ctrl>
						</ctrls>    -->
							<group>10</group>
						</attributes>
					</parameter>
					<parameter type="Float">
						<name>ratecorrprfix1</name>
						<attributes>
							<prompt>Autocorrelation Fixed Parameter</prompt>
							<precond>
								<language>perl</language>
								<code>!$mrbayesblockquery &amp;&amp; $ratecorrpropts eq "fixed"</code>
							</precond>
							<format>
								<language>perl</language>
								<code>""</code>
							</format>
							<vdef>
								<value>1.0</value>
							</vdef>
			<!-- 	 		<ctrls>
							<ctrl>
									<message>The value entered must be between -1 and 1</message>
									<language>perl</language>
									<code>$ratecorrprfix1 &lt; -1 || &gt; 1</code>
							</ctrl>
						</ctrls>    -->
							<group>10</group>
						</attributes>
					</parameter>
					
					<parameter ismandatory="1" type="Excl">
						<name>covswitchpropts</name>
						<attributes>
							<prompt>Covrion Switching Rates (Covswitchpr=)</prompt>
							<precond>
								<language>perl</language>
								<code>!$mrbayesblockquery</code>
							</precond>
							<paramfile>paramfile.txt</paramfile>
							<!-- 	<precond>
							<language>perl</language>
							<code>$omegavaropts eq "Ny98" || $omegavaropts eq "M3"</code>
						</precond> -->
							<vdef>
								<value>uniform</value>
							</vdef>
							<vlist>
								<value>uniform</value>
								<label>uniform</label>
								<value>exponential</value>
								<label>exponential</label>
								<value>fixed</value>
								<label>fixed</label>
							</vlist>
							<flist>
								<value>uniform</value>
								<code>"prset covswitchpr = uniform($covswitchuni1,$covswitchuni2)\\n"</code>
								<value>exponential</value>
								<code>"prset covswitchpr = exponential($covswitchexp1)\\n"</code>
								<value>fixed</value>
								<code>"prset covswitchpr = fixed($covswitchfix1,covswitchfix2)\\n"</code>
							</flist>
							<group>10</group>
							<comment>
								<value>This option sets the prior for the covarion switching rates. The options are uniform, exponential, and fixed, The covarion model has two rates: a rate from on to off       
and a rate from off to on. The rates are assumed to have independent priors that individually are either uniformly or exponentially distributed. The other option is to fix the switching rates, in which case you must specify both rates. (The first number is off to on and the second is on to off; the first should always be less than the second).                                                  
</value>
							</comment>
						</attributes>
					</parameter>
					<parameter type="Float">
						<name>covswitchuni1</name>
						<attributes>
							<prompt>Covarion Model Off to On Rate (Uniform)</prompt>
							<precond>
								<language>perl</language>
								<code>!$mrbayesblockquery &amp;&amp; $covswitchpropts eq "uniform"</code>
							</precond>
							<format>
								<language>perl</language>
								<code>""</code>
							</format>
							<vdef>
								<value>0.0</value>
							</vdef>
							<group>10</group>
						</attributes>
					</parameter>
					<parameter type="Float">
						<name>covswitchuni2</name>
						<attributes>
							<prompt>Covarion Model On to Off Rate (Uniform)</prompt>
							<precond>
								<language>perl</language>
								<code>!$mrbayesblockquery &amp;&amp; $covswitchpropts eq "uniform"</code>
							</precond>
							<format>
								<language>perl</language>
								<code>""</code>
							</format>
							<vdef>
								<value>100.0</value>
							</vdef>
							<group>10</group>
							<!-- 
						<ctrls>
							<ctrl>
					 			<message>The first parameter must be less than the second</message>
								<language>perl</language>
								<code>$covswitchuni1 &gt; $value</code>
							</ctrl>
						</ctrls>
						-->
						</attributes>
					</parameter>
					
					<parameter type="Float">
						<name>covswitchexp1</name>
						<attributes>
							<prompt>Covarion Model Exponential Parameter</prompt>
							<format>
								<language>perl</language>
								<code>""</code>
							</format>
							<precond>
								<language>perl</language>
								<code>!$mrbayesblockquery &amp;&amp; $covswitchpropts eq "exponential"</code>
							</precond>
							<vdef>
								<value>1.0</value>
							</vdef>
							<group>10</group>
						</attributes>
					</parameter>
					
					<parameter type="Float">
						<name>covswitchfix1</name>
						<attributes>
							<prompt>Covarion Model Off to On Rate (Fixed)</prompt>
							<format>
								<language>perl</language>
								<code>""</code>
							</format>
							<precond>
								<language>perl</language>
								<code>!$mrbayesblockquery &amp;&amp; $covswitchpropts eq "fixed"</code>
							</precond>
							<vdef>
								<value>1.0</value>
							</vdef>
							<group>10</group>
						</attributes>
					</parameter>
					
					<parameter type="Float">
						<name>covswitchfix2</name>
						<attributes>
							<prompt>Covarion Model On to Off Rate (Fixed)</prompt>
							<format>
								<language>perl</language>
								<code>""</code>
							</format>
							<precond>
								<language>perl</language>
								<code>!$mrbayesblockquery &amp;&amp; $covswitchpropts eq "fixed"</code>
							</precond>
							<vdef>
								<value>1.0</value>
							</vdef>
							<group>10</group>
						</attributes>
					</parameter>
					
					<parameter ismandatory="1" type="Excl">
						<name>symdirihyperpropts</name>
						<attributes>
							<prompt>Stationary frequencies for states in standard data sets (Symdirihyperpr=)</prompt>
							<precond>
								<language>perl</language>
								<code>!$mrbayesblockquery</code>
							</precond>
							<paramfile>paramfile.txt</paramfile>
							<!-- relevant only for morphological data 
						<precond>
							<language>perl</language>
							<code>$omegavaropts eq "Ny98" or "M3"</code>
						</precond> -->
							<vdef>
								<value>fixed(infinity)</value>
							</vdef>
							<vlist>
								<value>uniform</value>
								<label>uniform</label>
								<value>exponential</value>
								<label>exponential</label>
								<value>fixed</value>
								<label>fixed</label>
								<value>fixed(infinity)</value>
								<label>fixed (infinity)</label>
							</vlist>
							<flist>
								<value>uniform</value>
								<code>"prset symdirihyperpr = uniform($symdiruni1,$symdiruni2)\\n"</code>
								<value>exponential</value>
								<code>"prset symdirihyperpr = exponential($symdirexp1)\\n"</code>
								<value>fixed</value>
								<code>"prset symdirihyperpr = fixed($symdirfix1)\\n"</code>
								<value>fixed (infinity)</value>
								<code>"prset symdirihyperpr = fixed(infinity)\\n"</code>
							</flist>
							<group>10</group>
							<comment>
								<value>Symdirihyperpr sets the prior for the stationary frequencies of the states for morphological (standard) data. There can be as many as 10 states for standard data. However, the labelling of the states is somewhat arbitrary. For example, the state "1" for different characters does not have the same meaning. This is not true for DNA characters, for example, where a "G" has the same meaning across characters. The fact that the labelling of morphological characters is arbitrary makes it difficult to allow unequal character state frequencies. MrBayes gets around this problem by assuming that the states have a dirichlet prior, with all states having equal frequency. The variation in the dirichlet can be controlled by this parameter--symdirihyperpr.Symdirihyperpr specifies the distribution on the variance parameter of the dirichlet. Valid options are uniform, exponential, fixed with an explicit rate value, and fixed(infinity). "Fixed(infinity)" fixes the dirichlet prior such that all character states have equal frequency.
</value>
							</comment>
						</attributes>
					</parameter>
					<parameter type="Float">
						<name>symdiruni1</name>
						<attributes>
							<prompt>Stationary Frequency Uniform Param 1</prompt>
							<format>
								<language>perl</language>
								<code>""</code>
							</format>
							<precond>
								<language>perl</language>
								<code>!$mrbayesblockquery &amp;&amp; $symdirihyperpropts eq "uniform"</code>
							</precond>
							<vdef>
								<value>1.0</value>
							</vdef>
							<group>10</group>
						</attributes>
					</parameter>
					<parameter type="Float">
						<name>symdiruni2</name>
						<attributes>
							<prompt>Stationary Frequency Uniform Param 2</prompt>
							<format>
								<language>perl</language>
								<code>""</code>
							</format>
							<precond>
								<language>perl</language>
								<code>!$mrbayesblockquery &amp;&amp; $symdirihyperpropts eq "uniform"</code>
							</precond>
							<vdef>
								<value>1.0</value>
							</vdef>
							<group>10</group>
						</attributes>
					</parameter>
					<parameter type="Float">
						<name>symdirexp1</name>
						<attributes>
							<prompt>Stationary Frequency Exponential Param 1</prompt>
							<format>
								<language>perl</language>
								<code>""</code>
							</format>
							<precond>
								<language>perl</language>
								<code>!$mrbayesblockquery &amp;&amp; $symdirihyperpropts eq "exponential"</code>
							</precond>
							<vdef>
								<value>1.0</value>
							</vdef>
							<group>10</group>
						</attributes>
					</parameter>
					
					<parameter type="Float">
						<name>symdirfix1</name>
						<attributes>
							<prompt>Stationary Frequency Fixed Param 1</prompt>
							<format>
								<language>perl</language>
								<code>""</code>
							</format>
							<precond>
								<language>perl</language>
								<code>!$mrbayesblockquery &amp;&amp; $symdirihyperpropts eq "fixed"</code>
							</precond>
							<vdef>
								<value>1.0</value>
							</vdef>
							<group>10</group>
						</attributes>
					</parameter>
<!-- end symdirihyper-->
					
<!-- begin topologypr -->					
					<parameter ismandatory="1" type="Excl">
						<name>topologypropts</name>
						<attributes>
							<prompt>Specify Topological Constraint Types (Topologypr=)</prompt>
							<paramfile>paramfile.txt</paramfile>
							<precond>
								<language>perl</language>
								<code>!$mrbayesblockquery &amp;&amp; $noconstraints &gt;= 1</code>
							</precond>
							<vdef>
								<value>uniform</value>
							</vdef>
							<vlist>
								<value>uniform</value>
								<label>uniform</label>
<!-- added for MB 3.2 -->
								<value>speciestree</value>
								<label>speciestree</label>
<!-- added for mb 3.2-->
								<value>constraints</value>
								<label>constraints</label>
							</vlist>
							<flist>
								<value>uniform</value>
								<code>"prset topologypr = uniform\\n"</code>
								<value>constraints</value>
								<code>"prset topologypr = constraints($constraintnames)\\n"</code>
							</flist>
							<group>10</group>
							<comment>
								<value>This parameter specifies the prior probabilities of phylogenies. The options are uniform constraints If the prior is selected to be "uniform" all possible trees are considered a priori equally probable. The constraints option allows you to specify complicated prior probabilities on trees (constraints are discussed more fully in "help constraint"). Note  that you must specify a list of constraints that you wish to be obeyed. The list can be either the constraint's number or its name. Also, note that the constraints simply tell you how much more (or less) probable individual trees are that possess the constraint than trees not possessing the constraint.                                    
</value>
							</comment>
						</attributes>
					</parameter>
					
					<parameter type="String">
						<name>constraintnames1</name>
						<attributes>
							<prompt>Enter the names or numbers of the constraints to be used, separated by commas</prompt>
							<precond>
								<language>perl</language>
								<code>!$mrbayesblockquery &amp;&amp; $topologypropts eq "constraints"</code>
							</precond>
							<format>
								<language>perl</language>
								<code>""</code>
							</format>
							<group>10</group>
						</attributes>
					</parameter>
<!-- end topolgypr -->	
					
<!-- begin blrenspr -->			
					<parameter ismandatory="1" type="Excl">
						<name>brlenspropts</name>
						<attributes>
							<prompt>Probability distribution on branch lengths (Brlenspr=)</prompt>
							<precond>
								<language>perl</language>
								<code>!$mrbayesblockquery</code>
							</precond>
							<paramfile>paramfile.txt</paramfile>
							<!-- relevant only for morphological data 
						<precond>
							<language>perl</language>
							<code>$omegavaropts eq "Ny98" or "M3"</code>
						</precond> -->
							<vdef>
								<value>unconstrained:exponential</value>
							</vdef>
							<vlist>
								<value>unconstrained:uniform</value>
								<label>unconstrained:uniform</label>
								<value>unconstrained:exponential</value>
								<label>unconstrained:exponential</label>
								<value>clock:uniform</value>
								<label>clock:uniform</label>
								<value>clock:birthdeath</value>
								<label>clock:birthdeath</label>
								<value>clock:coalescence</value>
								<label>clock:coalescence</label>
							</vlist>
							<flist>
								<value>unconstrained:uniform</value>
								<code>"prset brlenspr = unconstrained:uniform(0,$brlenspruni2)\\n"</code>
								<value>unconstrained:exponential</value>
								<code>"prset brlenspr = unconstrained:exponential($brlensprexp1)\\n"</code>
								<value>clock:uniform</value>
								<code>"prset brlenspr = clock:uniform\\n"</code>
								<value>clock:birthdeath</value>
								<code>"prset brlenspr = clock:birthdeath\\n"</code>
								<value>clock:coalescence</value>
								<code>"prset brlenspr = clock:coalescence\\n"</code>
							</flist>
							<group>10</group>
							<comment>
								<value>Brlenspr specifies the prior probability distribution on branch lengths. The options are unconstrained:uniform, unconstrained:exponential, clock:uniform, clock:birthdeath, clock:coalescence. Trees with unconstrained branch lengths are unrooted whereas clock-constrained trees are rooted. The option after the colon specifies the details of the probability density of branch lengths. If you choose a birth-death or coalescence prior, you may want to modify the details of the parameters of those processes.
</value>
							</comment>
						</attributes>
					</parameter>
					<parameter ishidden="1" type="Integer">
						<name>brlenspruni1</name>
						<attributes>
							<prompt>Unconstrained Uniform Param 1 is set at 0</prompt>
							<precond>
								<language>perl</language>
								<code>!$mrbayesblockquery &amp;&amp; $brlenspropts eq "uniform"</code>
							</precond>
						</attributes>
					</parameter>
					<parameter type="Float">
						<name>brlenspruni2</name>
						<attributes>
							<prompt>Unconstrained Uniform Param 2</prompt>
							<format>
								<language>perl</language>
								<code>""</code>
							</format>
							<precond>
								<language>perl</language>
								<code>!$mrbayesblockquery &amp;&amp; $brlenspropts eq "uniform"</code>
							</precond>
							<vdef>
								<value>1.0</value>
							</vdef>
							<group>10</group>
						</attributes>
					</parameter>
					<parameter type="Float">
						<name>brlensprexp1</name>
						<attributes>
							<prompt>Unconstrained Exponential Param</prompt>
							<format>
								<language>perl</language>
								<code>""</code>
							</format>
							<precond>
								<language>perl</language>
								<code>!$mrbayesblockquery &amp;&amp; $brlenspropts eq "unconstrained:exponential"</code>
							</precond>
							<vdef>
								<value>10.0</value>
							</vdef>
							<group>10</group>
						</attributes>
					</parameter>
<!-- end brlenspr -->
					
<!-- begin treeagepr (formerly treeheightprops) -->
					<parameter ismandatory="1" type="Excl">
						<name>treeheightpropts</name>
						<attributes>
							<prompt>Distribution on Tree Height (for Clock Models) (Treeagepr=)</prompt>
							<precond>
								<language>perl</language>
								<code>!$mrbayesblockquery &amp;&amp; $brlenspropts eq "clock:uniform" </code>
							</precond>
							<paramfile>paramfile.txt</paramfile>
							<!--		<precond>
							<language>perl</language>
							<code>$brlenspropts eq "clock:birthdeath" || $brlenspropts eq "clock:uniform"</code>
						</precond> -->
							<vdef>
								<value>exponential</value>
							</vdef>
							<vlist>
								<value>gamma</value>
								<label>gamma</label>
								<value>exponential</value>
								<label>exponential</label>
<!-- added for mb 3.2 -->
								<value>fixed</value>
								<label>fixed</label>
							</vlist>
							<flist>
								<value>gamma</value>
								<code>"prset treeagepr = gamma($treeheightsprgamma1,$treeheightsprgamma2)\\n"</code>
								<value>exponential</value>
								<code>"prset treeagepr = exponential($treeheightsprexp1)\\n"</code>
								<value>fixed</value>
								<code>"prset treeagepr = fixed($treeheightsprfx1)\\n"</code>
							</flist>
							<group>10</group>
							<comment>
								<value>Treeagepr specifies the prior probability distribution on the tree height, when a clock model is specified. The options are gamma and exponential. (And, yes, we know the exponential is a special case of the gamma distribution.) The tree height is the expected number of substitutions on a single branch that extends from the root of the tree to the tips. This parameter  does not come into play for the coalescence prior. It insures that the prior probability distribution for unconstrained and birth-death models is proper.               
</value>
							</comment>
						</attributes>
					</parameter>
					<parameter type="Float">
						<name>treeheightsprgamma1</name>
						<attributes>
							<prompt>Gamma Param 1</prompt>
							<format>
								<language>perl</language>
								<code>""</code>
							</format>
							<precond>
								<language>perl</language>
								<code>!$mrbayesblockquery &amp;&amp; $treeheightpropts eq "gamma"</code>
							</precond>
							<vdef>
								<value>1.0</value>
							</vdef>
							<group>10</group>
						</attributes>
					</parameter>
					<parameter type="Float">
						<name>treeheightsprgamma2</name>
						<attributes>
							<prompt>Unconstrained Uniform Param 2</prompt>
							<precond>
								<language>perl</language>
								<code>!$mrbayesblockquery &amp;&amp; $treeheightpropts eq "gamma"</code>
							</precond>
							<format>
								<language>perl</language>
								<code>""</code>
							</format>
							<vdef>
								<value>1.0</value>
							</vdef>
							<group>10</group>
						</attributes>
					</parameter>
					<parameter type="Float">
						<name>treeheightsprexp1</name>
						<attributes>
							<prompt>Unconstrained Exponential Param</prompt>
							<precond>
								<language>perl</language>
								<code>!$mrbayesblockquery &amp;&amp; $treeheightpropts eq "exponential"</code>
							</precond>
							<format>
								<language>perl</language>
								<code>""</code>
							</format>
							<vdef>
								<value>1.0</value>
							</vdef>
							<group>10</group>
						</attributes>
					</parameter>
					<parameter type="Float">
						<name>treeheightsprfx1</name>
						<attributes>
							<prompt>Treeagepr Fixed Param</prompt>
							<precond>
								<language>perl</language>
								<code>!$mrbayesblockquery &amp;&amp; $treeheightpropts eq "exponential"</code>
							</precond>
							<format>
								<language>perl</language>
								<code>""</code>
							</format>
							<vdef>
								<value>1.0</value>
							</vdef>
							<group>10</group>
						</attributes>
					</parameter>
					
					<parameter ismandatory="1" type="Excl">
						<name>ratepropts</name>
						<attributes>
							<prompt>Site Specific Rates Models (Ratepr=)</prompt>
							<paramfile>paramfile.txt</paramfile>
							<precond>
								<language>perl</language>
								<code>!$mrbayesblockquery</code>
							</precond>
							<!--		Conditional upon the activation of various partitions using the set command			<precond>
							<language>perl</language>
							<code>$brlenspropts eq "clock:birthdeath" || "clock:uniform"</code>
						</precond> -->
							<vdef>
								<value>fixed</value>
							</vdef>
							<vlist>
								<value>fixed</value>
								<label>fixed</label>
								<value>variable</value>
								<label>variable</label>
								<!--		not ready for this yet					<value>dirichlet</value>
							<label>dirichlet</label> -->
							</vlist>
							<flist>
								<value>fixed</value>
								<code>"prset ratepr = fixed\\n"</code>
								<value>variable</value>
								<code>"prset ratepr = variable\\n"</code>
								<!--		not ready for this yet					<value>dirichlet</value>
							<code>"ratepr = dirichlet($rateprdir1,etc..)\\n"</code> -->
							</flist>
							<group>10</group>
							<comment>
								<value>Ratepr specifies the site specific rates model. First, you must have defined a partition of the characters. For example, you may define a partition that divides the characters by codon position, if you have DNA data. Second, you must make that partition the active one using the set command. For example, if your partition is called "by_codon", then you make that the active partition using "set partition=by_codon". Now that you have defined and activated a partition, you can specify the rate multipliers for the various partitions. The options are fixed, variable, and dirichlet. For "fixed" the rate multiplier for  that partition is set to 1 (i.e., the rate is fixed to the average rate across partitions). On the other hand, for "variable", the rate is allowed to vary across partitions subject to the constraint that the average rate of substitution across the partitions is 1. You must specify a variable rate prior for at least twopartitions, otherwise the option is not activated when calculating likelihoods. The variable option automatically associates the partition rates with a dirichlet(1,...,1) prior. The dirichlet option is an alternative way of setting a partition rate to be variable, and also gives accurate control of the shape of the prior. The parameters of the Dirichlet are listed in the order of the partitions that the ratepr is applied to. For instance, "prset applyto=(1,3,4)ratepr = dirichlet(10,40,15)" would set the Dirichlet parameter 10 to partition 1, 40 to partition 3, and 15 to partition 4.
</value>
							</comment>
						</attributes>
					</parameter>
					<parameter ismandatory="1" type="Excl">
						<name>speciationpropts</name>
						<attributes>
							<prompt>Speciation Rate (for Birth:Death Clock Models) (Speciationpr=)</prompt>
							<paramfile>paramfile.txt</paramfile>
							<precond>
								<language>perl</language>
								<code>!$mrbayesblockquery &amp;&amp; $brlenspropts eq "clock:birthdeath"</code>
							</precond>
							<vdef>
								<value>uniform</value>
							</vdef>
							<vlist>
								<value>uniform</value>
								<label>uniform</label>
								<value>exponential</value>
								<label>exponential</label>
								<value>fixed</value>
								<label>fixed</label>
							</vlist>
							<flist>
								<value>uniform</value>
								<code>"prset speciationpr = uniform($speciationpruni1,$speciationpruni2)\\n"</code>
								<value>exponential</value>
								<code>"prset speciationpr = exponential($speciationprexp1)\\n"</code>
								<value>fixed</value>
								<code>"prset speciationpr = fixed($speciationprfix1)\\n"</code>
							</flist>
							<group>10</group>
							<comment>
								<value>Speciationpr  sets the prior on the speciation rate. The options are uniform, exponential, and fixed. This parameter is only relevant if the birth-death  process is selected as the prior on branch lengths.
</value>
							</comment>
						</attributes>
					</parameter>
					<parameter type="Float">
						<name>speciationpruni1</name>
						<attributes>
							<prompt>Speciationpr Uniform Param 1</prompt>
							<format>
								<language>perl</language>
								<code>""</code>
							</format>
							<precond>
								<language>perl</language>
								<code>!$mrbayesblockquery &amp;&amp; $speciationpropts eq "uniform"</code>
							</precond>
							<vdef>
								<value>0.0</value>
							</vdef>
							<group>10</group>
						</attributes>
					</parameter>
					<parameter type="Float">
						<name>speciationpruni2</name>
						<attributes>
							<prompt>Speciationpr Uniform Param 2</prompt>
							<precond>
								<language>perl</language>
								<code>!$mrbayesblockquery &amp;&amp; $speciationpropts eq "uniform"</code>
							</precond>
							<format>
								<language>perl</language>
								<code>""</code>
							</format>
							<vdef>
								<value>10.0</value>
							</vdef>
							<!--  	 	<ctrls>
							<ctrl>
								<message>For the uniform option, the first value must be less than the second</message>
								<language>perl</language>
								<code>$speciationpruni1 &gt; $value</code>
							</ctrl>
						</ctrls>	-->
							<group>10</group>
						</attributes>
					</parameter>
					<parameter type="Float">
						<name>speciationprexp1</name>
						<attributes>
							<prompt>Speciationpr Exponential Param</prompt>
							<format>
								<language>perl</language>
								<code>""</code>
							</format>
							<precond>
								<language>perl</language>
								<code>!$mrbayesblockquery &amp;&amp; $speciationpropts eq "exponential"</code>
							</precond>
							<vdef>
								<value>1.0</value>
							</vdef>
							<group>10</group>
						</attributes>
					</parameter>
					<parameter type="Float">
						<name>speciationprfix1</name>
						<attributes>
							<prompt>Speciationpr Fixed Param</prompt>
							<format>
								<language>perl</language>
								<code>""</code>
							</format>
							<precond>
								<language>perl</language>
								<code>!$mrbayesblockquery &amp;&amp; $speciationpropts eq "fixed"</code>
							</precond>
							<vdef>
								<value>1.0</value>
							</vdef>
							<group>10</group>
						</attributes>
					</parameter>
<!-- end speciationpr -->
<!-- begin extinctionpr -->
					<parameter ismandatory="1" type="Excl">
						<name>extinctionpropts</name>
						<attributes>
							<prompt>Extinction Rate (for Birth:Death Clock Models) (Extinctionpr=)</prompt>
							<paramfile>paramfile.txt</paramfile>
							<precond>
								<language>perl</language>
								<code>!$mrbayesblockquery &amp;&amp; $brlenspropts eq "clock:birthdeath"</code>
							</precond>
							<vdef>
								<value>uniform</value>
							</vdef>
<!-- changed for MB 3.2 -->
							<vlist>
								<value>beta</value>
								<label>beta</label>
								<value>fixed</value>
								<label>fixed</label>
							</vlist>
							<flist>
								<value>beta</value>
								<code>"prset extinctionpr = beta($extinctionpruni1,$extinctionpruni2)\\n"</code>
								<value>fixed</value>
								<code>"prset extinctionpr = fixed($extinctionprfix1)\\n"</code>
							</flist>
							<group>10</group>
							<comment>
								<value>Extinctionpr sets the prior on the extinction rate. Valid options are uniform, exponential, and fixed.This parameter is only relevant if the birth-death process is selected as the prior on branch lengths. 
</value>
							</comment>
						</attributes>
					</parameter>
					<parameter type="Float">
						<name>extinctionpruni1</name>
						<attributes>
							<prompt>Extinctionpr Beta Param 1</prompt>
							<format>
								<language>perl</language>
								<code>""</code>
							</format>
							<precond>
								<language>perl</language>
								<code> !$mrbayesblockquery &amp;&amp; $extinctionpropts eq "beta"</code>
							</precond>
							<vdef>
								<value>1.0</value>
							</vdef>
							<group>10</group>
						</attributes>
					</parameter>
					<parameter type="Float">
						<name>extinctionpruni2</name>
						<attributes>
							<prompt>Extinctionpr Beta Param 2</prompt>
							<precond>
								<language>perl</language>
								<code>!$mrbayesblockquery &amp;&amp; $extinctionpropts eq "beta"</code>
							</precond>
							<format>
								<language>perl</language>
								<code>""</code>
							</format>
							<vdef>
								<value>1.0</value>
							</vdef>
							<!--  		<ctrls>
							<ctrl>
								<message>For the uniform option, the first value must be less than the second</message>
								<language>perl</language>
								<code>$extinctionpruni1 &gt; $value</code>
							</ctrl>
						</ctrls> -->
							<group>10</group>
						</attributes>
					</parameter>


					<parameter type="Float">
						<name>extinctionprfix1</name>
						<attributes>
							<prompt>Extinctionpr Fixed Param</prompt>
							<format>
								<language>perl</language>
								<code>""</code>
							</format>
							<precond>
								<language>perl</language>
								<code>!$mrbayesblockquery &amp;&amp; $extinctionpropts eq "fixed"</code>
							</precond>
							<vdef>
								<value>1.0</value>
							</vdef>
							<group>10</group>
						</attributes>
					</parameter>
					<parameter type="Float">
						<name>sampleprobopts</name>
						<attributes>
							<prompt>Fraction of Species Samples in Birth Death Analysis (SampleprobExtinctionpr=)</prompt>
							<paramfile>paramfile.txt</paramfile>
							<precond>
								<language>perl</language>
								<code>!$mrbayesblockquery &amp;&amp; $brlenspropts eq "clock:birthdeath"</code>
							</precond>
							<format>
								<language>perl</language>
								<code>"prset sampleprob = $value\\n"</code>
							</format>
							<vdef>
								<value>1.0</value>
							</vdef>
							<!--  		 <ctrls>
							<ctrl>
								<message>Please Enter a Value Greater than 0 and Less Than 1.0</message>
								<language>perl</language>
								<code>$value &lt;= 1 || $value &gt; 0</code>
							</ctrl>
						</ctrls> -->
							<group>10</group>
							<comment>
								<value>Sampleprob sets the fraction of species that are sampled in the analysis. This is used with the birth death prior on trees (see Yang and Rannala, 1997).            
</value>
							</comment>
						</attributes>
					</parameter>
					<parameter ismandatory="1" type="Excl">
						<name>thetapropts</name>
						<attributes>
							<prompt>Prior on the coalescence parameter (nucleic acid data) (Thetapr=)</prompt>
							<paramfile>paramfile.txt</paramfile>
							<precond>
								<language>perl</language>
								<code>!$mrbayesblockquery &amp;&amp; $brlenspropts eq "clock:coalescence"</code>
							</precond>
							<vdef>
								<value>uniform</value>
							</vdef>
							<vlist>
								<value>uniform</value>
								<label>uniform</label>
								<value>exponential</value>
								<label>exponential</label>
								<value>fixed</value>
								<label>fixed</label>
							</vlist>
							<flist>
								<value>uniform</value>
								<code>"prset thetapr = uniform($thetapruni1,$thetapruni2)\\n"</code>
								<value>exponential</value>
								<code>"prset thetapr = exponential($thetaprexp1)\\n"</code>
								<value>fixed</value>
								<code>"prset thetapr = fixed($thetaprfix1)\\n"</code>
							</flist>
							<group>10</group>
							<comment>
								<value>Thetapr sets the prior on the coalescence parameter. This parameter is only relevant if the coalescence process is selected as the prior on branch lengths.           
</value>
							</comment>
						</attributes>
					</parameter>
					<parameter type="Float">
						<name>thetapruni1</name>
						<attributes>
							<prompt>Thetapr Uniform Param 1</prompt>
							<format>
								<language>perl</language>
								<code>""</code>
							</format>
							<precond>
								<language>perl</language>
								<code>!$mrbayesblockquery &amp;&amp; $extinctionpropts eq "uniform"</code>
							</precond>
							<vdef>
								<value>0.0</value>
							</vdef>
							<group>10</group>
						</attributes>
					</parameter>
					<parameter type="Float">
						<name>thetapruni2</name>
						<attributes>
							<prompt>Thetapr Uniform Param 2</prompt>
							<precond>
								<language>perl</language>
								<code>!$mrbayesblockquery &amp;&amp; $extinctionpropts eq "uniform"</code>
							</precond>
							<format>
								<language>perl</language>
								<code>""</code>
							</format>
							<vdef>
								<value>10.0</value>
							</vdef>
							<!--  		<ctrls>
							<ctrl>
								<message>For the uniform option, the first value must be less than the second</message>
								<language>perl</language>
								<code>$extinctionpruni1 &gt; $value</code>
							</ctrl>
						</ctrls> -->
							<group>10</group>
						</attributes>
					</parameter>
					<parameter type="Float">
						<name>thetaprexp1</name>
						<attributes>
							<prompt>Thetapr Exponential Param</prompt>
							<format>
								<language>perl</language>
								<code>""</code>
							</format>
							<precond>
								<language>perl</language>
								<code>!$mrbayesblockquery &amp;&amp; $thetapropts eq "exponential"</code>
							</precond>
							<vdef>
								<value>1.0</value>
							</vdef>
							<group>10</group>
						</attributes>
					</parameter>
					<parameter type="Float">
						<name>thetaprfix1</name>
						<attributes>
							<prompt>Thetapr Fixed Param</prompt>
							<format>
								<language>perl</language>
								<code>""</code>
							</format>
							<precond>
								<language>perl</language>
								<code>!$mrbayesblockquery &amp;&amp; $thetapropts eq "fixed"</code>
							</precond>
							<vdef>
								<value>1.0</value>
							</vdef>
							<group>10</group>
						</attributes>
					</parameter>
				</parameters>
			</paragraph>
		</parameter>
		
			<parameter type="Paragraph">
			<paragraph>
				<name>datamodifications</name>
				<prompt>Data Specifications</prompt>
				<!--		<precond>
						<language>perl</language>
						<code>!$mrbayesblockquery</code>
		</precond> -->
				<parameters>
					<parameter type="String">
						<name>databreaksopts</name>
						<attributes>
							<paramfile>paramfile.txt</paramfile>
							<prompt>Specify Breaks in Sequence Data (Protein and Nucleic Acid Data only)</prompt>
							<precond>
								<language>perl</language>
								<code>!$mrbayesblockquery</code>
							</precond>
							<format>
								<language>perl</language>
								<code>"databreaks $value"</code>
							</format>
							<group>20</group>
							<comment>
								<value>The Databreaks command is used to specify breaks in the input data matrix. Some of the models (e.g. autocorrelated gamma model) implemented by MrBayes account for nonindependence at adjacent characters. Databreaks option specifies that two sites that are adjacent in the matrix, are actually separated by many kilobases or megabases in the genome. For example, say you have a data matrix of 3204 characters that include nucleotide data from three genes that are physically unlinked. The first gene covers characters 1 to 970, the second gene covers characters 971 to 2567, and the third gene covers characters 2568 to 3204. Just enter the last number of the contiuous sequnce, in this case, 970 and 2567, separated by spaces.
</value>
							</comment>
						</attributes>
					</parameter>
					
					<parameter type="String">
						<name>pairsopts</name>
						<attributes>
							<prompt>Specify nucleotide pairs involved in Watson-Crick pairing (pairs nucmodel=doublet only)</prompt>
							<paramfile>paramfile.txt</paramfile>
							<precond>
								<language>perl</language>
								<code>!$mrbayesblockquery &amp;&amp; $nucmodelopts eq "doublet"</code>
							</precond>
							<format>
								<language>perl</language>
								<code>"pairs $value\\n"</code>
							</format>
							<group>20</group>
							<comment>
								<value>The Pairs command is used to specify pairs of nucleotides. For example, RNA sequences with a known secondary structure of stems and loops. Substitutions in nucleotides involved in a Watson-Crick pairing in stems are not strictly independent; a change in one changes the probability of a change in the partner. A solution to this problem is to expand the model around the pair of nucleotides in the stem. Pairs allows you to do this. The correct usage is to enter the numbers of a base-pairforming nucleotide pair, separated by a semicolon: for example:30:56. To include multiplepairs, separate the enteredvalues by commas: 31:55, 32:54, 33:53, 34:52, 35:51, 36:50. This specifies pairings between nucleotides 30 and 56, 31 and 55, etc. Onlynucleotide data (DNA or RNA) may be paired using this command. Note that in order for the program to actually implement a "doublet" model involving a 16 X 16 rate matrix, you must specify that the structure of        
the model is 16 X 16 using "lset nucmodel=doublet".
</value>
							</comment>
						</attributes>
					</parameter>
<!-- this setup doesnt yet allow the user to enter a range of values, it just allows the user to provide one. This can be fixed, if needed. But for now, specifying this parameter entry on the nexus file is much faster.
			<parameter ismandatory="1" type="Excl">
					<name>ctypeopts</name>
					<attributes>
						<prompt>Ctype ordering specifier</prompt>
						<vlist>
							<value>unordered:</value>
							<label>unordered</label>
							<value>ordered:</value>
							<label>ordered</label>
							<value>irreversible:</value>
							<label>irreversible</label>
						</vlist>
						<group>20</group>
						<comment>
<value>Ctype sets the character ordering for standard-type data, usage is: ctype &lt;ordering&gt;:&lt;characters&gt; Ordering options are: unordered-movement directly from one state to another is allowed in an instant of time. ordered - movement is only allowed between adjacent characters, for example, between 0 &gt;-&lt; 1 and 1 &lt;-&gt; 2 for a three state character ordered as 0 - 1 - 2. irreversible - rates of change for losses are 0. The characters to which the ordering is applied is specified in manner that is identical to commands such as "include" or "exclude". For example, ctype ordered: 10 23 45  defines characters 10, 23, and 45 to be of type ordered. Similarly, ctype irreversible: 54-67  71-92 defines characters 54 to 67 and characters 71 to 92 to be of type irreversible. You can use the "." to denote the last character, and "all" to denote all of the characters. Finally, you can use the specifier "\" to apply the ordering to every n-th character or you can use predefined charsets to specify the character. Only one ordering can be used on any specific application of ctype. If you want to apply different orderings to different characters, then you need to use ctype multiple times. For example, ctype ordered: 1-50  ctype irreversible: 51-100 sets characters 1 to 50 to be ordered and characters 51 to 100 to be irreversible. The ctype command is only sensible with morphological (here called "standard") characters. The program ignores attempts to apply character orderings to other types of characters, such as DNA characters.          
</value>
						</comment>
					</attributes>
			</parameter> 

			<parameter type="String">
				<name>ctype1range</name>
					<attributes>
						<prompt>Ctype range</prompt>
						<format>
							<language>perl</language>
							<code>(defined $value )? " ctype $ctypeopts = $value" : \\n""</code>
						</format>
						<group>20</group>
					</attributes>
			</parameter> -->
				</parameters>
			</paragraph>
		</parameter>
		<parameter type="Paragraph">
			<paragraph>
				<name>Charset</name>
				<prompt>Character Sets</prompt>
				<precond>
					<language>perl</language>
					<code>!$mrbayesblockquery</code>
				</precond>
				<parameters>
					<parameter type="Excl">
						<name>nocharsets</name>
						<attributes>
							<prompt>How many character sets would you like to define? See the note below.</prompt>
							<precond>
								<language>perl</language>
								<code>!$mrbayesblockquery</code>
							</precond>
							<paramfile>paramfile.txt</paramfile>
							<format>
								<language>perl</language>
								<code>""</code>
							</format>
							<vlist>
								<value>0</value>
								<label>0</label>
								<value>1</value>
								<label>1</label>
								<value>2</value>
								<label>2</label>
								<value>3</value>
								<label>3</label>
								<value>4</value>
								<label>4</label>
								<value>5</value>
								<label>5</label>
								<value>6</value>
								<label>6</label>
								<value>7</value>
								<label>7</label>
								<value>8</value>
								<label>8</label>
							</vlist>
							<vdef>
								<value>0</value>
							</vdef>
							<!--			<ctrls>
						<ctrl>
							<message>The number of character sets must be between 1 and 8. See the note below.</message>
							<language>perl</language>
							<code>$value &gt; 8 || $value &lt; 1</code>
						</ctrl>
					</ctrls>-->
							<group>30</group>
							<comment>
								<value>You can specify up to 8 character sets here. You can experiment here, but if you get serious, you should really do this in the MrBayes Command block of a Nexus file. For more information see the help section below.</value>
							</comment>
						</attributes>
					</parameter>
					<parameter type="String">
						<name>charset1</name>
						<attributes>
							<prompt>Name for character set 1</prompt>
							<paramfile>paramfile.txt</paramfile>
							<precond>
								<language>perl</language>
								<code>!$mrbayesblockquery &amp;&amp; $nocharsets &gt;= 1</code>
							</precond>
							<format>
								<language>perl</language>
								<code>""</code>
							</format>
							<group>30</group>
							<comment>
								<value>Charset defines a character set. You must specify the name of the charset you wish to create, and the first and last positions of that set. Both parameters are entered into the forms
provided, for up to 8 charsets.  The character set name is entered in the first box; it cannot have any spaces in it. The character range is entered second, you enter the first character position, and last characterer position, separated by a hyphen. You can use "." to indicate the last character. In addition, the forward slash (\)  can be used to tell the program to assign every third (or second, or fifth, or whatever) character to the character set. For example, "charset first_pos = 1-720\3" defines a character set called "first_pos" that includes every third site from 1 to 720.             
</value>
							</comment>
						</attributes>
					</parameter>
					<parameter type="String">
						<name>charset1range</name>
						<attributes>
							<prompt>Character set 1 range</prompt>
							<precond>
								<language>perl</language>
								<code>!$mrbayesblockquery &amp;&amp; $nocharsets &gt;= 1</code>
							</precond>
							<paramfile>paramfile.txt</paramfile>
							<format>
								<language>perl</language>
								<code>(defined $value )? " charset $charset1 = $value\\n": ""</code>
							</format>
							<group>30</group>
						</attributes>
					</parameter>
					<parameter type="String">
						<name>charset2</name>
						<attributes>
							<prompt>Name for character set 2</prompt>
							<paramfile>paramfile.txt</paramfile>
							<precond>
								<language>perl</language>
								<code>!$mrbayesblockquery &amp;&amp; $nocharsets &gt;= 2</code>
							</precond>
							<format>
								<language>perl</language>
								<code>""</code>
							</format>
							<group>30</group>
						</attributes>
					</parameter>
					<parameter type="String">
						<name>charset2range</name>
						<attributes>
							<prompt>Character set 2 range</prompt>
							<precond>
								<language>perl</language>
								<code>!$mrbayesblockquery &amp;&amp; $nocharsets &gt;= 2</code>
							</precond>
							<paramfile>paramfile.txt</paramfile>
							<format>
								<language>perl</language>
								<code>(defined $value )? " charset $charset2 = $value\\n" : ""</code>
							</format>
							<group>30</group>
						</attributes>
					</parameter>
					<parameter type="String">
						<name>charset3</name>
						<attributes>
							<prompt>Name for character set 3</prompt>
							<paramfile>paramfile.txt</paramfile>
							<precond>
								<language>perl</language>
								<code>!$mrbayesblockquery &amp;&amp; $nocharsets &gt;= 3</code>
							</precond>
							<format>
								<language>perl</language>
								<code>""</code>
							</format>
							<group>30</group>
						</attributes>
					</parameter>
					<parameter type="String">
						<name>charset3range</name>
						<attributes>
							<prompt>Character set 3 range</prompt>
							<precond>
								<language>perl</language>
								<code>!$mrbayesblockquery &amp;&amp; $nocharsets &gt;= 3</code>
							</precond>
							<paramfile>paramfile.txt</paramfile>
							<format>
								<language>perl</language>
								<code>(defined $value )? " charset $charset3 = $value\\n" : ""</code>
							</format>
							<group>30</group>
						</attributes>
					</parameter>
					<parameter type="String">
						<name>charset4</name>
						<attributes>
							<prompt>Name for character set 4</prompt>
							<paramfile>paramfile.txt</paramfile>
							<precond>
								<language>perl</language>
								<code>!$mrbayesblockquery &amp;&amp; $nocharsets &gt;= 4</code>
							</precond>
							<format>
								<language>perl</language>
								<code>""</code>
							</format>
							<group>30</group>
						</attributes>
					</parameter>
					<parameter type="String">
						<name>charset4range</name>
						<attributes>
							<prompt>Character set 4 range</prompt>
							<precond>
								<language>perl</language>
								<code>!$mrbayesblockquery &amp;&amp; $nocharsets &gt;= 4</code>
							</precond>
							<paramfile>paramfile.txt</paramfile>
							<format>
								<language>perl</language>
								<code>(defined $value )? " charset $charset4 = $value\\n" : ""</code>
							</format>
							<group>30</group>
						</attributes>
					</parameter>
					<parameter type="String">
						<name>charset5</name>
						<attributes>
							<prompt>Name for character set 5</prompt>
							<precond>
								<language>perl</language>
								<code>!$mrbayesblockquery &amp;&amp; $nocharsets &gt;= 5</code>
							</precond>
							<format>
								<language>perl</language>
								<code>""</code>
							</format>
							<group>30</group>
						</attributes>
					</parameter>
					<parameter type="String">
						<name>charset5range</name>
						<attributes>
							<prompt>Character set 5 range</prompt>
							<precond>
								<language>perl</language>
								<code>!$mrbayesblockquery &amp;&amp; $nocharsets &gt;= 5</code>
							</precond>
							<paramfile>paramfile.txt</paramfile>
							<format>
								<language>perl</language>
								<code>(defined $value )? " charset $charset5 = $value\\n" : ""</code>
							</format>
							<group>30</group>
						</attributes>
					</parameter>
					<parameter type="String">
						<name>charset6</name>
						<attributes>
							<prompt>Name for character set 6</prompt>
							<precond>
								<language>perl</language>
								<code>!$mrbayesblockquery &amp;&amp; $nocharsets &gt;= 6</code>
							</precond>
							<format>
								<language>perl</language>
								<code>""</code>
							</format>
							<group>30</group>
						</attributes>
					</parameter>
					<parameter type="String">
						<name>charset6range</name>
						<attributes>
							<prompt>Character set 6 range</prompt>
							<precond>
								<language>perl</language>
								<code>!$mrbayesblockquery &amp;&amp; $nocharsets &gt;= 6</code>
							</precond>
							<paramfile>paramfile.txt</paramfile>
							<format>
								<language>perl</language>
								<code>(defined $value )? " charset $charset6 = $value\\n" : ""</code>
							</format>
							<group>30</group>
						</attributes>
					</parameter>
					<parameter type="String">
						<name>charset7</name>
						<attributes>
							<prompt>Name for character set 7</prompt>
							<precond>
								<language>perl</language>
								<code>!$mrbayesblockquery &amp;&amp; $nocharsets &gt;= 7</code>
							</precond>
							<format>
								<language>perl</language>
								<code>""</code>
							</format>
							<group>30</group>
						</attributes>
					</parameter>
					<parameter type="String">
						<name>charset7range</name>
						<attributes>
							<prompt>Character set 7 range</prompt>
							<precond>
								<language>perl</language>
								<code>!$mrbayesblockquery &amp;&amp; $nocharsets &gt;= 7</code>
							</precond>
							<paramfile>paramfile.txt</paramfile>
							<format>
								<language>perl</language>
								<code>(defined $value )? " charset $charset7 = $value\\n" : ""</code>
							</format>
							<group>30</group>
						</attributes>
					</parameter>
					<parameter type="String">
						<name>charset8</name>
						<attributes>
							<prompt>Name for character set 8</prompt>
							<precond>
								<language>perl</language>
								<code>!$mrbayesblockquery &amp;&amp; $nocharsets &gt;= 8</code>
							</precond>
							<format>
								<language>perl</language>
								<code>""</code>
							</format>
							<group>30</group>
						</attributes>
					</parameter>
					<parameter type="String">
						<name>charset8range</name>
						<attributes>
							<prompt>Character set 8 range</prompt>
							<precond>
								<language>perl</language>
								<code>!$mrbayesblockquery &amp;&amp; $nocharsets &gt;= 8</code>
							</precond>
							<paramfile>paramfile.txt</paramfile>
							<format>
								<language>perl</language>
								<code>(defined $value )? " charset $charset8 = $value\\n" : ""</code>
							</format>
							<group>30</group>
						</attributes>
					</parameter>
					<parameter type="String">
						<name>excludeopts</name>
						<attributes>
							<prompt>Exclude these characters from the analysis </prompt>
							<precond>
								<language>perl</language>
								<code>!$mrbayesblockquery</code>
							</precond>
							<paramfile>paramfile.txt</paramfile>
							<format>
								<language>perl</language>
								<code>"exclude $value\\n"</code>
							</format>
							<group>30</group>
							<comment>
								<value>Exclude removes specific character positions from the analysis. Enter one of the following into the form provided : a set of individual character position numbers separated by spaces (2, 3, 10, 11, 12, 13, 14, and 22); a range of numbers, by giving the starting and finishing position, separated by a hyphen ( 1-100 ). Note the backslash can be used to exclude every nth character (1-100\3), the name of a character set, or "all". A mixture is also allowed (2 3 10-14 22).              
</value>
							</comment>
						</attributes>
					</parameter>
<!-- removed 
			<parameter type="Switch">
			<name>ispartitioned</name>
			<attributes>
				<prompt>Check this switch for partitioned data</prompt>
					<format>
						<language>perl</language>
						<code>($value)? "":""</code>
					</format>
					<vdef>
						<value>0</value>
					</vdef>
					<group>30</group>
				</attributes>
			</parameter>

			<parameter type="Integer">
				<name>numberpartitions</name>
				<attributes>
					<prompt>How Many Partitions?</prompt>
					<precond>
						<language>perl</language>
						<code>$ispartitioned</code>
					</precond>
					<format>
						<language>perl</language>
						<code>($value)? "":""</code>
					</format>
					<vdef>
						<value>1</value>
					</vdef>
					<ctrls>
						<ctrl>
							<message>The web interface supports up to 4 partitions, but the MrBayes block can be used to specify an unlimited number</message>
							<language>perl</language>
							<code>$numberpartitions &gt; 4</code>
						</ctrl>
					</ctrls>
					<group>30</group>
				</attributes>
			</parameter>

			<parameter type="String">
					<name>partition1name</name>
					<attributes>
						<prompt>Name for Partition1</prompt>
						<precond>
							<language>perl</language>
							<code>$numberpartitions &gt;= 1</code>
						</precond>
						<format>
							<language>perl</language>
							<code>""</code>
						</format>
						<comment>
<value>Partition allows you to specify a character partition. You must enter a partition name the number of parts (eg charsets) in the partition, and the names or numbers of those charsets, separated by commas. The sites in each partition are defined using the charset command. You can specify a partition without using charset as follows:                           
Name: partition by_codon number of parts: 3 and then the exact positions of interest as a set of lists, defined by commas: 1 4 6 9 12,2 5 7 10 13,3 6 8 11 14.Thismight makes sense for eploration, but     
defining the partition as a line in the mrbayes block seems much more efficient. Note that the program will fail if any characters in your matrix are not assigned to one of the partitions. You must excluding characters from the analysis explicitly, using the "exclude" option. 
</value>
						</comment>
					</attributes>
			</parameter>

			<parameter type="Integer">
					<name>partition1numparts</name>
					<attributes>
						<prompt>How many charsets in Partition1</prompt>
						<precond>
							<language>perl</language>
							<code>$numberpartitions &gt;= 1</code>
						</precond>
						<format>
							<language>perl</language>
							<code>""</code>
						</format>
					</attributes>
			</parameter>

			<parameter type="String">
					<name>partition1parts</name>
					<attributes>
						<prompt>Charsets in Partition1 (enter Charset names separated by commas)</prompt>
						<precond>
							<language>perl</language>
							<code>$numberpartitions &gt;= 1</code>
						</precond>
						<format>
							<language>perl</language>
							<code>"partition $partition1name = $partition1numparts:$value\\n"</code>
						</format>
					</attributes>
			</parameter>

			<parameter type="String">
					<name>partition2name</name>
					<attributes>
						<prompt>Name for Partition2</prompt>
						<precond>
							<language>perl</language>
							<code>$numberpartitions &gt;= 2</code>
						</precond>
						<format>
							<language>perl</language>
							<code>""</code>
						</format>
					</attributes>
			</parameter>

			<parameter type="Integer">
					<name>partition2numparts</name>
					<attributes>
						<prompt>How many charsets in Partition2</prompt>
						<precond>
							<language>perl</language>
							<code>$numberpartitions &gt;= 2</code>
						</precond>
						<format>
							<language>perl</language>
							<code>""</code>
						</format>
					</attributes>
			</parameter>

			<parameter type="String">
					<name>partition2parts</name>
					<attributes>
						<prompt>Charsets in Partition2 (enter Charset names separated by commas)</prompt>
						<precond>
							<language>perl</language>
							<code>$numberpartitions &gt;= 2</code>
						</precond>
						<format>
							<language>perl</language>
							<code>"partition $partition2name = $partition2numparts:$value\\n"</code>
						</format>
					</attributes>
			</parameter>

			<parameter type="String">
					<name>partition3name</name>
					<attributes>
						<prompt>Name for Partition3</prompt>
						<precond>
							<language>perl</language>
							<code>$numberpartitions &gt;= 3</code>
						</precond>
						<format>
							<language>perl</language>
							<code>""</code>
						</format>
					</attributes>
			</parameter>

			<parameter type="Integer">
					<name>partition3numparts</name>
					<attributes>
						<prompt>How many charsets in Partition3</prompt>
						<precond>
							<language>perl</language>
							<code>$numberpartitions &gt;= 3</code>
						</precond>
						<format>
							<language>perl</language>
							<code>""</code>
						</format>
					</attributes>
			</parameter>

			<parameter type="String">
					<name>partition3parts</name>
					<attributes>
						<prompt>Charsets in Partition3 (enter Charset names separated by commas)</prompt>
						<precond>
							<language>perl</language>
							<code>$numberpartitions &gt;= 3</code>
						</precond>
						<format>
							<language>perl</language>
							<code>"partition $partition3name = $partition3numparts:$value\\n"</code>
						</format>
					</attributes>
			</parameter>

			<parameter type="String">
					<name>partition4name</name>
					<attributes>
						<prompt>Name for Partition4</prompt>
						<precond>
							<language>perl</language>
							<code>$numberpartitions &gt;= 4</code>
						</precond>
						<format>
							<language>perl</language>
							<code>""</code>
						</format>
					</attributes>
			</parameter>

			<parameter type="Integer">
					<name>partition4numparts</name>
					<attributes>
						<prompt>How many charsets in Partition4</prompt>
						<precond>
							<language>perl</language>
							<code>$numberpartitions &gt;= 4</code>
						</precond>
						<format>
							<language>perl</language>
							<code>""</code>
						</format>
					</attributes>
			</parameter>

			<parameter type="String">
					<name>partition4parts</name>
					<attributes>
						<prompt>Charsets in Partition4 (enter Charset names for this partition, separated by commas)</prompt>
						<precond>
							<language>perl</language>
							<code>$numberpartitions &gt;= 4</code>
						</precond>
						<format>
							<language>perl</language>
							<code>"partition $partition4name = $partition4numparts:$value\\n"</code>
						</format>
					</attributes>
			</parameter>

			<parameter type="String">
						<name>setpartitionpopts</name>
						<attributes>
						<precond>
							<language>perl</language>
							<code>$numberpartitions &gt;= 1</code>
						</precond>
							<prompt>Specify A Partition Scheme for the Analysis</prompt>
							<format>
								<language>perl</language>
								<code>"set partition=$value\\n"</code>
							</format>
							<comment>
<value>Set is used to override the default data partitioning. If you used "partition" to create and name a preferredpartitioning scheme, you specify use of that partition by providing the partitioning schem id or its number. You can also specify the default partition by typing set partition=default or set partition=1.
</value>
							</comment>
						</attributes>	
				</parameter> 

			<parameter ismandatory="1" type="Excl">
					<name>linkunlink</name>
					<attributes>
						<prompt>Link or unlink model parameters across all partitions?</prompt>
						<precond>
							<language>perl</language>
							<code>$ispartitioned</code>
						</precond>
						<vlist>
							<value>Link</value>
							<label>Link</label>
							<value>Unlink</value>
							<label>Unlink</label>
						</vlist>
						<format>
							<language>perl</language>
							<code>"$value $linkingopts </code>
						</format>
					</attributes>
			</parameter>

			<parameter type="List">
					<name>linkingopts</name>
					<attributes>
						<prompt>Select Model parameters to link or unlink across data partitions</prompt>
						<format>
							<language>perl</language>
							<code>"link=\"$value\"'</code>
						</format>
						<precond>
							<language>perl</language>
							<code>$ispartitioned</code>
						</precond>
						<vdef>
							<value>all</value>
						</vdef>
						<vlist>
							<value>all</value>
							<label>all</label>
							<value>Tratio</value>
							<label>Partition 1</label>
							<value>Revmat </value>
							<label>Substitution rates of GTR model</label>
							<value>Omega</value>
							<label>Nonsynonymous/synonymous rate ratio </label>
							<value>Statefreq</value>
							<label>Character state frequencie</label>
							<value>Shape</value>
							<label>Gamma shape parameter</label>
							<value>Pinvar</value>
							<label>Proportion of invariable sites</label>
							<value>Correlation</value>
							<label>Correlation parameter of autodiscrete gamma</label>
							<value>Switchrates</value>
							<label>Switching rates for covarion model</label>
							<value>Brlens</value>
							<label>Branch lengths of tree </label>
							<value>Topology</value>
							<label>Topology of tree</label>
							<value>Speciationrates</value>
							<label>Speciation rates for birth-death process</label>
							<value>Extinctionrates</value>
							<label>Extinction rates for birth-death process</label>
							<value>Theta</value>
							<label>Parameter for coalescence process</label>
							<value>Growthrate</value>
							<label>Growth rate of coalescence process</label>
						</vlist>
						<group>30</group>
						<comment>
<value>Link specifies linkage of model parameters across partitions of the data. For example, link shape=(all) links the gamma shape parameter across all partitions of the data.
</value>
						</comment>
					</attributes>
				</parameter> -->
				</parameters>
			</paragraph>
		</parameter>
		<parameter type="Paragraph">
			<paragraph>
				<name>mcmcparams</name>
				<prompt>Parameters for MCMC</prompt>
				<!--*******************************************************************************************
All of the parameters in this section must be preceded by the string mcmc
***********************************************************************************************-->
				<!--		<precond>
						<language>perl</language>
						<code>!$mrbayesblockquery</code>
		</precond> -->
				<parameters>
					<parameter type="Integer">
						<name>ngenval</name>
						<attributes>
							<prompt>Number of Generations (Ngen=)</prompt>
							<precond>
								<language>perl</language>
								<code>!$mrbayesblockquery</code>
							</precond>
							<paramfile>paramfile.txt</paramfile>
							<format>
								<language>perl</language>
								<!--removed $allcomps value becuase it crashed the program-->
								<code>"mcmc ngen=$value filename=infile.nex nruns=$nrunsval nchains=$nchainsval temp=$tempval swapfreq=$swapfreqval nswaps=$nswapsval samplefreq=$samplefreqval $mcmcdiagnval minpartfreq=$minpartfreqval $allchainsval $relburninval burnin=$burninval burninfrac=$burninfracval $stopruleval $startingtreeval stopval=$stopval $sbrlensval nperts=$npertsval $ordertaxaval\\n"</code>
							</format>
							<!--mcmc  Stopval=0.01 sblrensval=Yes -->
							<vdef>
								<value>5000</value>
							</vdef>
							<warns>
								<warn>
									<message>The number of samples you requested is greater than 50,000; this may cause your .t output file to exceed the allowed limit of 500 GB. Please consider editing your input file to request a lower sample frequency.</message>
									<language>perl</language>
									<code>$ngenval &gt; 50000 * $samplefreqval</code>
								</warn>
							</warns>
							<ctrls>
								<ctrl>
									<message>Please enter a value for ngen of at least 5000 generations</message>
									<language>perl</language>
									<code>$ngenval &lt; 5000</code>
								</ctrl>
							</ctrls>
							<group>50</group>
							<comment>
								<value>Ngen sets the number of cycles for the MCMC algorithm. This should be a big number as you want the chain to first reach stasis, and then remain there for enough time to take lots of samples.
</value>
							</comment>
						</attributes>
					</parameter>
					<!--			<parameter type="Switch">
					<name>useseed</name>
					<attributes>
						<prompt>Specify a Seed?</prompt>
						<precond>
								<language>perl</language>
								<code>!$mrbayesblockquery</code>
							</precond>
						<format>
							<language>perl</language>
							<code>""</code>
						</format>
						<comment>
<value>Sets the seed number for the random number generator. The random number seed is initialized haphazardly at the beginning of each MrBayes session. This option allows you to set the seed to some specific value, thereby allowing you to exactly repeat an analysis. If the analysis uses swapping between cold and heated chains, you must also set the swap seed (see below) to exactly repeat the analysis.
</value>
						</comment>
					</attributes>
				</parameter> -->
					
					<parameter type="Integer">
						<name>nrunsval</name>
						<attributes>
							<prompt>Number of Runs (nruns=)</prompt>
							<precond>
								<language>perl</language>
								<code>!$mrbayesblockquery</code>
							</precond>
							<paramfile>paramfile.txt</paramfile>
							<format>
								<language>perl</language>
								<code>" "</code>
							</format>
							<vdef>
								<value>2</value>
							</vdef>
							<group>50</group>
							<comment>
								<value>Nruns sets the number of independent analyses started simultaneously.  Only values of 2 and 4 are permitted.                      
</value>
							</comment>
							<ctrls>
								<!-- nruns value -->
								<ctrl>
									<message>Please enter a value for nruns (default = 2)</message>
									<language>perl</language>
									<code>!defined $nrunsval </code>
								</ctrl>
								<ctrl>
									<message>nruns x nchains must be a multiple of 2</message>
									<language>perl</language>
									<code>((($nrunsval * $nchainsval) % 2) != 0)</code>
								</ctrl>
								<ctrl>
									<message>nruns x nchains must be less than or equal to 16.</message>
									<language>perl</language>
									<code>($nrunsval * $nchainsval &gt; 17) </code>
								</ctrl>
							</ctrls>
							<warns>
								<!-- this is for values entered in the interface -->
							<warn>
								<message>The job will run on 2 processors as configured. If it runs for the entire configured time, it will consume 2 x $runtime cpu hours</message>
								<language>perl</language>
								<code>!$mrbayesblockquery &amp;&amp; $nchainsval * $nrunsval == 2</code>
							</warn>
							<warn>
								<message>The job will run on 4 processors as configured. If it runs for the entire configured time, it will consume 4 x $runtime cpu hours</message>
								<language>perl</language>
								<code>!$mrbayesblockquery &amp;&amp; $nchainsval * $nrunsval == 4</code>
							</warn>
							<warn>
								<message>The job will run on 6 processors as configured. If it runs for the entire configured time, it will consume 6 x $runtime cpu hours</message>
								<language>perl</language>
								<code>!$mrbayesblockquery &amp;&amp; $nchainsval * $nrunsval == 6</code>
							</warn>
							<warn>
								<message>The job will run on 8 processors as configured. If it runs for the entire configured time, it will consume 8 x $runtime cpu hours</message>
								<language>perl</language>
								<code>!$mrbayesblockquery &amp;&amp; $nchainsval * $nrunsval == 8</code>
							</warn>
							<warn>
								<message>The job will run on 16 processors as configured. If it runs for the entire configured time, it will consume 16 x $runtime cpu hours</message>
								<language>perl</language>
								<code>!$mrbayesblockquery &amp;&amp; $nchainsval * $nrunsval &gt; 8 </code>
							</warn>
							</warns>
						</attributes>
					</parameter>
					<parameter type="Integer">
						<name>nchainsval</name>
						<attributes>
							<prompt>Number of Chains to Run (nchains=)</prompt>
							<precond>
								<language>perl</language>
								<code>!$mrbayesblockquery</code>
							</precond>
							<paramfile>paramfile.txt</paramfile>
							<format>
								<language>perl</language>
								<code>""</code>
							</format>
							<vdef>
								<value>4</value>
							</vdef>
							<group>50</group>
							<comment>
								<value>   Nchains specifies how many chains are run for each analysis for the MCMCMC variant. The default is 4: 1 cold chain and 3 heated chains. If Nchains is set to 1, MrBayes will use regular MCMC sampling, without heating.
</value>
							</comment>
							<ctrls>
								<ctrl>
									<message>The value of nchains must 1 or greater.  The default (recommended) is 4.</message>
									<language>perl</language>
									<code>$nchainsval &lt; 1</code>
								</ctrl>
								<ctrl>
									<message>nruns x nchains must be a multiple of 2</message>
									<language>perl</language>
									<code>((($nrunsval * $nchainsval) % 2) != 0)</code>
								</ctrl>
								<ctrl>
									<message>nruns x nchains must be less than or equal to 16.</message>
									<language>perl</language>
									<code>($nrunsval * $nchainsval &gt; 17) </code>
								</ctrl>
								<ctrl>
									<message>Please enter a value for nchains= (default = 4)</message>
									<language>perl</language>
									<code>!defined $nchainsval</code>
								</ctrl>
							</ctrls>
						</attributes>
					</parameter>
					<parameter type="Float">
						<name>tempval</name>
						<attributes>
							<prompt>Temperature parameter (temp=)</prompt>
							<precond>
								<language>perl</language>
								<code>!$mrbayesblockquery</code>
							</precond>
							<paramfile>paramfile.txt</paramfile>
							<format>
								<language>perl</language>
								<code>" "</code>
							</format>
							<vdef>
								<value>0.200</value>
							</vdef>
							<group>50</group>
							<comment>
								<value>Temp  is the temperature parameter for heating the chains. The higher the temperature, the more likely the heated chains are tomove between isolated peaks in the posterior distribution.     However, excessive heating may lead to very low acceptance rates for swaps between different chains. Before changing the default setting, however, note that the acceptance rates of swaps tend to fluctuate during the burn-in phase of the run.
</value>
							</comment>
						</attributes>
					</parameter>
					<!-- dont understand this paramter, implement if requested
				<parameter type="Switch">
					<name>reweightval</name>
					<attributes>
						<prompt>Reweight the Characters (reweight=)?</prompt>
						<precond>
							<language>perl</language>
							<code>!$mrbayesblockquery</code>
						</precond>
						<vdef>
							<value>0</value>
						</vdef>
						<format>
							<language>perl</language>
							<code>""</code>
						</format>
						<comment>
<value>Reweight requires three numbers: the percentage of characters to decrease in weight, the percentage of characters to increase in weight, and the increment. An increase/decrease in weight is acheived by replicating/removing a character in the matrix. This is only done to non-cold chains.                                          
</value>
						</comment>
					</attributes>
				</parameter>

				<parameter  ishidden="1" type="String">
					<name>reweightvalstring</name>
					<attributes>
						<precond>
							<language>perl</language>
							<code>!$mrbayesblockquery &amp;&amp; $reweightval</code>
						</precond>
						<vdef>
							<value>reweight=($reweightparam1,$reweightparam2)</value>
						</vdef>
					</attributes>
				</parameter>		
				
				<parameter type="Float">
					<name>reweightval1</name>
					<attributes>
						<prompt>Reweight parameter 1</prompt>
						<precond>
							<language>perl</language>
							<code>!$mrbayesblockquery &amp;&amp; $reweightvalstring</code>
						</precond>
						<format>
							<language>perl</language>
							<code>""</code>
						</format>
						<vdef>
							<value>0.00</value>
						</vdef>
					</attributes>
				</parameter>
				
				<parameter type="Float">
					<name>reweightval2</name>
					<attributes>
						<prompt>Reweight parameter 2</prompt>
						<precond>
							<language>perl</language>
							<code>!$mrbayesblockquery &amp;&amp; $reweightvalstring</code>
						</precond>
						<vdef>
							<value>0.00</value>
						</vdef>
						<format>
							<language>perl</language>
							<code>""</code>
						</format>
					</attributes>
				</parameter> -->
					<parameter type="Integer">
						<name>swapfreqval</name>
						<attributes>
							<prompt>How often should swap of states be attempted</prompt>
							<precond>
								<language>perl</language>
								<code>!$mrbayesblockquery</code>
							</precond>
							<format>
								<language>perl</language>
								<code>""</code>
							</format>
							<vdef>
								<value>1</value>
							</vdef>
							<comment>
								<value>Swapfreq specifies how often swaps of states between chains are attempted. You must be running at least two chains for this option to be relevant. The default is Swapfreq=1, resulting in Nswaps (see below) swaps being tried each generation of the run. If Swapfreq is set to 10, then Nswaps swaps will be tried every tenth generation of the run.                       
</value>
							</comment>
						</attributes>
					</parameter>
					<parameter type="Integer">
						<name>nswapsval</name>
						<attributes>
							<prompt>How many swaps should be tried per generation</prompt>
							<precond>
								<language>perl</language>
								<code>!$mrbayesblockquery</code>
							</precond>
							<format>
								<language>perl</language>
								<code>""</code>
							</format>
							<vdef>
								<value>1</value>
							</vdef>
							<comment>
								<value>Nswaps sets the number of swaps tried for each swapping generation of the chain (see also Swapfreq).                                     
</value>
							</comment>
						</attributes>
					</parameter>
					<parameter type="Integer">
						<name>samplefreqval</name>
						<attributes>
							<prompt>How often should the Markov chain be sampled?</prompt>
							<precond>
								<language>perl</language>
								<code>!$mrbayesblockquery</code>
							</precond>
							<paramfile>paramfile.txt</paramfile>
							<format>
								<language>perl</language>
								<code>""</code>
							</format>
							<vdef>
								<value>1000</value>
							</vdef>
							<group>50</group>
							<comment>
								<value>Samplefreq specifies how often the Markov chain is sampled. You can sample the chain every cycle, but this results in very large output files. Thinning the chain is a way of making these files smaller and making the samples more independent.
</value>
							</comment>
						</attributes>
					</parameter>
					<parameter ismandatory="1" type="Excl">
						<name>mcmcdiagnval</name>
						<attributes>
							<prompt>Write acceptance ratios of moves and swaps to file?</prompt>
							<precond>
								<language>perl</language>
								<code>!$mrbayesblockquery</code>
							</precond>
							<vdef>
								<value>mcmcdiagn=Yes</value>
							</vdef>
							<vlist>
								<value>mcmcdiagn=Yes</value>
								<label>Yes</label>
								<value>mcmcdiagn=No</value>
								<label>No</label>
							</vlist>
							<comment>
								<value>Mcmcdiagn determines whether acceptance ratios of moves and swaps will be printed to file. The file will be named similarly to the .p' and '.t' files, but will have the ending '.mcmc'. If more than one independent analysis is run simultaneously (see Nruns below), convergence diagnostics for tree topology will also be printed to this file. The convergence diagnostic used is the average standard deviation in partition frequency values across independent analyses. The Burnin setting (see below) determines how many samples will be discarded as burnin before calculating the partition frequencies. The Minpartfreq setting (see below) determines the minimum partition frequency required for a partition to be included in the calculation. As the independent analyses approach stationarity (converge), the value of the diagnostic is expected to approach zero.          
</value>
							</comment>
						</attributes>
					</parameter>
					<parameter type="Float">
						<name>minpartfreqval</name>
						<attributes>
							<prompt>Minimum frequency for a partition to be included (minpartfreq)</prompt>
							<precond>
								<language>perl</language>
								<code>!$mrbayesblockquery</code>
							</precond>
							<paramfile>paramfile.txt</paramfile>
							<format>
								<language>perl</language>
								<code>""</code>
							</format>
							<vdef>
								<value>0.1</value>
							</vdef>
							<group>50</group>
							<comment>
								<value>Minpartfreq sets the minimum frequency required for a partition to be included in the calculation of the topology convergence diagnostic. The partition is included if the minimum frequency is reached in at least one of the independent tree samples that are compared.                                                         
</value>
							</comment>
						</attributes>
					</parameter>
					<parameter ismandatory="1" type="Excl">
						<name>allchainsval</name>
						<attributes>
							<paramfile>paramfile.txt</paramfile>
							<prompt>Record acceptance ratios for all chains?</prompt>
							<precond>
								<language>perl</language>
								<code>!$mrbayesblockquery</code>
							</precond>
							<vdef>
								<value>allchains=No</value>
							</vdef>
							<vlist>
								<value>allchains=Yes</value>
								<label>Yes</label>
								<value>allchains=No</value>
								<label>No</label>
							</vlist>
							<comment>
								<value>Allchains: when set to YES, acceptance ratios for moves are recorded for all chains, cold or heated. By default, only the acceptance ratios for the cold chain are recorded.             
</value>
							</comment>
						</attributes>
					</parameter>
					<!-- setting to yes crashes the program			
				<parameter ismandatory="1" type="Excl">
					<name>allcompsval</name>
					<attributes>
						<prompt>Calculate convergence diagnostics over all pairwise comparisons?</prompt>
						<precond>
							<language>perl</language>
							<code>!$mrbayesblockquery</code>
						</precond>
						<vdef>
							<value>allcomps=Yes</value>
						</vdef>
						<vlist>
							<value>allcomps=Yes</value>
							<label>Yes</label>
							<value>allcomps=No</value>
							<label>No</label>
						</vlist>
						<comment>
<value>Allcomps: when set to YES, topological convergence diagnostics are calculated over all pairwise comparisons of runs. If it is set to NO, only the overall value is reported.        
</value>
						</comment>
					</attributes>
				</parameter>	-->
					<parameter ismandatory="1" type="Excl">
						<name>relburninval</name>
						<attributes>
							<prompt>Discard a proportion of the sampled values as burnin when calculating the convergence diagnostic?</prompt>
							<precond>
								<language>perl</language>
								<code>!$mrbayesblockquery</code>
							</precond>
							<format>
								<language>perl</language>
								<code>""</code>
							</format>
							<vdef>
								<value>relburnin=Yes</value>
							</vdef>
							<vlist>
								<value>relburnin=Yes</value>
								<label>Yes</label>
								<value>relburnin=No</value>
								<label>No</label>
							</vlist>
							<comment>
								<value> Relburnin: If set to YES, a proportion of the sampled values will be discarded as burnin when calculating the convergence diagnostic. The proportion to be discarded is set with Burninfrac.  By default, the Relburnin option is set to NO, resulting in a specific number of samples being discarded instead. This number is set by Burnin (see below).
</value>
							</comment>
						</attributes>
					</parameter>
					<parameter type="Float">
						<name>burninfracval</name>
						<attributes>
							<prompt>Specify the fraction of the sampled values discarded as burnin</prompt>
							<paramfile>paramfile.txt</paramfile>
							<precond>
								<language>perl</language>
								<code>!$mrbayesblockquery &amp;&amp; $relburninval eq "relburnin=Yes"</code>
							</precond>
							<format>
								<language>perl</language>
								<code>""</code>
							</format>
							<vdef>
								<value>0.25</value>
							</vdef>
							<comment>
								<value>BurninFrac specifies fraction of samples that will be discarded when convergence diagnostics are calculated. The value of this option is only relevant when Relburnin is set to YES. Example: A value for this option of 0.25 means that 25 percent of the samples will be discarded.
</value>
							</comment>
						</attributes>
					</parameter>
					<parameter type="Integer">
						<name>burninval</name>
						<attributes>
							<prompt>Specify the number of sampled values discarded as burnin</prompt>
							<paramfile>paramfile.txt</paramfile>
							<precond>
								<language>perl</language>
								<code>!$mrbayesblockquery &amp;&amp; $relburninval eq "relburnin=No"</code>
							</precond>
							<format>
								<language>perl</language>
								<code>""</code>
							</format>
							<vdef>
								<value>0</value>
							</vdef>
							<group>50</group>
							<comment>
								<value>Burnin specifies the number of samples (not generations) that will be discarded when convergence diagnostics are calculated. The value of this option is only relevant when Relburnin is set to NO.                                                    
</value>
							</comment>
						</attributes>
					</parameter>
					<parameter ismandatory="1" type="Excl">
						<name>stopruleval</name>
						<attributes>
							<prompt>Stop early if the convergence diagnostic falls below the stop value?</prompt>
							<precond>
								<language>perl</language>
								<code>!$mrbayesblockquery &amp;&amp; $mcmcdiagnval eq "mcmcdiagn=Yes"</code>
							</precond>
							<vdef>
								<value>stoprule=Yes</value>
							</vdef>
							<vlist>
								<value>stoprule=Yes</value>
								<label>Yes</label>
								<value>stoprule=No</value>
								<label>No</label>
							</vlist>
							<comment>
								<value>Stoprule: if set to NO, then the chain is run the number of generations determined by Ngen. If it is set to YES, and topological convergence diagnostics are calculated (Mcmcdiagn is set to YES), then the chain will be stopped before the pre-determined number of generations if the convergence diagnostic falls below the stop value.                                    
</value>
							</comment>
						</attributes>
					</parameter>
					<parameter type="Float">
						<name>stopval</name>
						<attributes>
							<prompt>Stop early if the convergence diagnostic falls below the stop value?</prompt>
							<paramfile>paramfile.txt</paramfile>
							<precond>
								<language>perl</language>
								<code>!$mrbayesblockquery &amp;&amp; $mcmcdiagnval eq "Yes" &amp;&amp; $nrun &gt; "1"</code>
							</precond>
							<format>
								<language>perl</language>
								<code>""</code>
							</format>
							<vdef>
								<value>0.01</value>
							</vdef>
							<group>50</group>
							<comment>
								<value>Stopval: the critical value for the topological convergence diagnostic. Only used when Stoprule and Mcmcdiagn are set to yes, and more than one analysis is run simultaneously (Nruns greater than 1).
</value>
							</comment>
						</attributes>
					</parameter>
					<!--   Filename     The name of the files that will be generated. Two files are 

generated: "Filename.t" and "Filename.p". The .t file contains the trees whereas the .p file contains the sampled values of the parameters. The default params are temp.out.p and temp.out.t -->
					<!-- implemneted assuming user tree is implemen ted as well -->
					<parameter ishidden="1" ismandatory="1" type="String">
						<name>startingtreeval</name>
						<attributes>
							<!--						<prompt>Random or User Selected Starting Trees?</prompt> -->
							<precond>
								<language>perl</language>
								<code>!$mrbayesblockquery &amp;&amp; $Usertreesel</code>
							</precond>
							<paramfile>paramfile.txt</paramfile>
							<format>
								<language>perl</language>
								<code>""</code>
							</format>
							<vdef>
								<value>startingtree=random</value>
							</vdef>
							<!--						<vlist>
							<value>startingtree=random</value>
							<label>random</label>
							<value>startingtree=user</value>
							<label>user</label> 
						</vlist>-->
							<group>50</group>
							<comment>
								<value>Startingtree specifies whether the starting tree for the chain is randomly selected or user-defined. It might be a good idea to start from randomly chosen trees; convergence seems likely if independently run chains, each of which started from different random trees, converge to the same answer.
</value>
							</comment>
						</attributes>
					</parameter>
					<parameter type="Integer">
						<name>npertsval</name>
						<attributes>
							<prompt>Number of random perturbations to apply to user starting tree.</prompt>
							<precond>
								<language>perl</language>
								<code>!$mrbayesblockquery &amp;&amp; $startingtreeval eq "startingtree=user"</code>
							</precond>
							<format>
								<language>perl</language>
								<code>""</code>
							</format>
							<vdef>
								<value>0</value>
							</vdef>
							<comment>
								<value>Nperts is the number of random perturbations to apply to the user starting tree. This allows you to have something between completely random and user-defined trees start the chain.                                                     
</value>
							</comment>
						</attributes>
					</parameter>
					<parameter ismandatory="1" type="Excl">
						<name>sbrlensval</name>
						<attributes>
							<prompt>Save branch length information?</prompt>
							<precond>
								<language>perl</language>
								<code>!$mrbayesblockquery</code>
							</precond>
							<paramfile>paramfile.txt</paramfile>
							<vdef>
								<value>Savebrlens=Yes</value>
							</vdef>
							<vlist>
								<value>Savebrlens=Yes</value>
								<label>Yes</label>
								<value>Savebrlens=No</value>
								<label>No</label>
							</vlist>
							<group>50</group>
						</attributes>
					</parameter>
					<parameter ismandatory="1" type="Excl">
						<name>ordertaxaval</name>
						<attributes>
							<prompt>Should taxa be ordered before trees are printed to file?</prompt>
							<precond>
								<language>perl</language>
								<code>!$mrbayesblockquery</code>
							</precond>
							<paramfile>paramfile.txt</paramfile>
							<vdef>
								<value>Ordertaxa=Yes</value>
							</vdef>
							<vlist>
								<value>Ordertaxa=Yes</value>
								<label>Yes</label>
								<value>Ordertaxa=No</value>
								<label>No</label>
							</vlist>
							<format>
								<language>perl</language>
								<code>""</code>
							</format>
							<group>50</group>
							<comment>
								<value>Ordertaxa determines whether taxa should be ordered before trees are printed to file. If set to 'Yes', terminals in the sampled trees will be reordered to match the order of the taxa in thedata matrix as closely as possible. By default, trees will be printed without reordering of taxa.
</value>
							</comment>
						</attributes>
					</parameter>
				</parameters>
			</paragraph>
		</parameter>
		<parameter type="Paragraph">
			<paragraph>
				<name>outputopts</name>
				<prompt>Output/Reporting Options</prompt>
				<!--		<precond>
			<language>perl</language>
			<code>!$mrbayesblockquery</code>
		</precond> -->
				<parameters>
					<parameter type="Paragraph">
						<paragraph>
							<name>sumtintro</name>
							<prompt>Report parameters</prompt>
							<comment>
								<value>    Report allows you to control how the posterior distribution is reported. For rate parameters, it allows you to choose among several popular parameterizations. The report command also allows you to request printing of some model aspects that are usually not reported. For instance, if a node is constrained in the analysis, MrBayes can print the probabilities of the ancestral states at that node. Similarly, if there is rate variation in the model, MrBayes can print the inferred site rates, and if there is omega variation, MrBayes can print the inferred omega (positive selection) values foreach codon. In a complex model with several partitions, each partition is controlled separately using the same 'Applyto' mechanism as in the 'Lset' and  'Prset' commands.                                                              
Options:                                                                       
Applyto   allows you to apply the report commands to specific partitions. This command should be the first in the list of commands specified in 'report'.                                   
For example,  report applyto=(1,2) tratio=ratio 
					 report applyto=(3) tratio=dirichlet                            
would result in the transition and transversion rates of the first and second partitions in the model being reported as a ratio and the transition and transversion rates of the third partition being reported as proportions of the rate sum (the Dirichlet parameterization).                                      

Tratio    -- This specifies the report format for the transition and transversion rates of a nucleotide substitution model with nst=2. If 'ratio' is selected, the rates will be reported as a ratio (transition rate/transversion rate). If 'dirichlet' is selected, the transition and transversion rates will instead be reported as proportions of the rate sum. For example, if the transition rate is three times the transversion rate and 'ratio' is selected, this will reported as a single value, '3.0'. If 'dirichlet' is selected instead, the same rates will be reported using two values, '0.75 0.25'. The sum of the Dirichlet values is always 1. Although the Dirichlet format may be unfamiliar to some users, it is more convenient for specifying priors than the ratio  format. 
                                                         
Revmat    -- This specifies the report format for the substitution rates of a GTR substitution model for nucleotide or amino acid data. If 'ratio' is selected, the rates will be reported scaled to the G-T rate (for nucleotides) or the Y-V rate (for amino acids). If 'dirichlet' is specified instead, the rates are reported as proportions of the rate sum. For instance, assume that the C-T rate is twice the A-G rate and four times the transversion rates, which are equal. If the report format is set to 'ratio', this would be reported as '1.0 2.0 1.0 1.0 4.0 1.0' since the rates are reported in the order rAC, rAG, rAT, rCG, rCT, rGT and scaled relative to the last rate, the G-T rate. If 'dirichlet' is selected instead, the same rates would have been reported as '0.1 0.2  0.1 0.1 0.4 0.1' since the rates are now scaled so that they sumto 1.0. The Dirichlet format is the parameterization used for formulating priors on the rates.                                  

Ratemult  -- This specifies the report format used for the rate multiplier of different model partitions. Three formats are available. If 'scaled' is selected, then rates are scaled such that the mean rate per site across partitions is 1.0. If 'ratio' is chosen, the rates are scaled relative to the rate of the first partition. Finally, if 'dirichlet' is chosen, the rates are given as proportions of the rate sum. The latter is the format used when formulating priors on the rate multiplier.

Ancstates -- If this option is set to 'yes', MrBayes will print the probability of the ancestral states at all constrained nodes. Typically, you are interested in the ancestral states of only a few characters and only at one node in the tree. To perform such an analysis, first define and enforce a topology constraint using 'constraint' and 'prset topologypr = constraints (...)'.Then put the character(s) of interest in a separate partition and set MrBayes to report the ancestral states for that partition. For instance, if the characters of interest are in partition 2, use 'report applyto=(2) ancstates=yes' to force MrBayes to print the probability of the ancestral states of those characters at the constrained node to the '.p' file. 
                           
Siterates  If this option is set to 'yes' and the relevant model has rate variation across sites, the mean site rate in the posterior will be reported for each site to the '.p' file.
                       
Possel     If this option is set to 'yes' and the relevant model has omega variation across sites, the mean omega value for each model site (codon in this case) will be written to the '.p' file.            

</value>
							</comment>
							<parameters>
								<!--The parameters are sub commands of the report option-->
								<parameter ismandatory="1" type="Excl">
									<name>tratioval</name>
									<attributes>
										<prompt>Report format for the transition and transversion rates of a nucleotide substitution model with nst=2</prompt>
										<paramfile>paramfile.txt</paramfile>
										<vdef>
											<value>ratio</value>
										</vdef>
										<precond>
											<language>perl</language>
											<code>!$mrbayesblockquery &amp;&amp; $nstopts eq 2</code>
										</precond>
										<format>
											<language>perl</language>
											<code>"report tratio=$value\\n"</code>
										</format>
										<vlist>
											<value>ratio</value>
											<label>ratio</label>
											<value>dirichlet</value>
											<label>dirichlet</label>
										</vlist>
										<group>45</group>
									</attributes>
								</parameter>
								<parameter ismandatory="1" type="Excl">
									<name>revmatopts</name>
									<attributes>
										<prompt>Report format for substitution rates of a GTR substitution model for nucleotide or amino acid data</prompt>
										<precond>
											<language>perl</language>
											<code>!$mrbayesblockquery</code>
										</precond>
										<paramfile>paramfile.txt</paramfile>
										<vdef>
											<value>dir</value>
										</vdef>
										<!--  		<precond>
														<language>perl</language>
														<code>$nstopts eq 6 || $aamodelpropts eq "fixed(gtr)"</code>
													</precond> -->
										<format>
											<language>perl</language>
											<code>"report revmat=$value\\n"</code>
										</format>
										<vlist>
											<value>ratio</value>
											<label>ratio</label>
											<value>dirichlet</value>
											<label>dirichlet</label>
										</vlist>
										<group>45</group>
									</attributes>
								</parameter>
								<!-- not relvant, since partitions arent supported										<parameter ismandatory="1" type="Excl">
												<name>ratemultopts</name>
												<attributes>
													<prompt>Report format for the rate multiplier of different model partitions</prompt>
													<precond>
														<language>perl</language>
														<code>!$mrbayesblockquery</code>
													</precond>
													<paramfile>paramfile.txt</paramfile>
													<vdef>
															<value>dirichlet</value>
													</vdef>
													<precond>
														<language>perl</language>
														<code>!$mrbayesblockquery &amp;&amp; $ispartitioned</code>
													</precond>
													<format>
														<language>perl</language>
														<code>"report ratemult=$value\\n"</code>
													</format>
													<vlist>
														<value>scaled</value>
														<label>scaled</label>
														<value>ratio</value>
														<label>ratio</label>
														<value>dir</value>
														<label>dirichlet</label>
													</vlist>
													<group>45</group>
												</attributes>
											</parameter> -->
								<parameter type="Switch">
									<name>reportancstateopts</name>
									<attributes>
										<prompt>Report the probability of ancestral states at all constrained nodes</prompt>
										<paramfile>paramfile.txt</paramfile>
										<vdef>
											<value>0</value>
										</vdef>
										<precond>
											<language>perl</language>
											<code>!$mrbayesblockquery &amp;&amp; $topologypropts eq "constraint"</code>
										</precond>
										<format>
											<language>perl</language>
											<code>($value)? "report Ancstates=Yes\\n":"report Ancstates=No\\n"</code>
										</format>
										<group>45</group>
									</attributes>
								</parameter>
								<parameter type="Switch">
									<name>reportsiterateopts</name>
									<attributes>
										<prompt>Report mean site rate in the posterior</prompt>
										<precond>
											<language>perl</language>
											<code>!$mrbayesblockquery</code>
										</precond>
										<paramfile>paramfile.txt</paramfile>
										<vdef>
											<value>0</value>
										</vdef>
										<!--<precond>
														<language>perl</language>
														<code>$rateopts eq "gamma" || $rateopts eq "adgamma" || $rateopts eq "propinv" || $rateopts eq "invgamma"</code>
													</precond> -->
										<format>
											<language>perl</language>
											<code>($value)? "report Siterates=Yes\\n":"report Siterates=No\\n"</code>
										</format>
										<group>45</group>
									</attributes>
								</parameter>
								<parameter type="Switch">
									<name>reportposselopts</name>
									<attributes>
										<prompt>Write Mean Omega Values</prompt>
										<paramfile>paramfile.txt</paramfile>
										<vdef>
											<value>0</value>
										</vdef>
										<precond>
											<language>perl</language>
											<code>!$mrbayesblockquery &amp;&amp; $nucmodelopts eq "codon"</code>
										</precond>
										<format>
											<language>perl</language>
											<code>($value)? "report possel=Yes\\n":"report possel=No\\n"</code>
										</format>
										<group>45</group>
									</attributes>
								</parameter>
							</parameters>
						</paragraph>
					</parameter>
					<!--The parameters are sub commands of the sumt option-->
					<parameter type="Paragraph">
						<paragraph>
							<name>sumtintro</name>
							<prompt>Set Sumt parameters</prompt>
							<comment>
								<value> Sumt command is used to produce summary statistics for trees sampled during a Bayesian MCMC analysis. You can either summarize trees from one individual analysis, or trees coming from several independent analyses. In either case, all the sampled trees are read in and the proportion of the time any single taxon bipartition is found is counted. The proportion of the time that the bipartition is found is an approximation of the posterior probability of the bipartition. (A taxon bipartition is defined by removing a branch on the tree, dividing the tree into those taxa to the left and right  of the removed branch.) The branchlength of the bipartition is also recorded, if branch lengths have been saved to file. The result is a list of taxon bipartitions, the frequency with which they were found, the posterior probability of the bipartition and the mean and variance of the lengthof the branch (if bl's were recorded). 

The partition information is output to a file with the suffix ".parts" and a consensus tree is also printed to a file with the suffix ".con". The consensus tree is either a 50 percent majority rule tree or a majority rule tree showing all compatible partitions. If branch lengths have been recorded during the run, the ".con" file will contain a consensus tree with branch lengths and interior nodes labelled with support values. This tree can be viewed in a program such as TreeView. Finally, MrBayes produces a file with the ending ".trprobs" that contains a  list of all the trees that were found during the MCMC analysis, sorted by their probabilities. This list of trees can be used to construct a credible set of trees. For example, if you want to construct a 95 percent credible set of trees, you include all of those trees whose cumulated probability is less than or equal to 0.95. If you are analyzing a large set of taxa, you may actually want to skip the calculation of tree probabilities entirely by setting "Calctreeprobs" to NO.                                                       

When calculating summary statistics you probably want to skip those trees that were sampled in the initial part of the run, the so-called burn-in period. The number of skipped samples is controlled by the "burnin" setting. The default is 0 but you typically want to override this setting. If you are summarizing the trees sampled in several independent analyses, such as those resulting from setting the "Nruns" option of the "Mcmc" command to a value larger than 1, MrBayes will also calculate convergence diagnostics for the sampled topologies and branch lengths. These values can help you determine whether it is likely that your chains have converged. 

The "Sumt" command expands the "Filename" according to the current values of the "Nruns" and "Ntrees" options. For instance, if both "Nruns" and "Ntrees" are set to 1, "Sumt" will try to open a file named "Filename.t". If "Nruns" is set to 2 and "Ntrees" to 1, then "Sumt" will open two files, Filename.run1.t and Filename.run2.t, etc. By default, the "Filename" option will be set such that "Sumt" automatically summarizes all the results from your immediately preceding "Mcmc"  command. You can also use the "Sumt" command to summarize tree samples inolder analyses. If you want to do that, remember to first read in a matrix so that MrBayes knows what taxon names to expect in the trees. Then set the  "Nruns", "Ntrees" and "Filename" options appropriately.

Options:                              
Burnin  -- Determines the number of samples that will be discarded from the input file before calculating summary statistics. If there are several input files, the same number of sampleswill be discarded from each. Note that the burnin is set separately for the 'sumt', 'sump', and 'mcmc' commands.                                               
Ntrees   -- Determines how many trees there are in the sampled model. If 'Ntrees' is greater then 1 then the names of the files are derived from 'Filename' by adding '.tree1.t', '.tree2.t', etc. If Nruns=1 and Ntrees=1 (see below), then only '.t' is added to 'Filename'.  
Displaygeq   -- The minimum probability of partitions to display.
Contype       -- Type of consensus tree. 'Halfcompat' results in a 50 majority rule tree, 'Allcompat' adds all compatible groups to such a tree.                                                       
Calctreeprobs -- Determines whether tree probabilities should be calculated.                           

</value>
							</comment>
							<parameters>
								<parameter type="Integer">
									<name>sumtburnin</name>
									<attributes>
										<prompt>Sumt Burnin Value</prompt>
										<precond>
											<language>perl</language>
											<code>!$mrbayesblockquery</code>
										</precond>
										<paramfile>paramfile.txt</paramfile>
										<vdef>
											<value>10</value>
										</vdef>
										<format>
											<language>perl</language>
											<code>"sumt burnin=$value relburnin=$sumt_relburnin burninfrac=$sumt_burninfrac nruns=$sumtnruns ntrees=$sumtntrees displaygeq=$sumtdisplaygeq $sumtcontype conformat=$sumt_conformat\\n"</code>
										</format>
										<ctrls>
											<ctrl>
												<message>Please enter a sumt burnin value of 10 or more</message>
												<language>perl</language>
												<code>$value &lt; 10</code>
											</ctrl>
										</ctrls>
										<group>70</group>
									</attributes>
								</parameter>
								<!-- add for mb 3.2 -->
								<parameter type="Excl">
									<name>sumt_relburnin</name>
									<attributes>
										<prompt>Discard a specified proportion of samples instead of a specific number(Relburnin=Yes)</prompt>
										<precond>
											<language>perl</language>
											<code>!$mrbayesblockquery</code>
										</precond>
										<paramfile>paramfile.txt</paramfile>
										<vdef>
											<value>Yes</value>
										</vdef>
										<vlist>
											<value>Yes</value>
											<label>Yes</label>
											<value>No</value>
											<label>No</label>
										</vlist>
										<format>
											<language>perl</language>
											<code>""</code>
										</format>
										<group>60</group>
										<comment>
											<value> Specify the fraction of samples to be discarded.                                     
</value>
										</comment>
									</attributes>
								</parameter>
								
								<parameter type="Float">
									<name>sumt_burninfrac</name>
									<attributes>
										<prompt>Specify the fraction of samples to be discarded (Burninfrac=)</prompt>
										<precond>
											<language>perl</language>
											<code>!$mrbayesblockquery &amp;&amp; $sumt_relburnin eq Yes</code>
										</precond>
										<paramfile>paramfile.txt</paramfile>
										<vdef>
											<value>0.25</value>
										</vdef>
										<format>
											<language>perl</language>
											<code>""</code>
										</format>
										<group>60</group>
										<comment>
											<value> Specify the fraction of samples to be discarded.                                     
</value>
										</comment>
									</attributes>
								</parameter>
								<parameter type="Integer">
									<name>sumtnruns</name>
									<attributes>
										<prompt>How many .t files should be summarized (Sumt nruns=)</prompt>
										<precond>
											<language>perl</language>
											<code>!$mrbayesblockquery</code>
										</precond>
										<paramfile>paramfile.txt</paramfile>
										<vdef>
											<value>2</value>
										</vdef>
										<format>
											<language>perl</language>
											<code>""</code>
										</format>
										<group>70</group>
										<comment>
											<value>Sumt Nruns Determines how many '.t' files from independent analyses will be summarized. If Nruns > 1 then the names of the files are derived from 'Filename' by adding '.run1.t', '.run2.t', etc. If Nruns=1 and Ntrees=1 (see below), then only '.t' is added to 'Filename'.                                          
</value>
										</comment>
									</attributes>
								</parameter>
								<parameter type="Integer">
									<name>sumtntrees</name>
									<attributes>
										<prompt>How many trees should be in the Sumt model</prompt>
										<precond>
											<language>perl</language>
											<code>!$mrbayesblockquery</code>
										</precond>
										<paramfile>paramfile.txt</paramfile>
										<vdef>
											<value>1</value>
										</vdef>
										<format>
											<language>perl</language>
											<code>""</code>
										</format>
										<group>70</group>
										<comment>
											<value>Sumt Ntrees  determines how many trees there are in the sampled model. If 'Ntrees' > 1 then the names of the files are derived from 'Filename' by adding '.tree1.t', '.tree2.t', etc. If there are both multiple trees and multiple runs, the filenames will be 'Filename.tree1.run1.t', 'Filename.tree1.run2.t', etc.</value>
										</comment>
									</attributes>
								</parameter>
								<!--  The Filename parameter is not supported. Filename specifies the name of the file(s) to be summarized. This is the base of the file name, to which endings are added according to the current settings of the 'Nruns' and 'Ntrees' options.     -->
								<parameter type="Float">
									<name>sumtdisplaygeq</name>
									<attributes>
										<prompt>Minimum probability of partitions to display in Sumt (0.05 = 95%)</prompt>
										<precond>
											<language>perl</language>
											<code>!$mrbayesblockquery</code>
										</precond>
										<paramfile>paramfile.txt</paramfile>
										<vdef>
											<value>0.05</value>
										</vdef>
										<format>
											<language>perl</language>
											<code>""</code>
										</format>
										<group>70</group>
									</attributes>
								</parameter>

								<parameter ismandatory="1" type="Excl">
									<name>sumtcontype</name>
									<attributes>
										<prompt>Type of consensus tree</prompt>
										<paramfile>paramfile.txt</paramfile>
										<vdef>
											<value>contype=Halfcompat</value>
										</vdef>
										<format>
											<language>perl</language>
											<code>""</code>
										</format>
										<group>70</group>
										<precond>
											<language>perl</language>
											<code>!$mrbayesblockquery</code>
											<!-- not sure why this prcond on sumtcalctreeprobs would have been required.
										<code>!$mrbayesblockquery &amp;&amp; $sumtcalctreeprobs</code> -->
										</precond>
										<vlist>
											<value>contype=Halfcompat</value>
											<label>50% Majority Rule</label>
											<value>contype=Allcompat</value>
											<label>All Compatible Groups</label>
										</vlist>
										<comment>
											<value>Contype sets the type of consensus tree. The choices are 50 per cent majority rule tree, and one where all compatible groups are added to the tree.</value>
										</comment>
									</attributes>
								</parameter>
<!-- added for MB 3.2 -->								
								<parameter type="Excl">
									<name>sumt_conformat</name>
									<attributes>
										<prompt>Choose the output format for your consensus tree (Conformat=)</prompt>
										<precond>
											<language>perl</language>
											<code>!$mrbayesblockquery</code>
										</precond>
										<paramfile>paramfile.txt</paramfile>
										<vdef>
											<value>Figtree</value>
										</vdef>
										<vlist>
											<value>Figtree</value>
											<label>Figtree</label>
											<value>Simple</value>
											<label>Simple</label>
										</vlist>
										<format>
											<language>perl</language>
											<code>""</code>
										</format>
										<group>60</group>
										<comment>
											<value> Figtree format is rich and can be read by the program Figtree. Simple format can be read by many programs                                     
</value>
										</comment>
									</attributes>
								</parameter>
								<!-- this paramater is not found by the app -->
								<!--							<parameter type="Switch">
								<name>sumtcalctreeprobs</name>
								<attributes>
									<prompt>Calculate Tree Probabilities</prompt>
									<precond>
										<language>perl</language>
										<code>!$mrbayesblockquery</code>
									</precond>
									<paramfile>paramfile.txt</paramfile>
									<vdef>
										<value>1</value>
									</vdef>
									<format>
										<language>perl</language>
										<code>($value)? "sumt calctreeprobs = Yes\\n":"sumt calctreeprobs = No\\n"</code>
									</format>
									<group>70</group>
								</attributes>
							</parameter> -->
								<parameter ismandatory="1" type="Excl">
									<name>sumtshowtreeprobs</name>
									<attributes>
										<prompt>Show Tree Probabilities</prompt>
										<precond>
											<language>perl</language>
											<code>!$mrbayesblockquery</code>
										</precond>
										<paramfile>paramfile.txt</paramfile>
										<vdef>
											<value>showtreeprobs=No</value>
										</vdef>
										<vlist>
											<value>showtreeprobs=Yes</value>
											<label>Yes</label>
											<value>showtreeprobs=No</value>
											<label>No</label>
										</vlist>
										<format>
											<language>perl</language>
											<code>""</code>
										</format>
										<group>70</group>
									</attributes>
								</parameter>
							</parameters>
						</paragraph>
					</parameter>
					<!--The parameters are sub commands of the sump option -->
					<parameter type="Paragraph">
						<paragraph>
							<name>sumpintro</name>
							<prompt>Set Sump parameters</prompt>
							<comment>
								<value>Sump specifies how information is summarized, and written to a parameter file. During MCMC analysis, MrBayes prints the sampled parameter values to a tab delimited text file. By default, the name of the parameter file is assumed to be the name of the last matrix-containing nexus file, but with a '.p' extension. You can set 'Sump' to summarize the information in any other parameter file by setting the 'filename' option to the appropriate file name. The 'Sump' command does not require a matrix to be read in first. When you invoke the 'Sump' command, three items are output (1) a generation plot of the likelihood values; (2) estimates of the marginal likelihood of the model; and (3) a table with the mean, variance, and 95 percent credible interval for the sampled parameters. Each of these items can be switched on or off using the options 'Plot', 'Marglike', and 'Table'. By default, all three items are output but only to the screen. If output to a file is also desired, set 'Printtofile' to 'Yes'. The name of the output file is specified by setting the 'Outputname' option. When a new matrix is read in or when the 'Mcmc' output filename or 'Sump' input filename is changed, the 'Sump' outputname is changed as well. If you want to output to another file than the default, make sure you specify the outputname every time you invoke 'Sump'. If the specified outputfile already exists, you will   
be prompted about whether you like to overwrite it or append to it. When you run several independent analyses simultaneously in MrBayes, the 'Nruns' and 'Filename' options are automatically set such that 'Sump' will summarize all the resulting output files.                                                             
                                     
                                                                                  
Default settings:    Burnin:0; Nruns:1; Filename:temp.p.p; Printtofile:No; Outputname:temp.p.stat; Plot:Yes; Marglike:Yes; Table:Yes                                  
</value>
							</comment>
							<parameters>
								<parameter type="Integer">
									<name>sumpburnin</name>
									<attributes>
										<prompt>Sump Burnin Value</prompt>
										<precond>
											<language>perl</language>
											<code>!$mrbayesblockquery</code>
										</precond>
										<paramfile>paramfile.txt</paramfile>
										<vdef>
											<value>10</value>
										</vdef>
										<format>
											<language>perl</language>
											<code>"sump burnin=$value relburnin=$sump_relburnin burninfrac=$sump_burninfrac nruns=$sumpnruns printtofile=yes outputname=sumpoutput.out $sumpplot $sumpmarglike $sumptable\\n"</code>
										</format>
										<ctrls>
											<ctrl>
												<message>Please enter a sump burnin value of 10 or more</message>
												<language>perl</language>
												<code>$value &lt; 10</code>
											</ctrl>
										</ctrls>
										<group>60</group>
										<comment>
											<value>Burnin determines the number of samples that will be discarded from the input file before calculating summary statistics. If there are several input files, the same number of samples will 				be discarded from each.</value>
										</comment>
									</attributes>
								</parameter>
<!-- add for mb 3.2 -->
								<parameter type="Excl">
									<name>sump_relburnin</name>
									<attributes>
										<prompt>Discard a specified proportion of samples instead of a specific number(Relburnin=Yes)</prompt>
										<precond>
											<language>perl</language>
											<code>!$mrbayesblockquery</code>
										</precond>
										<paramfile>paramfile.txt</paramfile>
										<vdef>
											<value>Yes</value>
										</vdef>
										<vlist>
											<value>Yes</value>
											<label>Yes</label>
											<value>No</value>
											<label>No</label>
										</vlist>
										<format>
											<language>perl</language>
											<code>""</code>
										</format>
										<group>60</group>
										<comment>
											<value> Specify the fraction of samples to be discarded.                                     
</value>
										</comment>
									</attributes>
								</parameter>
								
								<parameter type="Float">
									<name>sump_burninfrac</name>
									<attributes>
										<prompt>Specify the fraction of samples to be discarded (Burninfrac=)</prompt>
										<precond>
											<language>perl</language>
											<code>!$mrbayesblockquery &amp;&amp; $sump_relburnin eq Yes</code>
										</precond>
										<paramfile>paramfile.txt</paramfile>
										<vdef>
											<value>0.25</value>
										</vdef>
										<format>
											<language>perl</language>
											<code>""</code>
										</format>
										<group>60</group>
										<comment>
											<value> Specify the fraction of samples to be discarded.                                     
</value>
										</comment>
									</attributes>
								</parameter>
								
								<parameter type="Integer">
									<name>sumpnruns</name>
									<attributes>
										<prompt>How many '.p' files from independent analyses will be summarized (sump Nruns=)</prompt>
										<precond>
											<language>perl</language>
											<code>!$mrbayesblockquery</code>
										</precond>
										<paramfile>paramfile.txt</paramfile>
										<vdef>
											<value>2</value>
										</vdef>
										<format>
											<language>perl</language>
											<code>""</code>
										</format>
										<group>60</group>
										<comment>
											<value>Sump nruns determines how many '.p' files from independent analyses that will be summarized. If Nruns > 1 then the names of the files are derived from 'Filename' by adding '.run1.p', '.run2.p', etc. If Nruns=1, then the single file name is obtained by adding '.p' to 'Filename'.                                     
</value>
										</comment>
									</attributes>
								</parameter>
												
<!-- eliminated in mb 3.2								<parameter ismandatory="1" type="Excl">
									<name>sumpplot</name>
									<attributes>
										<prompt>Prepare a likelihood plot</prompt>
										<precond>
											<language>perl</language>
											<code>!$mrbayesblockquery</code>
										</precond>
										<paramfile>paramfile.txt</paramfile>
										<vdef>
											<value>plot=Yes</value>
										</vdef>
										<vlist>
											<value>plot=Yes</value>
											<label>Yes</label>
											<value>plot=No</value>
											<label>No</label>
										</vlist>
										<format>
											<language>perl</language>
											<code>""</code>
										</format>
										<group>60</group>
									</attributes>
								</parameter>
								<parameter ismandatory="1" type="Excl">
									<name>sumpmarglike</name>
									<attributes>
										<prompt>Calculate estimates of marginal model likelihoods</prompt>
										<precond>
											<language>perl</language>
											<code>!$mrbayesblockquery</code>
										</precond>
										<paramfile>paramfile.txt</paramfile>
										<vdef>
											<value>marglike=Yes</value>
										</vdef>
										<vlist>
											<value>marglike=Yes</value>
											<label>Yes</label>
											<value>marglike=No</value>
											<label>No</label>
										</vlist>
										<format>
											<language>perl</language>
											<code>""</code>
										</format>
										<group>60</group>
									</attributes>
								</parameter>
								<parameter ismandatory="1" type="Excl">
									<name>sumptable</name>
									<attributes>
										<prompt>Prepare a table summarizing the parameter value samples</prompt>
										<precond>
											<language>perl</language>
											<code>!$mrbayesblockquery</code>
										</precond>
										<paramfile>paramfile.txt</paramfile>
										<vdef>
											<value>table=Yes</value>
										</vdef>
										<vlist>
											<value>table=Yes</value>
											<label>Yes</label>
											<value>table=No</value>
											<label>No</label>
										</vlist>
										<format>
											<language>perl</language>
											<code>""</code>
										</format>
										<group>60</group>
									</attributes>
								</parameter> -->
							</parameters>
						</paragraph>
					</parameter>
				</parameters>
			</paragraph>
		</parameter>

	</parameters>
</pise>

