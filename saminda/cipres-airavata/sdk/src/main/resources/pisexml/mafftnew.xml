<?xml version = "1.0" encoding = "UTF-8" ?>
<!DOCTYPE pise SYSTEM "http://www.phylo.org/dev/rami/PARSER/pise.dtd" [
<!ENTITY runtime SYSTEM "http://www.phylo.org/dev/rami/XMLDIR/triton_run_time.xml">
]>
<!--
	Mafft xml prepared by Rahul Suri
	
NAME

mafft - Multiple alignment program for amino acid or nucleotide sequences

 
SYNOPSIS

mafft [options] input [> output]
linsi input [> output]
ginsi input [> output]
einsi input [> output]
fftnsi input [> output]
fftns input [> output]
nwns input [> output]
nwnsi input [> output]
mafft-profile group1 group2 [> output]
input, group1 and group2 must be in FASTA format.

 
DESCRIPTION

MAFFT is a multiple sequence alignment program for unix-like operating systems. It offers a range of multiple alignment methods.
 
Accuracy-oriented methods:

*L-INS-i (probably most accurate; recommended for <200 sequences; iterative refinement method incorporating local pairwise alignment information):
	mafft -localpair -maxiterate 1000 input [> output]
	linsi input [> output]

*G-INS-i (suitable for sequences of similar lengths; recommended for <200 sequences; iterative refinement method incorporating global pairwise alignment information):
	mafft -globalpair -maxiterate 1000 input [> output]
	ginsi input [> output]

*E-INS-i (suitable for sequences containing large unalignable regions; recommended for <200 sequences):
	mafft -ep 0 -genafpair -maxiterate 1000 input [> output]
	einsi input [> output]
	For E-INS-i, the -ep 0 option is recommended to allow large gaps.
 
Speed-oriented methods:

*FFT-NS-i (iterative refinement method; two cycles only):
	mafft -retree 2 -maxiterate 2 input [> output]
	fftnsi input [> output]

*FFT-NS-i (iterative refinement method; max. 1000 iterations):
	mafft -retree 2 -maxiterate 1000 input [> output]

*FFT-NS-2 (fast; progressive method):
	mafft -retree 2 -maxiterate 0 input [> output]
	fftns input [> output]

*FFT-NS-1 (very fast; recommended for >2000 sequences; progressive method with a rough guide tree):
	mafft -retree 1 -maxiterate 0 input [> output]

*NW-NS-i (iterative refinement method without FFT approximation; two cycles only):
	mafft -retree 2 -maxiterate 2 -nofft input [> output]
	nwnsi input [> output]

*NW-NS-2 (fast; progressive method without the FFT approximation):
	mafft -retree 2 -maxiterate 0 -nofft input [> output]
	nwns input [> output]

*NW-NS-PartTree-1 (recommended for ~10,000 to ~50,000 sequences; progressive method with the PartTree algorithm):
	mafft -retree 1 -maxiterate 0 -nofft -parttree input [> output]
 
Group-to-group alignments

mafft-profile group1 group2 [> output]
or:
mafft -maxiterate 1000 -seed group1 -seed group2 /dev/null [> output]


OPTIONS

Algorithm

-auto
Automatically selects an appropriate strategy from L-INS-i, FFT-NS-i and FFT-NS-2, according to data size. Default: off (always FFT-NS-2)

-6merpair
Distance is calculated based on the number of shared 6mers. Default: on

-globalpair
All pairwise alignments are computed with the Needleman-Wunsch algorithm. More accurate but slower than -6merpair. Suitable for a set of globally alignable sequences. Applicable to up to ~200 sequences. A combination with -maxiterate 1000 is recommended (G-INS-i). Default: off (6mer distance is used)

-localpair
All pairwise alignments are computed with the Smith-Waterman algorithm. More accurate but slower than -6merpair. Suitable for a set of locally alignable sequences. Applicable to up to ~200 sequences. A combination with -maxiterate 1000 is recommended (L-INS-i). Default: off (6mer distance is used)

-genafpair
All pairwise alignments are computed with a local algorithm with the generalized affine gap cost (Altschul 1998). More accurate but slower than -6merpair. Suitable when large internal gaps are expected. Applicable to up to ~200 sequences. A combination with -maxiterate 1000 is recommended (E-INS-i). Default: off (6mer 
distance is used)

-fastapair
All pairwise alignments are computed with FASTA (Pearson and Lipman 1988). FASTA is required. Default: off (6mer distance is used)

-weighti number
Weighting factor for the consistency term calculated from pairwise alignments. Valid when either of -blobalpair, -localpair, -genafpair, -fastapair or -blastpair is selected. Default: 2.7

-retree number
Guide tree is built number times in the progressive stage. Valid with 6mer distance. Default: 2

-maxiterate number
number cycles of iterative refinement are performed. Default: 0

-fft
Use FFT approximation in group-to-group alignment. Default: on

-nofft
Do not use FFT approximation in group-to-group alignment. Default: off

-noscore
Alignment score is not checked in the iterative refinement stage. Default: off (score is checked)

-memsave
Use the Myers-Miller (1988) algorithm. Default: automatically turned on when the alignment length exceeds 10,000 (aa/nt).

-parttree
Use a fast tree-building method (PartTree, Katoh and Toh 2007) with the 6mer distance. Recommended for a large number (> ~10,000) of sequences are input. Default: off

-dpparttree
The PartTree algorithm is used with distances based on DP. Slightly more accurate and slower than -parttree. Recommended for a large number (> ~10,000) of sequences are input. Default: off

-fastaparttree
The PartTree algorithm is used with distances based on FASTA. Slightly more accurate and slower than -parttree. Recommended for a large number (> ~10,000) of sequences are input. FASTA is required. Default: off

-partsize number
The number of partitions in the PartTree algorithm. Default: 50

-groupsize number
Do not make alignment larger than number sequences. Valid only with the -*parttree options. Default: the number of input sequences
 
Parameter

-op number
Gap opening penalty at group-to-group alignment. Default: 1.53

-ep number
Offset value, which works like gap extension penalty, for group-to-group alignment. Deafult: 0.123

-lop number
Gap opening penalty at local pairwise alignment. Valid when the -localpair or -genafpair option is selected. Default: -2.00

-lep number
Offset value at local pairwise alignment. Valid when the -localpair or -genafpair option is selected. Default: 0.1

-lexp number
Gap extension penalty at local pairwise alignment. Valid when the -localpair or -genafpair option is selected. Default: -0.1

-LOP number
Gap opening penalty to skip the alignment. Valid when the -genafpair option is selected. Default: -6.00

-LEXP number
Gap extension penalty to skip the alignment. Valid when the -genafpair option is selected. Default: 0.00

-bl number
BLOSUM number matrix (Henikoff and Henikoff 1992) is used. number=30, 45, 62 or 80. Default: 62

-jtt number
JTT PAM number (Jones et al. 1992) matrix is used. number>0. Default: BLOSUM62

-tm number
Transmembrane PAM number (Jones et al. 1994) matrix is used. number>0. Default: BLOSUM62

-aamatrix matrixfile
Use a user-defined AA scoring matrix. The format of matrixfile is the same to that of BLAST. Ignored when nucleotide sequences are input. Default: BLOSUM62

-fmodel
Incorporate the AA/nuc composition information into the scoring matrix. Deafult: off
 
Output

-clustalout
Output format: clustal format. Default: off (fasta format)

-inputorder
Output order: same as input. Default: on

-reorder
Output order: aligned. Default: off (inputorder)

-treeout
Guide tree is output to the input.tree file. Default: off

-quiet
Do not report progress. Default: off
 
Input

-nuc
Assume the sequences are nucleotide. Deafult: auto

-amino
Assume the sequences are amino acid. Deafult: auto

-seed alignment1 [-seed alignment2 -seed alignment3 ...]
Seed alignments given in alignment_n (fasta format) are aligned with sequences in input. The alignment within every seed is preserved.

 
FILES

Mafft stores the input sequences and other files in a temporary directory, which by default is located in /tmp.

 
ENVIONMENT

MAFFT_BINARIES
Indicates the location of the binary files used by mafft. By default, they are searched in /usr/local/lib/mafft, but on Debian systems, they are searched in /usr/lib/mafft.

FASTA_4_MAFFT
This variable can be set to indicate to mafft the location to the fasta34 program if it is not in the PATH.
 
SEE ALSO
mafft-homologs(1)

 
REFERENCES

In English

*Katoh and Toh (Bioinformatics 23:372-374, 2007) PartTree: an algorithm to build an approximate tree from a large number of unaligned sequences (describes the PartTree algorithm).
*Katoh, Kuma, Toh and Miyata (Nucleic Acids Res. 33:511-518, 2005) MAFFT version 5: improvement in accuracy of multiple sequence alignment (describes [ancestral versions of] the G-INS-i, L-INS-i and E-INS-i strategies)
*Katoh, Misawa, Kuma and Miyata (Nucleic Acids Res. 30:3059-3066, 2002) MAFFT: a novel method for rapid multiple sequence alignment based on fast Fourier transform (describes the FFT-NS-1, FFT-NS-2 and FFT-NS-i strategies)
 
In Japanese

*Katoh and Misawa (Seibutsubutsuri 46:312-317, 2006) Multiple Sequence Alignments: the Next Generation
*Katoh and Kuma (Kagaku to Seibutsu 44:102-108, 2006) Jissen-teki Multiple Alignment


AUTHORS

Kazutaka Katoh <katoh_at_bioreg.kyushu-u.ac.jp>
Wrote Mafft.

Charles Plessy <charles-debian-nospam_at_plessy.org>
Wrote this manpage in DocBook XML for the Debian distribution, using Mafft's homepage as a template.
 
COPYRIGHT

Copyright © 2002-2007 Kazutaka Katoh (mafft) 
Copyright © 2007 Charles Plessy (this manpage) 

Mafft and its manpage are offered under the following conditions:

Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:

1.Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
2.Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
3.The name of the author may not be used to endorse or promote products derived from this software without specific prior written permission.
THIS SOFTWARE IS PROVIDED BY THE AUTHOR "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
-->
<!-- Modified by mamiller on Nov 17 or so, to add the new Q-INS-i and X-INS-i options for highly diverged RNA structure

	Q-INS-i Usage:

% mafft-qinsi input > output
To use the CONTRAfold algorithm, instead of the default McCaskill algorithm, 

% mafft-qinsi -*contrafold input > output
	
	
    X-INS-i usage: 
	
By default, MXSCARNA is selected as the source of pairwise structural alignment (X-INS-i-scarnapair): 
	
% mafft-xinsi input > output

in other words this is equivalent to 
	
% mafft-xinsi -*scarnapair input > output
	
To use LaRA (X-INS-i-larapair), 

% mafft-xinsi -*larapair -*laraparams lara.params input > output
To use the local alignment option of FOLDALIGN (X-INS-i-foldalignlocalpair), 

% mafft-xinsi -*foldalignlocalpair input > output
To use the global alignment option of FOLDALIGN (X-INS-i-foldalignglobalpair), 

% mafft-xinsi -*foldalignglobalpair input > output
To use CONTRAfold, instead of the McCaskill algorithm, to compute the base-pairing probability, 

% mafft-xinsi -*contrafold -*scarnapair input > output
-->
<pise>
  <head>
    <title>MAFFT</title>
    <version>6.822</version>
    <description>Multiple alignment program for amino acid or nucleotide sequences</description>
    <authors>Kazutaka Katoh, Kei-ichi Kuma, Hiroyuki Toh, and Takashi Miyata</authors>
    <reference>Brief Bioinform. 2008 Jul;9(4):286-98</reference>
    <category>Nucleic Acid Sequence,Protein Sequence,Phylogeny / Alignment</category>
    <doclink>http://align.bmr.kyushu-u.ac.jp/mafft/software/</doclink>
  </head>

  <command>mafftnew</command>

  <parameters>
  
  	&runtime;
    
	<!-- command name: this parameter precedes all instruction strings except for qinsi and xinsi; it was commented out to make life easier -->
    <!--<parameter ishidden="1" type="String"> 
	  <name>mafft</name>
	  <attributes>
	    <format>
		  <language>perl</language>
		  <code>"mafft68"</code>
		</format>
		<group>0</group>
	  </attributes>
	</parameter> -->

    <!-- required input file, this is selected outside the parameters gui -->
    <parameter isinput = "1" type = "InFile">
	  <name>infile</name>
	  <attributes>
	    <prompt>Sequences File (FASTA format)</prompt>
		<filenames>input.fasta</filenames>
		<format>
		  <language>perl</language>
		  <code>"input.fasta"</code>
		</format>
	    <group>98</group>
	  </attributes>	  
	</parameter>
	
	<!-- output all results files -->
	<parameter type="Results">
	  <name>all_outputfiles</name>
	  <attributes>
	    <filenames>*</filenames>
		<group>99</group>
	  </attributes>
	</parameter>

    <!-- output results file -->
	<parameter type="Results">
	  <name>outputfile</name>
	  <attributes>
	    <filenames>output.mafft</filenames>
	    <format>
		  <language>perl</language>
		  <code>" > output.mafft"</code>
		</format>
		<group>99</group>
	  </attributes>
	</parameter>
	
	<!-- Output guide tree file -->
	<parameter type="Results">
	  <name>tree_outputfile</name>
	  <attributes>
	    <filenames>*.tree</filenames>
		<precond>
		  <language>perl</language>
		  <code>defined $outputGuideTree &amp;&amp; $outputGuideTree eq "1"</code>
		</precond>
	  </attributes>
	</parameter>
	  
	<!-- visible selections -->
	<!-- specify what general goal you have -->
	
	<parameter type="Paragraph">
		<paragraph>
			<name>overall</name>
			<prompt>Set the Basic Run Parameters</prompt>
			<parameters>
	
		<!-- input type -->
	<parameter ismandatory = "1" type = "Excl">
	  <name>datatype</name>
	  <attributes>
	    <prompt>Input type</prompt>
		<vlist>
			<value>0</value>
			<label>Determine Automatically</label>
		  
			<value>dna</value>
			<label>Nucleotide</label>

			<value>protein</value>
			<label>Amino Acid</label>
		</vlist>
		
		<vdef>
		  <value>0</value>
		</vdef>
		
		<flist>
			<value>0</value>
			<code>""</code>
		
			<value>dna</value>
			<code>" --nuc"</code>
		
			<value>protein</value>
			<code>"--amino"</code>
		</flist>
		<group>29</group>
	  </attributes>
	</parameter>

	<parameter type="Excl">
	  <name>analysis_type</name>
	  <attributes>
			<prompt>Use a preconfigured MAFFT strategy that:</prompt>
			<precond>
				<language>perl</language>
				<code>!$configure_analysis &amp;&amp; !$auto_analysis</code>
			</precond>
			<vlist>
				<value>accurate</value>
				<label>Favors accuracy</label>
				<value>fast</value>
				<label>Favors speed</label>
				<value>rna</value>
				<label>Considers RNA structure</label>
			</vlist>
			<vdef>
				<value>accurate</value>
			</vdef>
			<ctrls>
				<ctrl>
					<message>Please choose an analysis type, or opt to create an analysis from scratch</message>
					<language>perl</language>
					<code>!$configure_analysis &amp;&amp; !$auto_analysis &amp;&amp; $analysis_type ne "accurate" &amp;&amp; $analysis_type ne "rna" &amp;&amp; $analysis_type ne "fast"</code>
				</ctrl>
			</ctrls>
	  </attributes>
	</parameter>

<!-- Allow user to configure their own run -->	
	<parameter type="Switch">
	  <name>configure_analysis</name>
	  <attributes>
			<prompt>I want to configure my own analysis from scratch: (--mafft)</prompt>
			<precond>
				<language>perl</language>
				<code>!$auto_analysis</code>
			</precond>
			<format>
				<language>perl</language>
				<code>($value) ? "mafft68":""</code>
			</format>
			<vdef>
				<value>0</value>
			</vdef>
			<group>0</group>
	  </attributes>
	</parameter>
	
	<parameter type="Switch">
	  <name>auto_analysis</name>
	  <attributes>
			<prompt>Automatically select an appropriate strategy from L-INS-i, FFT-NS-i and FFT-NS-2 (based on data size) (--auto)</prompt>
			<precond>
				<language>perl</language>
				<code>!$configure_analysis</code>
			</precond> 
			<format>
				<language>perl</language>
				<code>($value) ? "mafft68 --reorder --ep 0.0 --auto":""</code>
			</format>
			<vdef>
				<value>0</value>
			</vdef>
			<group>0</group>
	  </attributes>
	</parameter>
	
	<!-- MAFFT executable; this chooses which accurate mafft heuristic to use -->
	<parameter ismandatory = "1" type = "Excl">
	  <name>accurate_executable</name>
	  <attributes>
	    <prompt>Choose a MAFFT accurate executable</prompt>
	    <precond>
			<language>perl</language>
			<code>$analysis_type eq "accurate"</code>
		</precond>
		<vlist>

		  <value>linsi68</value>
		  <label>L-INS-i </label>

		  <value>ginsi68</value>
		  <label>G-INS-i </label>

		  <value>einsi68</value>
		  <label>E-INS-i</label>
		  
		  <value>ftnsi</value>
		  <label>FFT-NS-i</label>
		  
		</vlist>
		<flist>

		  <value>linsi68</value>
		  <code>"mafft68 --localpair --maxiterate 1000 --reorder --ep 0.0 --retree 1"</code>

		  <value>ginsi68</value>
		  <code>"mafft68 --globalpair --maxiterate 1000 --reorder --ep 0.0 --retree 1"</code>

		  <value>einsi68</value>
		  <code>"mafft68 --ep 0.0 --genafpair --maxiterate 1000 --reorder --retree 1"</code>
		  
		  <value>ftnsi</value>
		  <code>"mafft68 --reorder --ep 0.0 --maxiterate 1000"</code>
		  
		</flist>
		<group>0</group>
		<comment>
			<value>Accuracy-oriented methods:</value>

			<value>* L-INS-i (probably most accurate; recommended for &lt; 200 sequences; iterative refinement method</value>
			<value>           incorporating local pairwise alignment information); equivalent to: </value>
			<value>  mafft --localpair --maxiterate 1000 --reorder --ep 0.0 --retree 1 input [&lt; output]</value>

			<value>* G-INS-i (suitable for sequences of similar lengths; recommended for &lt; 200 sequences; iterative</value>
			<value>           refinement method incorporating global pairwise alignment information); equivalent to:</value>
			<value>  mafft --globalpair --maxiterate 1000 --reorder --ep 0.0 --retree 1 input [&lt; output]</value>

			<value>* E-INS-i (suitable for sequences containing large unalignable regions; recommended for &lt; 200</value>
			<value>           sequences); equivalent to:</value>
			<value>  mafft --ep 0.0 --genafpair --maxiterate 1000 --reorder --retree 1 [&lt; output]</value>
			<value>  For E-INS-i, the --ep 0 option is recommended to allow large gaps.</value>
			<value>FFT-NS-i (Slow; iterative refinement method) equivalent to mafft --reorder --ep 0.0 --maxiterate 1000</value>
		</comment>
	  </attributes>
	</parameter>
	
<!-- MAFFT fast executables; this chooses which mafft fast heuristic to use -->
	<parameter ismandatory = "1" type = "Excl">
	  <name>fast_executables</name>
	  <attributes>
	    <prompt>Choose a fast MAFFT executable</prompt>
	    <precond>
			<language>perl</language>
			<code>$analysis_type eq "fast"</code>
		</precond>
		<vlist>
		  <value>fftns168</value>
		  <label>FFT-NS-1 (0 cycles)</label>

		  <value>fftns268</value>
		  <label>FFT-NS-2 (0 cycles)</label>
		  
		  <value>nwnsi68</value>
		  <label>Medium (2 cycles)</label>

		  <value>nwns68</value>
		  <label>nwns (0 cycles)</label>
										
		</vlist>
		<flist>
		  <value>fftns168</value>
		  <code>"mafft68  --reorder --ep 0.0 --maxiterate 0 --retree 1"</code>

		  <value>fftns268</value>
		  <code>"mafft68  --reorder --ep 0.0 --maxiterate 0"</code>
		  
		  <value>nwnsi68</value>
		  <code>"mafft68  --reorder --ep 0.0 --maxiterate 2"</code>

		  <value>nwns68</value>
		  <code>"mafft68 --retree 2 --maxiterate 0 --nofft"</code>
		  
		</flist>
		<group>0</group>
		<comment>			
			<value>Speed-oriented methods:</value>

			<value>* FFT-NS-i (fftnsi)(iterative refinement method; equivalent to:</value>
			<value> mafft --retree 2 --reorder --ep 0.0 --maxiterate 0 --retree input [&lt; output]</value>

			<value>* FFT-NS-2 (fftns) (fast; progressive method); equivalent to: </value>
			<value> mafft --retree 2  --reorder --ep 0.0 --maxiterate 0  input [&lt; output]</value>

			<value>* NW-NS-i (nwnsi) (iterative refinement, two cycles only); equivalent to:</value>
			<value> mafft --retree 2 --reorder --ep 0.0 --maxiterate 2 input [&lt; output] </value>

			<value>* NW-NS-2 (nwns) (fast; progressive method without the FFT approximation); equivalent to:</value>
			<value> mafft --retree 2 --maxiterate 0 --nofft input [&lt; output] </value>
			
		</comment>
	  </attributes>
	</parameter>
	  
<!-- MAFFT executable; this chooses which mafft RNA structure heuristic to use -->
	<parameter ismandatory = "1" type = "Excl">
	  <name>rna_executable</name>
	  <attributes>
	    <prompt>Choose a MAFFT RNA structure executable</prompt>
	    <precond>
			<language>perl</language>
			<code>$analysis_type eq "rna"</code>
		</precond>
		<vlist>
<!--  add the new Q-INS-i option highly diverged RNA structure -->
		  <value>qinsi68</value>
		  <label>Q-INS-i</label>	  
<!--  add the  X-INS-i option  -->
		  <value>xinsi68</value>
		  <label>X-INS-i</label>	  
		</vlist>
		<flist>
				  
<!--  add the new Q-INS-i option highly diverged RNA structure -->	
		  <value>qinsi68</value>
		  <code>"mafft-qinsi68 --reorder --ep 0.0"</code>	  
<!--    X-INS-i usage: -->
		   <value>xinsi68</value>
		   <code>"mafft-xinsi68 --reorder --ep 0.0"</code>	  
		</flist>
		<vdef>
		  <value>qinsi68</value>
		</vdef>
		<group>0</group>
		<comment>
			<value>RNA structure methods</value>
			<value>* Q-INS-i (suitable for sequences containing large unalignable regions; recommended for &lt; 200 X 1,000 nt</value>
			<value>  sequences); equivalent to:</value>
			<value>  mafft-qunisi --reorder --ep 0.0 [--objective function]</value>
			<value>  Secondary structure information of RNA is considered.  Uses the Four-way Consistency objective function (Katoh and Toh, submitted) for incorporating structural information. These methods are suitable for a global alignment of highly diverged ncRNA sequenes. For relatively conserved RNAs, such as SSU and LSU rRNA, the advantage of these methods is small. Uses the Four-way Consistency objective function (Katoh and Toh, submitted) for incorporating structural information. 
</value>
			
			<value>* X-INS-i (suitable for sequences containing large unalignable regions; recommended for &lt; 50 sequences x 1,000 nt</value>
			<value>           sequences); equivalent to:</value>
			<value> mafft-xinsi --reorder --ep 0.0 [--algorithm] CONTRAfold  or McCaskill (default) algorithm</value>
			<value> X-INS-i is a framework based on the Four-way Consistency objective function to build a multiple structural alignment by combining pairwise structural alignments given by an external program.  At present, the external program can be selected from MXSCARNA (default), LaRA and FOLDALIGN (the local and global options). 
</value>
		</comment>
	  </attributes>
	</parameter>

<!-- configure RNA structure runs -->
					<parameter type="Switch">
						<name>use_contrafold</name>
						<attributes>
							<prompt>Use Contrafold rather than McCaskill algorithm (--contrafold)</prompt>
							<precond>
								<language>perl</language>
								<code>$analysis_type eq "rna" </code>
							</precond>
							<format>
								<language>perl</language>
								<code>($value) ? "--contrafold":""</code>
							</format>
						</attributes>
				</parameter>
				
				<parameter type="Excl">
						<name>xinsi_option</name>
						<attributes>
							<prompt>Which X-INS-i option should be used</prompt>
							<precond>
								<language>perl</language>
								<code>$rna_executable eq "xinsi68"</code>
							</precond>
							<vdef>
								<value>scarnapair</value>
							</vdef>
							<vlist>
								<value>larapair</value>
								<label>larapair</label>
								<value>foldalignlocalpair</value>
								<label>foldalignlocalpair</label>
								<value>--foldalignglobalpair</value>
								<label>foldalignglobalpair</label>
								<value>scarnapair</value>
								<label>MXSCARNA</label>
							</vlist>
							<flist>
								<value>larapair</value>
								<code>"--larapair"</code>
								<value>foldalignlocalpair</value>
								<code>"--foldalignlocalpair"</code>
								<value>foldalignglobalpair</value>
								<code>"--foldalignglobalpair"</code>
								<value>scarnapair</value>
								<code>"--scarnapair"</code>
							</flist>
						</attributes>
				</parameter>
			</parameters>
		</paragraph>
	</parameter>

  <parameter type = "Paragraph">
	  <paragraph>
		  <name>para_algorithm</name>
		  <prompt>Algorithm Options</prompt>
			  <parameters>

	<!-- distance metric -->
				<parameter ismandatory = "1" type = "Excl">
					<name>distanceMetric</name>
					<attributes>
						<prompt>Distance metric</prompt>
						<precond>
						<language>perl</language>
						<code>$configure_analysis</code>
						</precond>
						<vlist>
							<value>0</value>
							<label>6merpair</label>
		  
							<value>1</value>
							<label>globalpair</label>

							<value>2</value>
							<label>localpair</label>

							<value>3</value>
							<label>genafpair</label>

							<value>4</value>
							<label>fastapair</label>
						</vlist>
						<flist>
							<value>0</value>
							<code>" --6merpair"</code>
		  
							<value>1</value>
							<code>" --globalpair"</code>

							<value>2</value>
							<code>" --localpair"</code>

							<value>3</value>
							<code>" --genafpair"</code>

							<value>4</value>
							<code>" --fastapair"</code>
						</flist>
						<vdef>
							<value>0</value>
						</vdef>
						<group>2</group>
						<comment>
							<value>* 6merpair: Distance is calculated based on the number of shared 6mers.</value>

							<value>* globalpair: All pairwise alignments are computed with the Needleman-Wunsch algorithm. More accurate</value>
							<value> but slower than using 6merpair. Suitable for a set of globally alignable sequences. Applicable to up to</value>
							<value> ~200 sequences. A combination with --maxiterate 1000 is recommended (G-INS-i).</value>

							<value>* localpair: All pairwise alignments are computed with the Smith-Waterman algorithm. More ac	curate but</value>
							<value> slower than using 6merpair. Suitable for a set of locally alignable sequences. Applicable up to ~200</value>
							<value> sequences. A combination with --maxiterate 1000 is recommended (L-INS-i).</value>

							<value>* genafpair: All pairwise alignments are computed with a local algorithm with the generalized affine</value>
							<value> gap cost (Altschul 1998). More accurate but slower than using 6merpair. Suitable when large internal</value>
							<value> gaps are expected. Applicable to up to ~200 sequences. A combination with --maxiterate 1000 is</value>
							<value> recommended (E-INS-i).</value>

							<value>* fastapair: All pairwise alignments are computed with FASTA (Pearson and Lipman 1988). FASTA is required.</value>
						</comment>
					</attributes>
				</parameter> 

	<!-- weighting factor -->
	<parameter ismandatory = "1" type = "Float">
	  <name>weighting_factor</name>
	  <attributes>
	    <prompt>Weighting factor for the consistency term calculated from pairwise alignments (--weighti)</prompt>
		<precond>
		  <language>perl</language>
		  <code>$configure_analysis &amp;&amp; $distanceMetric ne "0"</code>
		</precond>
		<format>
		  <language>perl</language>
		  <code>(defined $value &amp;&amp; $value ne $vdef) ? " --weighti $value" : ""</code>
		</format>
	    <vdef>
		  <value>2.7</value>
		</vdef>
		<comment>
			<value>Weighting factor for the consistency term calculated from pairwise alignments. Valid when any of --blobalpair,</value>
			<value> --localpair, --genafpair, --fastapair or --blastpair is selected.</value>
		</comment>
		<group>3</group>
	  </attributes>
	</parameter>
	
	<!-- # of times guide tree is built -->
	<parameter type = "Integer">
		<name>retrees</name>
		<attributes>
			<prompt>Number of times guide tree is built in progressive stage (--retree)</prompt>
			<precond>
				<language>perl</language>
				<code>($distanceMetric eq "0") &amp;&amp; $configure_analysis</code>
			</precond>
			<format>
				<language>perl</language>
				<code>(defined $value &amp;&amp; $value ne $vdef) ? " --retree $value" : ""</code>
			</format>
			<vdef>
				<value>2</value>
			</vdef>
			<comment>
				<value>Valid only with 6-mer distances</value>
			</comment>
			<group>4</group>
		</attributes>
	</parameter>

	<!-- # of cycles of iterative refinement -->
	<parameter  type = "Integer">
	  <name>iterativeRefinements</name>
	  <attributes>
	    <prompt>Number of cycles of iterative refinement (-maxiterate)</prompt>
	    <precond>
		  <language>perl</language>
		  <code>$configure_analysis</code>
		</precond>
		<format>
		  <language>perl</language>
		  <code>(defined $value &amp;&amp; $value ne $vdef) ? " --maxiterate $value" : ""</code>
		</format>
	    <vdef>
		  <value>0</value>
		</vdef>
		<group>5</group>
	  </attributes>
	</parameter>

	<!-- FFT approximation -->
	<parameter type = "Excl">
	  <name>useFFT</name>
	  <attributes>
	    <prompt>FFT approximation in group-to-group alignment</prompt>
	    <precond>
		  <language>perl</language>
		  <code>$configure_analysis</code>
		</precond>
		<vlist>
		  <value>0</value>
		  <label>off</label>
		  <value>1</value>
		  <label>on</label>
		</vlist>
		<vdef>
		  <value>1</value>
		</vdef>
		<format>
		  <language>perl</language>
		  <code>(defined $value &amp;&amp; $value ne $vdef) ? " --nofft" : ""</code>
		</format>
		<group>6</group>
	  </attributes>
	</parameter> 

<!-- check alignment score? -->
	<parameter type = "Excl">
	  <name>noScore</name>
	  <attributes>
	    <prompt>Check alignment score in iterative refinement stage ( --noscore)</prompt>
		<vlist>
		  <value>0</value>
		  <label>no</label>
		  <value>1</value>
		  <label>yes</label>
		</vlist>
		<vdef>
		  <value>1</value>
		</vdef>
		<format>
		  <language>perl</language>
		  <code>(defined $value &amp;&amp; $value ne $vdef) ? " --noscore" : ""</code>
		</format>
		<group>7</group>
	  </attributes>
	</parameter>

<!-- memsave -->
	<parameter type = "Excl">
	  <name>memSave</name>
	  <attributes>
	    <prompt>Use the Myers-Miller (1988) algorithm (--memsave)</prompt>
		<vlist>
		  <value>0</value>
		  <label>auto-select</label>
		  <value>1</value>
		  <label>yes</label> 
		</vlist>
		<vdef>
		  <value>0</value>
		</vdef>
		<format>
		  <language>perl</language>
		  <code>(defined $value &amp;&amp; $value ne $vdef) ? " --memsave" : ""</code>
		</format>
		<comment>
			<value>By default, this is automatically turned on when the alignment length exceeds 10,000</value>
		</comment>
		<group>8</group>
	  </attributes>
	</parameter>

	<!-- use PartTree? -->
	<parameter type = "Excl">
	  <name>usePartTree</name>
	  <attributes>
	    <prompt>Use the PartTree algorithm for tree building.</prompt>
		<vlist>
		  <value>0</value>
		  <label>no</label>		  
		  <value>1</value>
		  <label>yes</label> 
		</vlist>
		<vdef>
		  <value>0</value>
		</vdef>
		<comment>
			<value>Uses a fast tree-building method (PartTree, Katoh and Toh 2007). Recommended if a large number </value>
			<value>(&gt; ~10,000) of sequences are input.</value>
		</comment>
		<group>9</group>
	  </attributes>
	</parameter>

	<!-- PartTree distance metric -->
	<parameter type = "Excl">
	  <name>partTreeMetric</name>
	  <attributes>
	    <prompt>PartTree distance metric</prompt>
	    <precond>
		  <language>perl</language>
		  <code>$usePartTree eq "1"</code>
		</precond>
		<vlist>
		  <value>0</value>
		  <label>6-mer</label>

		  <value>1</value>
		  <label>DP</label>

		  <value>2</value>
		  <label>FASTA</label>
		</vlist>
	    <flist>
		  <value>0</value>
		  <code>" --parttree "</code>

		  <value>1</value>
		  <code>" --dpparttree "</code>

		  <value>2</value>
		  <code>" --fastaparttree "</code>
		</flist>
		<vdef>
		  <value>0</value>
		</vdef>
		<group>10</group>
		<comment>
			<value>* 6-mer: default distance metric</value>

			<value>* DP: distances are based on dynamic programming. Slightly more accurate and slower than using 6-mers.</value>

			<value>* FASTA: distances based on FASTA. Slightly more accurate and slower than using 6-mers.</value>
		</comment>
	  </attributes>
	</parameter>
	
	<!-- number of PartTree partitions -->
	<parameter type = "Integer">
	  <name>partTreePartitions</name>
	  <attributes>
	    <prompt>Number of partitions in the PartTree algorithm (--partsize)</prompt>
	    <precond>
		  <language>perl</language>
		  <code>$usePartTree eq "1"</code>
		</precond>
		<format>
		  <language>perl</language>
		  <code>(defined $value &amp;&amp; $value ne $vdef) ? " --partsize $value" : "" </code>
		</format>
		<vdef>
		  <value>50</value>
		</vdef>
		<group>11</group>
	  </attributes>
	</parameter>

	<!-- maximum size of alignment -->
				<parameter type = "Integer">
				  <name>maxAlignment</name>
				  <attributes>
					<prompt>Maximum alignment size (--groupsize)</prompt>
					<precond>
						<language>perl</language>
						<code>$usePartTree eq "1"</code>
					</precond>
					<format>
					  <language>perl</language>
					  <code>(defined $value) ? " --groupsize $value" : "" </code>
					</format>
					<comment>
						<value>Valid only with the --*parttree options. Default: the number of input sequences</value>
					</comment>
					<group>12</group>
				  </attributes>
				</parameter>
				
		  </parameters>
	  </paragraph>
  </parameter>
				
	  
  <parameter type = "Paragraph">
  <paragraph>
  <name>para_parameters</name>
  <prompt>Algorithm Parameters</prompt>
  <parameters>
 

<!--Nucleic Acid matrix selection -->

<parameter type = "Excl" ismandatory="1">
	  <name>dnaMatrix</name>
	  <attributes>
	    <prompt>Nucleic Acid matrix selection (--kimura)</prompt>
	    <precond>
			<language>perl</language>
			<code>$datatype eq "dna"</code>
		</precond>
		<vlist>
		  <value>200</value>
		  <label>200PAM/kappa=2</label>
		  
		  <value>20</value>
		  <label>20PAM / kappa=2</label>

		  <value>1</value>
		  <label>1PAM / kappa=2</label>
		</vlist>
		<flist>
			<value>200</value>
			<code>""</code>
			<value>20</value>
			<code>"--kimura 20"</code>
			<value>1</value>
			<code>"--kimura 1"</code>
		</flist>
		<format>
			<language>perl</language>
			<code>"--kimura $value"</code>
		</format>
		<vdef>
		  <value>200</value>
		</vdef>
	    <group>20</group>
	  </attributes>
	</parameter>

  	
<!-- AA matrix selection -->

	<parameter type = "Excl">
	  <name>aaMatrix</name>
	  <attributes>
	    <prompt>Amino Acid matrix selection</prompt>
	    <precond>
			<language>perl</language>
			<code>$datatype eq "protein"</code>
		</precond>
		<vlist>
		  <value>0</value>
		  <label>BLOSUM (Henikoff and Henikoff 1992)</label>
		  
		  <value>1</value>
		  <label>JTT PAM (Jones et al. 1992)</label>

		  <value>2</value>
		  <label>Transmembrane PAM (Jones et al. 1994)</label>

		  <value>3</value>
		  <label>User-defined</label>
		</vlist>
		<vdef>
		  <value>0</value>
		</vdef>
	    <group>20</group>
	  </attributes>
	</parameter>

	<!-- JTT PAM matrix -->
	<parameter type = "Integer">
	  <name>jtt</name>
	  <attributes>
	    <prompt>JTT PAM matrix (Jones et al. 1992) selection (--jtt)</prompt>
	    <precond>
		  <language>perl</language>
		  <code>(defined $aaMatrix &amp;&amp; $aaMatrix eq "1")</code>
		</precond>
		<format>
		  <language>perl</language>
		  <code>(defined $value) ? " --jtt $value" : "" </code>
		</format>
		<ctrls>
		  <ctrl>
		    <message>Please enter a value greater than 0.</message>
			<language>perl</language>
			<code>$value &lt; 1</code>
		  </ctrl>
		</ctrls>
		<comment>
			<value>Valid entries must be greater than 0.</value>
		</comment>
		<group>22</group>
	  </attributes>
	</parameter>
	
	<!-- TM PAM matrix -->
	<parameter type = "Integer">
	  <name>tm</name>
	  <attributes>
	    <prompt>Transmembrane PAM matrix (Jones et al. 1994) selection (--tm)</prompt>
	    <precond>
		  <language>perl</language>
		  <code>(defined $aaMatrix &amp;&amp; $aaMatrix eq "2")</code>
		</precond>
		<format>
		  <language>perl</language>
		  <code>(defined $value) ? " --tm $value" : "" </code>
		</format>
		<ctrls>
		  <ctrl>
		    <message>Please enter a value greater than 0.</message>
			<language>perl</language>
			<code>$value &lt; 1</code>
		  </ctrl>
		</ctrls>
		<comment>
			<value>Valid entries must be greater than 0.</value>
		</comment>
		<group>23</group>
	  </attributes>
	</parameter>

	<!-- user-defined matrix -->
    <parameter type = "InFile">
	  <name>userMatrix</name>
	  <attributes>
	    <prompt>User-defined amino acid scoring matrix in BLAST format (--aamatrix)</prompt>
	    <precond>
		  <language>perl</language>
		  <code>(defined $aaMatrix &amp;&amp; $aaMatrix eq "3")</code>		
		</precond>
		<filenames>userMatrixFile.blast</filenames>
		<format>
		  <language>perl</language>
		  <code>(defined $value) ? " --aamatrix userMatrixFile.blast" : "" </code>
		</format>
		<comment>
			<value>The format of matrixfile is the same to that of BLAST. Ignored when nucleotide sequences are input.</value>
		</comment>
	    <group>24</group>
	  </attributes>	  
	</parameter>
  
	<!-- gap open penalty for group-to-group alignment -->
	<parameter type = "Float">
	  <name>opPenaltyGroupToGroup</name>
	  <attributes>
	    <prompt>Gap opening penalty for group-to-group alignment (--op)</prompt>
		<format>
		  <language>perl</language>
		  <code>(defined $value &amp;&amp; $value ne $vdef) ? " --op $value" : ""</code>
		</format>
	    <vdef>
		  <value>1.53</value>
		</vdef>
		<group>13</group>
	  </attributes>
	</parameter>

<!-- offset value (gap extension penalty) for group-to-group alignment -->
	<parameter type = "Float">
		<name>extendPenaltyGroupToGroup</name>
		<attributes>
			<precond>
				<language>perl</language>
				<code>$configure_analysis</code>
			</precond>
			<prompt>Offset value (gap extension penalty) for group-to-group alignment (--ep)</prompt>
			<format>
				<language>perl</language>
				<code>(defined $value &amp;&amp; $value ne $vdef) ? " --ep $value" : ""</code>
			</format>
			<vdef>
				<value>0.0</value>
			</vdef>
			<group>14</group>
		</attributes>
	</parameter>

	<!-- Gap open penalty for pairwise alignment -->
	<parameter type = "Float">
		<name>opPenaltyPairwise</name>
		<attributes>
			<prompt>Gap open penalty for pairwise alignment (--lop)</prompt>
			<precond>
				<language>perl</language>
				<code>($distanceMetric eq "2") || ($distanceMetric eq "3")</code>
			</precond>
			<format>
				<language>perl</language>
				<code>(defined $value &amp;&amp; $value ne $vdef) ? " --lop $value" : ""</code>
			</format>
			<group>15</group>
			<vdef>
				<value>-2.00</value>
			</vdef>
			<comment>
<value>Valid when the --localpair or --genafpair distance metric options are selected.</value>
			</comment>
		</attributes>
	</parameter>

	<!-- Offset value for pairwise alignment -->
	<parameter type = "Float">
		<name>offsetValuePairwise</name>
		<attributes>
			<prompt>Offset value for pairwise alignment (--lep)</prompt>
			<precond>
				<language>perl</language>
				<code>($distanceMetric eq "2") || ($distanceMetric eq "3")</code>
			</precond>
			<format>
				<language>perl</language>
				<code>(defined $value &amp;&amp; $value ne $vdef) ? " --lep $value" : ""</code>
			</format>
			<vdef>
				<value>0.1</value>
			</vdef>
			<comment>
<value>Valid when the --localpair or --genafpair distance metric options are selected.</value>
			</comment>
			<group>16</group>
		</attributes>
	</parameter>

	<!-- Gap extension penalty for pairwise alignment -->
	<parameter issimple = "0" ismandatory = "0" type = "Float">
	  <name>extendPenaltyPairwise</name>
	  <attributes>
	    <prompt>Gap extension penalty for pairwise alignment (--lexp)</prompt>
	    <precond>
		  <language>perl</language>
		  <code>($distanceMetric eq "2") || ($distanceMetric eq "3")</code>
		</precond>
		<format>
		  <language>perl</language>
		  <code>(defined $value &amp;&amp; $value ne $vdef) ? " --lexp $value" : ""</code>
		</format>
	    <vdef>
		  <value>-0.1</value>
		</vdef>
		<comment>
			<value>Valid when the --localpair or --genafpair distance metric options are selected.</value>
		</comment>
		<group>17</group>
	  </attributes>
	</parameter>

	<!-- Gap open penalty for skipping the alignment -->
	<parameter type = "Float">
	  <name>opPenaltySkip</name>
	  <attributes>
	    <prompt>Gap open penalty for skipping the alignment (--LOP)</prompt>
	    <precond>
		  <language>perl</language>
		  <code>($distanceMetric eq "3")</code>
		</precond>
		<format>
		  <language>perl</language>
		  <code>(defined $value &amp;&amp; $value ne $vdef) ? " --LOP $value" : ""</code>
		</format>
	    <vdef>
		  <value>-6.00</value>
		</vdef>
		<comment>
			<value>Valid when the --genafpair distance metric option is selected.</value>
		</comment>
		<group>18</group>
	  </attributes>
	</parameter>

	<!-- Gap extension penalty for skipping the alignment -->
	<parameter type = "Float">
	  <name>extendPenaltySkip</name>
	  <attributes>
	    <prompt>Gap extension penalty for skipping the alignment (--LEXP)</prompt>
	    <precond>
		  <language>perl</language>
		  <code>($distanceMetric eq "3")</code>
		</precond>
		<format>
		  <language>perl</language>
		  <code>(defined $value &amp;&amp; $value ne $vdef) ? " --LEXP $value" : ""</code>
		</format>
	    <vdef>
		  <value>0.00</value>
		</vdef>
		<comment>
			<value>Valid when the --genafpair distance metric option is selected.</value>
		</comment>
		<group>19</group>
	  </attributes>
	</parameter>
	
	<!-- fmodel --> 
	<parameter type = "Excl" ismandatory="1">
	  <name>fmodel</name>
	  <attributes>
	    <prompt>Incorporate AA/nucleotide composition information into the scoring matrix (--fmodel)</prompt>
		<vlist>
		  <value>0</value>
		  <label>no</label>
		  
		  <value>1</value>
		  <label>yes</label>
		</vlist>
		<vdef>
		  <value>0</value>
		</vdef>
		<format>
		  <language>perl</language>
		  <code>(defined $value &amp;&amp; $value ne $vdef) ? " --fmodel" : ""</code>
		</format>
		<group>25</group>
	  </attributes>
	</parameter>
  </parameters>
  </paragraph>
  </parameter>

  
  <!-- Input/Output options paragraph -->
  <parameter type = "Paragraph">
  <paragraph>
  <name>para_io</name>
  <prompt>Input/Output Options</prompt>
  <parameters>
	<!-- output format -->
	<parameter issimple = "1" ismandatory = "0" type = "Excl">
	  <name>outputFormat</name>
	  <attributes>
	    <prompt>Output format</prompt>
		<vlist>
		  <value>0</value>
		  <label>FASTA</label>
		  
		  <value>1</value>
		  <label>ClustalW</label>
		</vlist>
		<vdef>
		  <value>0</value>
		</vdef>
		<format>
		  <language>perl</language>
		  <code>(defined $value &amp;&amp; $value ne $vdef) ? " --clustalout" : ""</code>
		</format>
		<group>26</group>
	  </attributes>
	</parameter>
	
	<!-- output order -->
	<parameter issimple = "0" ismandatory = "0" type = "Excl">
		<name>outputOrder</name>
		<attributes>
			<prompt>Output order</prompt>
			<precond>
				<language>perl</language>
				<code>$configure_analysis</code>
			</precond>
			<vlist>
				<value>0</value>
				<label>same as input</label>
				<value>1</value>
				<label>aligned</label>
			</vlist>
			<vdef>
				<value>1</value>
			</vdef>
			<format>
				<language>perl</language>
				<code>(defined $value &amp;&amp; $value ne $vdef) ? " --reorder" : ""</code>
			</format>
			<group>27</group>
		</attributes>
	</parameter>
	
	<!-- Output guide tree? -->
	<parameter ismandatory = "1" type = "Excl">
	  <name>outputGuideTree</name>
	  <attributes>
	    <prompt>Output guide tree (--treeout)</prompt>
		<vlist>
		  <value>0</value>
		  <label>no</label>
		  
		  <value>1</value>
		  <label>yes</label>
		</vlist>
		<vdef>
		  <value>0</value>
		</vdef>
		<format>
		  <language>perl</language>
		  <code>(defined $value &amp;&amp; $value ne $vdef) ? " --treeout" : ""</code>
		</format>
		<group>28</group>
	  </attributes>
	</parameter>

  </parameters>
  </paragraph>
  </parameter>
  </parameters>
</pise>


