<?xml version="1.0" encoding="ISO-8859-1" ?>
<!DOCTYPE pise SYSTEM "http://www.phylo.org/dev/rami/PARSER/pise.dtd">
<pise>

  <head>
    <title>Pars</title>
    <version>Phylip 3.66</version>
    <description>Discrete character parsimony</description>
        <authors>Felsenstein</authors>
    <reference>Felsenstein, J.  2007.  PHYLIP (Phylogeny Inference Package) version 3.66. Distributed by the author.  Department of Genetics, University of Washington, Seattle.</reference>
    <reference>Felsenstein, J.  1989.  PHYLIP -- Phylogeny Inference Package (Version 3.2). Cladistics  5: 164-166.</reference>
	<category>Phylogeny / Alignment</category>
<!--repaired obsolete link-->
    <doclink>http://evolution.genetics.washington.edu/phylip/doc/pars.html</doclink>
  </head>
  <command>pars</command>
  <parameters>
      <!--***********************************************************************************************************************************************************************************************
		 ***********************************************************************************************************************************************************************************************
	     **    Update by MMiller, 6_9_2008 to include all of the command line options except for the terminal type; cleaned up command line ordering                                  **
		 **                                                                                                                                                                                                                                          **
		************************************************************************************************************************************************************************************************
        ************************************************************************************************************************************************************************************************-->
    <!--Settings for Pars:
	**	U		Search for best tree?  							Yes											(group 1)
	**	S		Search option?  									More thorough search				(group 1)
	**	V		Number of trees to save?  						100											(group 1)
	**	J		Randomize input order of species?  		No. Use input order					(groups 19. 20)
	**	O		Outgroup root?  									No, use as outgroup species 1	(group 1)
	**	T		Use Threshold parsimony?  					No, use ordinary parsimony		(groups 2,3)
	**	W		Sites weighted?  									No											(group 1)
	**	M		Analyze multiple data sets?  					No											(groups 9,10)
	**	I		Input species interleaved?  						Yes											(group 1)
	**	0		Terminal type (IBM PC, ANSI, none)?  	ANSI										(group 0)
	**	1		Print out the data at start of run  				No											(group 1)
	**	2		Print indications of progress of run  			Yes  ****not supported by swanmi yet*** (group 1)
	**	3		Print out tree  										Yes											(group 1)
	**	4		Print out steps in each site  					No											(group 1)
	**	5		Print character at all nodes of tree  			No											(group 1)
	**	6		Write out trees onto tree file?  				Yes											(group 1)

  Y to accept these or type the letter for one to change

        -->
 <!--
	Here is how the groups are organized:
	 group -10 = input file ("ln -s infile.phylip infile; ")
	 group -9 = ln -s weights_file.param weights Weights Infile
	 group -1 = user tree file "ln -s tree_file.param intree; " : ""

	 group 0 = invoking command, calls for <params> file; terminal_type
			 contents of <params> file: where does interleaved go?
					 group 1 = More thorough search (S); Number of trees to save ( V); Sites Weighted (W); Search with User tree (default = no) (U); Outgroup root; Print out the data at start of run (1);
                                    Print out tree (3); Print out steps in each site (4) (corrected an error where the submitted value was 5 instead of 4. Print sequences at all nodes of tree (5); Write out
                                    trees onto tree file (6); 
					 group 2 = Threshold value (if use threshold parsimony); but adds nothing to command line.
					 group 3 = Threshold command string;
					 group 4 = Number of trees to save. added for Swami.
					 group 5 = Use Transversion parsimony (N)
					 group 6 = Coefficient of variation of substitution rate among sites (If gamma) [used to be group 51]
					 group 7 = Fraction of invariant sites (if Gamma) [used to be group 52]
					 group 9 = Multiple commands that dont get put in command line
					 group 10 = Multiple data sets (M); complete command line
					 group 19 = Jumble commands that doint get put in command file
					 group 20 = Jumble command (J) ($value &amp;&amp; ! $seqboot )? "j\\n$jumble_seed\\n$times\\n" : "" <
					 group 99 = Indent Tree; Confirm
 -->    
											<parameter iscommand="1" ishidden="1" type="String">
											<name>pars</name>
												<attributes>
													<format>
														<language>perl</language>
														<code> "pars &lt; params" </code>
													</format>
													<group>0</group>
												</attributes>
											</parameter>
											<!-- <parameter ismandatory="1" issimple="1"  type="InFile"> -->
											<parameter ismandatory="1" issimple="1" isinput="1" type="InFile">
											<name>infile</name>
												<attributes>
													<prompt>Input File</prompt>
													<format>
														<language>perl</language>
														<!-- <code>"ln -s $infile infile; "</code> -->
													<code>""</code>
													</format>
													<group>-10</group>
													<comment>
														<value>Example input file:</value>
														<value>     5    6</value>
														<value>Alpha     110110</value>
														<value>Beta      110000</value>
														<value>Gamma     100110</value>
														<value>Delta     001001</value>
														<value>Epsilon   001110</value>
														</comment>
		<!-- Added for Swami -->
														<filenames>infile</filenames>
	<!-- -->
												</attributes>
											</parameter>
											<parameter ismandatory="1" issimple="1" type="Excl">
											<name>interleavedinfile</name>
												<attributes>
													<prompt>Input sequences interleaved?</prompt>
													<vdef><value>yes</value></vdef>
													<vlist>
														<value>yes</value>
														<label>Yes</label>
														<value>no</value>
														<label>No</label>
													</vlist>
													<flist>
														<value>yes</value>
														<code>""</code>
														<value>no</value>
														<code>"I//n"</code>
													</flist>
													<group>1</group>
													<paramfile>params</paramfile>
												</attributes>
											</parameter>
<!--		*******  This can be implemented when Swami is ready for it ********
										 <parameter ismandatory="1" issimple="1" type="Switch">
										 <name>printintermediatedata</name>
											 <attributes>
												 <prompt>Print indications of progress of run  (2)</prompt>
												 <format>
													 <language>perl</language>
													 <code>($value)? "2\\n" : ""</code>
												 </format>
												 <vdef><value>0</value></vdef>
												 <group>1</group>
												 <paramfile>params</paramfile>
											 </attributes>
								 </parameter> -->
		<parameter type="Paragraph">
			<paragraph>
			<name>pars_opt</name>
			<prompt>Pars options</prompt>
				<parameters>
										<parameter type="Excl">
										<name>search_opt</name>
											<attributes>
												<prompt>Search option (S)</prompt>
												<vdef>
													<value>0</value>
												</vdef>
												<flist>
													<value>0</value>
													<code>""</code>
													<value>1</value>
													<code>"S\\nY\\n"</code>
													<value>2</value>
													<code>"S\\nN\\n"</code>
												</flist>
												<vlist>
													<value>0</value>
													<label>More thorough search</label>
													<value>1</value>
													<label>Rearrange on one best tree</label>
													<value>2</value>
													<label>Less thorough</label>
												</vlist>
													<group>1</group>
													<paramfile>params</paramfile>
												 <comment>
<value> PARS is a general parsimony program which carries out the Wagner parsimony method with multiple states. Wagner parsimony allows changes among all states. The criterion is to find the tree which requires the  minimum number of changes. The Wagner method was originated by Eck and Dayhoff (1966) and by Kluge and Farris (1969). Here are its assumptions:</value>
<value>  1. Ancestral states are unknown.</value>
<value>   2. Different characters evolve independently.</value>
<value>   3. Different lineages evolve independently.</value>
<value>  4. Changes to all other states are equally probable (Wagner).</value>
<value>  5. These changes are a priori improbable over the evolutionary time
       spans involved in the differentiation of the group in question.</value>
<value>  6. Other kinds of evolutionary event such as retention of
       polymorphism are far less probable than these state changes.</value>
<value>  7. Rates of evolution in different lineages are sufficiently low that two changes in a long segment of the tree are far less probable than one change in a short segment.</value>
<value>PARS can handle both bifurcating and multifurcating trees. In doing its search for most parsimonious trees, it adds species not only by
   creating new forks in the middle of existing branches, but it also tries putting them at the end of new branches which are added to
   existing forks. Thus it searches among both bifurcating and multifurcating trees. If a branch in a tree does not have any
   characters which might change in that branch in the most parsimonious tree, it does not save that tree. Thus in any tree that results, a
   branch exists only if some character has a most parsimonious reconstruction that would involve change in that branch.</value>
<value>It also saves a number of trees tied for best (you can alter the number it saves using the V option in the menu). When rearranging trees, it tries rearrangements of all of the saved trees. This makes the algorithm slower than earlier programs such as Mix.</value>
												</comment>
											</attributes>
										</parameter>	  
										<parameter type="Integer">
										<name>save_trees</name>
											<attributes>
												<prompt> Number of trees to save? (V)</prompt>
												<paramfile>params</paramfile>
												<vdef>
													<value>100</value>
												</vdef>
												<format>
													<language>perl</language>
													<code>(defined $value &amp;&amp; $value != $vdef) ? "V\\n$value\\n" : ""</code>
												</format>
												<group>1</group>
											</attributes>
										</parameter>
	  <!-- Removed Swami: doesn't make sense with pars
										<parameter type="Switch">
										<name>use_ancestral_state</name>
											<attributes>
												<prompt>Use ancestral states  (A)</prompt>
												<format>
													<language>perl</language>
													<code>($value)? "A\\n" : ""</code>
												</format>
												<group>1</group>
												<paramfile>params</paramfile>
												<comment>
													<value>The A (Ancestral states) option. This indicates that we are specifying the ancestral states for each character. In the menu the ancestors (A) option must be selected.</value>
													<value>An ancestral states file is uploaded to the program, whose default name = ancestors. It contains a line or lines giving the ancestral states for each character. These may be 0, 1 or ?, the latter indicating that the ancestral state is unknown.</value>
<value>An example is:</value>
<value></value>
<value>001??11</value>
<value></value>
<value>The ancestor information can be continued to a new line and can have blanks between any of the characters in the same way that species character data can.
.</value>
												</comment>
											</attributes>
										</parameter>
	  -->
				</parameters>
			</paragraph>
		</parameter>
		<parameter type="Paragraph">
			<paragraph>
			<name>jumble_opt</name>
			<prompt>Randomize options</prompt>
				<parameters>
										<parameter type="Switch">
										<name>jumble</name>
											<attributes>
												<prompt>Randomize (jumble) input order (J)</prompt>
												<format>
													<language>perl</language>
													<code>($value)? "j\\n$jumble_seed\\n$times\\n" : "" </code>
												</format>
												<vdef><value>0</value></vdef>
												<group>20</group>
												<paramfile>params</paramfile>
												<comment>
													<value>The J (Jumble) option. In most tree construction programs, the search of different trees depends on the order of input of species. The J option tells the program to use a random number generator to choose the input order of species. If you select Jumble, you must provide a "seed" for the random number generator. The seed should be an integer between 1 and be of form 4n+1. Each different seed leads to a different sequence of addition of species. By simply changing the random number seed and re-running the programs one can look for other, and better trees. </value>
													<value>
Using the Jumble option, you must specify how many times you want to restart the process. The value 10 causes ten different orders of species to be used in constructing the trees, and the results printed out will reflect this entire search process (that is, the best trees found among all 10 runs will be printed out, not the best trees from each individual run).</value>
												</comment>
											</attributes>
										</parameter>
										<parameter ismandatory="1" type="Integer">
										<name>jumble_seed</name>
											<attributes>
												<prompt>Random number seed (must be odd)</prompt>
													<format>
														<language>perl</language>
														<code>""</code>
													</format>
													<group>19</group>
													<ctrls>
														<ctrl>
															<message>Random number seed must be odd</message>
															<language>perl</language>
															<code>$value &lt;= 0 || (($value % 2) == 0)</code>
														</ctrl>
													</ctrls>
													<precond>
													<language>perl</language>
													<code>$jumble</code>
													</precond>
											</attributes>
										</parameter>
										<parameter type="Integer">
										<name>times</name>
											<attributes>
												<prompt>Number of times to jumble</prompt>
												<format>
													<language>perl</language>
													<code>""</code>
												</format>
												<vdef><value>1</value></vdef>
												<group>19</group>
											</attributes>
										</parameter>
				</parameters>
			</paragraph>
		</parameter>
		<parameter type="Paragraph">
			<paragraph>
			<name>weight_opt</name>
			<prompt>Weight options</prompt>
				<parameters> 
										<parameter type="Switch">
										<name>weights</name>
											<attributes>
												<prompt>Weighted sites (W)</prompt>
												<format>
													<language>perl</language>
													<code>(defined $value &amp;&amp; $value) ? "W\\n" : ""</code>
												</format>
												<group>1</group>
												<paramfile>params</paramfile>
												<comment>
													<value>The W (Weights) option. This signals the program that, in addition to the data set, you want to read in a series of weights that tell how many times each character is to be counted. If the weight for a character is zero (0) then that character is in effect to be omitted when the tree is evaluated. If it is (1) the character is to be counted once. A value greater than one means the character is counted as if it were present that many times, so that a weight of 4 means that the character is counted 4 times. The values 0-9 give weights 0 through 9, and the values A-Z give weights 10 through 35.</value>
													<value>The weights are used to analyze subsets of the characters, and also can be used for resampling of the data as in bootstrap and jackknife resampling. For those programs that allow weights to be greater than 1, they can also be used to emphasize information from some characters more strongly than others. Of course, you must have some rationale for doing this. </value>
													<value>The weights are provided as a sequence of digits. Thus they might be</value> 
													<value></value>
													<value>10011111100010100011110001100</value>
													<value>The weights are to be provided in an input file whose default name = weights. The weights in it are a simple string of digits. Blanks in the weightfile are skipped over and ignored, and the weights can continue to a new line.</value>
												</comment>
											</attributes>
										</parameter>
										<parameter type="InFile">
										<name>weight_file</name>
											<attributes>
												<prompt>Weight file</prompt>
												<format>
													<language>perl</language>
													<!-- <code>($value)? "ln -s $weights_file weights; " : ""</code> -->
													<code>($value)? "ln -s weights_file.param weights; " : ""</code>
												</format>
												<group>-9</group>
												<precond>
													<language>perl</language>
													<code>$weights</code>
												</precond>
<!-- Added for Swami-->
												<filenames>weights_file.param</filenames>
<!-- -->
											</attributes>
										</parameter>
						</parameters>
			</paragraph>
		</parameter>
		<parameter type="Paragraph">
			<paragraph>
			<name>user_tree_opt</name>
			<prompt>User tree options</prompt>
						<parameters>
										<parameter type="Switch">
										<name>user_tree</name>
											<attributes>
												<prompt>Search with User tree (default = no) (U)</prompt>
												<format>
													<language>perl</language>
													<code>($value)? "U\\n" : "" </code>
												</format>
												<vdef><value>0</value></vdef>
												<group>1</group>
												<comment>
													<value>The U (User tree) option. This option toggles between the default setting, which allows the program to
		 search for the best tree, and the User tree setting, which reads a tree or trees ("user trees") from an input
		 tree file. The input tree file default name is intree.</value>
		<value>((Alligator,Bear),((Cow,(Dog,Elephant)),Ferret));</value>
		<value>((Alligator,Bear),(((Cow,Dog),Elephant),Ferret));</value>
		<value>((Alligator,Bear),((Cow,Dog),(Elephant,Ferret)));</value>
		
		<value>Multifurcating trees are permitted. You must then enter the number of trees submitted. In using the
		 user tree option, check the pattern of parentheses carefully. The programs do not always detect whether
		 the tree makes sense, and if it does not there will probably be a crash (hopefully, but not inevitably,
		 with an error message indicating the nature of the problem). Trees written out by programs are typically
		 in the proper form.</value>
												</comment>
												<ctrls>
													<ctrl>
														<message>you cannot randomize (jumble) your dataset and give a user tree at the same time</message>
														<language>perl</language>
														<code>$user_tree &amp;&amp; $jumble</code>
													</ctrl>
												</ctrls>
												<paramfile>params</paramfile>
											</attributes>
										</parameter>
										<parameter type="InFile">
										<name>tree_file</name>
											<attributes>
												<prompt>Please Specify the Starting Tree</prompt>
												<format>
												<language>perl</language>
<!-- CHANGED FOR SWAMI <code>($value)? "cat $tree_file &gt;&gt; infile; " : ""</code> -->
												<code>"" </code>
												</format>
<!-- Aded Swami -->
												<filenames>intree</filenames> 
<!-- -->
												<group>-1</group>
<!--						wrong comment removed...					<comment>
<value>Give a tree whenever the infile does not already 
		  </format>contain the tree.</value>
												</comment>-->
												<precond>
												<language>perl</language>
												<code>$user_tree</code>
												</precond>
											</attributes>
										</parameter>
<!--	  
	  <parameter ismandatory="1" type="Integer">
	    <name>tree_nb</name>
	    <attributes>
	      <prompt>How many tree(s) in the User Tree file</prompt>
	      <format>
		<language>perl</language>
		<code>"echo $value &gt;&gt; intree; "</code>
	      </format>
	      <vdef><value>1</value></vdef>
	      <group>-2</group>
	      <comment>
		<value>Give this information whenever the infile does not already contain the tree.</value>
	      </comment>
	      <precond>
		<language>perl</language>
		<code>$user_tree</code>
	      </precond>
	    </attributes>
	  </parameter>
-->	  
						</parameters>
			</paragraph>
		</parameter>
<!-- ********************Bogus incorrect multipe datasets option****************** -->
<!--		<parameter type="Paragraph">
			<paragraph>
			<name>bootstrap</name>
			<prompt>Multiple Dataset Options</prompt>
						<parameters>
										<parameter type="Switch">
										<name>multiple_dataset</name>
											<attributes>
	      <prompt>Analyze multiple data sets (M)</prompt>
	      <format>
		<language>perl</language>
		<code>($value)? "M\\nD\\n$datasets_nb\\n$multi_seed\\n$multi_times\\n" : ""</code>
	      </format>
	      <vdef><value>0</value></vdef>
	      <group>10</group>
	      <paramfile>params</paramfile>
-->
<!-- **************corrected multiple data sets option*********** -->
		<parameter type="Paragraph">
			<paragraph>
			<name>multidata</name>
			<prompt>Multiple Datasets: Can be generated as Weights or Data using Seqboot. Please use Consense to calculate a Consensus tree</prompt>
						<parameters>
								<parameter type="Switch">
								<name>multiple_dataset</name>
									<attributes>
										<prompt>Analyze multiple data sets (M)</prompt>
										<format>
<!--modified to accomodate the weights or data prompt -->
											<language>perl</language>
											<code>($value) ? "M\\n$weightsordata\\n$datasets_nb\\n$multi_seed\\n$multi_times\\n" : ""</code>
										</format>
										<vdef><value>0</value></vdef>
										<group>10</group>
										<paramfile>params</paramfile>
										<comment>
<value>The M (Multiple data sets) option. The main use of this option is to allow bootstrapping. Using the program Seqboot, one can take any DNA, protein, restriction sites, gene frequency or binary character data set and make multiple data sets by bootstrapping. Trees can be produced for all of these using the M option. They will be written on the tree output file if that option is left in force. The program Consense can be used with that multi-tree output file as its input file. The result is a majority rule consensus tree that can be used to make confidence intervals. The present version of the package allows bootstrapping with the use of Seqboot and Consense and the M option.</value>

<value>Here is a (very small) sample input file with two five-species data sets:</value>
<value>&#xA0;&#xA0;&#xA0;&#xA0;5&#xA0;&#xA0;&#xA0;6</value>
<value>Alpha&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;CCACCA</value>
<value>Beta&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;CCAAAA</value>
<value>Gamma&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;CAACCA</value>
<value>Delta&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;AACAAC</value>
<value>Epsilon&#xA0;&#xA0;&#xA0;AACCCA</value>
<value>&#xA0;&#xA0;&#xA0;&#xA0;5&#xA0;&#xA0;&#xA0;6</value>
<value>Alpha&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;CCACCA</value>
<value>Beta&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;CCAAAA</value>
<value>Gamma&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;CAACCA</value>
<value>Delta&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;AACAAC</value>
<value>Epsilon&#xA0;&#xA0;&#xA0;AACCCA</value>

<value>Pars can take multiple weights instead of multiple data sets. It can do bootstrapping by reading in one data set, together with a file of weights that show how the characters (or sites) are reweighted in each bootstrap sample. Thus a site that is omitted in a bootstrap sample has effectively been given weight 0, while a site that has been duplicated has effectively been given weight 2. Seqboot has a menu selection to produce the file of weights information automatically, instead of producing a file of multiple data sets. It can be renamed and used as the input weights file. </value>

<value>The main use of this option will be to allow all of the methods in these programs to be bootstrapped. Using the program Seqboot one can take any DNA, protein, restriction sites, gene frequency or binary character data set and make multiple data sets by bootstrapping. Trees can be produced for all of these using the M option. They will be written on the tree output file if that option is left in force. Then the program Consense can be used with that tree file as its input file. The result is a majority rule consensus tree which can be used to make confidence intervals. The present version of the package allows, with the use of Seqboot and Consense and the M option, bootstrapping of many of the methods in the package. </value>
<value>
Programs Dnaml, Dnapars and Pars can also take multiple weights instead of multiple data sets. They can then do bootstrapping by reading in one data set, together with a file of weights that show how the characters (or sites) are reweighted in each bootstrap sample. Thus a site that is omitted in a bootstrap sample has effectively been given weight 0, while a site that has been duplicated has effectively been given weight 2. Seqboot has a menu selection to produce the file of weights information automatically, instead of producing a file of multiple data sets. It can be renamed and used as the input weights file.</value>
										</comment>
									</attributes>
								</parameter>
								<parameter ismandatory="1" type="Excl">
								 <name>weightsordata</name>
									 <attributes>
										 <prompt>Multiple data sets or multiple weights? (type D or W)</prompt>
										 <precond>
											 <language>perl</language>
											 <code>$multiple_dataset</code>
										 </precond>
										 <format>
											 <language>perl</language>
											 <code>""</code>
										 </format>
										 <vdef><value>data</value></vdef>
										 <vlist>
												 <value>data</value>
												 <label>Data</label>
												 <value>weights</value>
												 <label>Weights</label>
										 </vlist>
										 <flist>
										 		 <value>data</value>
												 <code>"D//n"</code>
												 <value>weights</value>
												 <code>"W//n"</code>
										 </flist>
<!-- this is labelled group 9, but it is delivered in group 10 as part of the /m command -->
										 <group>9</group>
									 </attributes>
								 </parameter>
								<parameter ismandatory="1" type="Integer">
								<name>datasets_nb</name>
									<attributes>
										<prompt>How many data sets?</prompt>
										<format>
											<language>perl</language>
											<code>""</code>
										</format>
										<group>9</group>
										<ctrls>
											<ctrl>
												<message>enter a value &gt; 0 ; there must be no more than 1000 datasets for this server</message>
												<language>perl</language>
												<code>($value &gt; 1000) || ($value &lt; 0)</code>
											</ctrl>
										</ctrls>
										<precond>
										<language>perl</language>
										<code>$multiple_dataset</code>
										</precond>
									</attributes>
								</parameter>
								<parameter ismandatory="1" type="Integer">
								<name>multi_seed</name>
									<attributes>
										<prompt>Random number seed (must be odd)</prompt>
										<format>
										<language>perl</language>
											<code>""</code>
											</format>
										<group>9</group>
										<ctrls>
											<ctrl>
												<message>Random number seed must be odd</message>
												<language>perl</language>
												<code>$value &lt;= 0 || (($value % 2) == 0)</code>
											</ctrl>
										</ctrls>
										<precond>
											<language>perl</language>
											<code>$multiple_dataset</code>
										</precond>
									</attributes>
								</parameter>
								<parameter type="Integer">
								<name>multi_times</name>
									<attributes>
										<prompt>Number of times to jumble</prompt>
										<format>
											<language>perl</language>
											<code>""</code>
										</format>
										<vdef><value>1</value></vdef>
										<group>9</group>
									</attributes>
								</parameter>
<!--                     Not supported in SWAMI                -->
<!-- <parameter type="Switch">
	    <name>consense</name>
	    <attributes>
	      <prompt>Compute a consensus tree</prompt>
	      <format>
		<language>perl</language>
		<code>($value) ? "; cp -f infile infile.mix; cp -f outtree outtree.mix; cp -f outfile outfile.mix; rm -f outfile; mv -f outtree intree ; consense &lt; consense.params; cp -f outtree outtree.consense; cp -f outfile outfile.consense; mv -f outtree.mix outtree; mv -f infile.mix infile; mv -f outfile.mix outfile" : ""</code>
	      </format>
	      <vdef><value>0</value></vdef>
	      <group>10</group>
	      <precond>
		<language>perl</language>
		<code>$multiple_dataset &amp;&amp; $print_treefile</code>
	      </precond>
	    </attributes>
	  </parameter>
	  -->
						</parameters>
			</paragraph>
		</parameter>
		<parameter type="Paragraph">
			<paragraph>
			<name>output</name>
			<prompt>Output options</prompt>
						<parameters>
								<parameter type="Switch">
								<name>print_tree</name>
									<attributes>
										<prompt>Print out tree (3)</prompt>
										<format>
											<language>perl</language>
											<code>($value)? "" : "3\\n"</code>
										</format>
										<vdef><value>1</value></vdef>
										<group>1</group>
										<comment>
<value>Tells the program to print a semi-graphical picture of the tree in the outfile.</value>
										</comment>
										<paramfile>params</paramfile>
									</attributes>
								</parameter>
								<parameter type="Switch">
								<name>print_step</name>
									<attributes>
										<prompt>Print out steps in each character (4)</prompt>
										<format>
											<language>perl</language>
											<code>($value)? "4\\n" : ""</code>
										</format>
										<vdef><value>0</value></vdef>
										<group>1</group>
										<paramfile>params</paramfile>
									</attributes>
								</parameter>
								<parameter type="Switch">
								<name>print_states</name>
									<attributes>
										<prompt>Print states at all nodes of tree (5)</prompt>
										<format>
											<language>perl</language>
											<code>($value)? "5\\n" : ""</code>
										</format>
										<vdef><value>0</value></vdef>
										<group>1</group>
										<paramfile>params</paramfile>
									</attributes>
								</parameter>
								<parameter type="Switch">
								<name>print_treefile</name>
									<attributes>
										<prompt>Write out trees onto tree file (6)</prompt>
										<format>
											<language>perl</language>
											<code>($value) ? "" : "6\\n"</code>
										</format>
										<vdef><value>1</value></vdef>
										<group>1</group>
										<comment>
<value>Tells the program to save the tree in a treefile (a standard representation of trees where the tree is specified by a nested pairs of parentheses, enclosing names and separated by commas).</value>
										</comment>
										<paramfile>params</paramfile>
									</attributes>
								</parameter>
								<parameter type="Switch">
								<name>printdata</name>
									<attributes>
										<prompt>Print out the data at start of run (1)</prompt>
										<format>
											<language>perl</language>
											<code>($value)? "1\\n" : ""</code>
										</format>
										<vdef><value>0</value></vdef>
										<group>1</group>
										<paramfile>params</paramfile>
									</attributes>
								</parameter>
								<parameter type="Switch">
								<name>indent_tree</name>
									<attributes>
										<prompt>Indent treefile</prompt>
										<format>
											<language>perl</language>
											<code>($value)? " &amp;&amp; indenttree -o outtree.indent outtree" : "" </code>
										</format>
										<vdef><value>0</value></vdef>
										<group>99</group>
									</attributes>
								</parameter>
					</parameters>
			</paragraph>
		</parameter>
		<parameter type="Paragraph">
			<paragraph>
			<name>parcimony_opt</name>
			<prompt>Parsimony options</prompt>
					<parameters>
								<parameter type="Switch">
								<name>use_threshold</name>
									<attributes>
										<prompt>Use Threshold parsimony (T)</prompt>
										<format>
											<language>perl</language>
											<code>($value)? "T\\n$threshold\\n" : ""</code>
										</format>
										<vdef><value>0</value></vdef>
										<group>3</group>
										<paramfile>params</paramfile>
									</attributes>
								</parameter>
								<parameter ismandatory="1" type="Integer">
								<name>threshold</name>
									<attributes>
										<prompt>Threshold value (if use threshold parsimony)</prompt>
										<format>
											<language>perl</language>
											<code>"" </code>
										</format>
										<group>2</group>
										<precond>
											<language>perl</language>
											<code>$use_threshold</code>
										</precond>
										<ctrls>
											<ctrl>
												<message>You must enter a numeric value, greater than 1</message>
												<language>perl</language>
												<code>($threshold !~ /^\d+(\.\d+)?$/) || ($threshold &lt; 1)</code>
											</ctrl>
										</ctrls>
										<paramfile>params</paramfile>
										<comment>
<value>The T (Threshold) option. This sets a threshold for the parsimony programs such that if the number of
steps counted in a character is higher than the threshold, it will be taken to be the threshold value rather
than the actual number of steps. The default is a threshold so high that it will never be surpassed (in which
case the steps will simply be counted). If you select the T option, you must also supply a threshold. This
will be a positive real number greater than 1. The T option is an important and underutilized one: it is, for
example, the only way in the Phylip package to do a compatibility analysis when there are missing data. It is
a method of de-weighting characters that evolve rapidly.</value>
										</comment>
									</attributes>
								</parameter>
					</parameters>
			</paragraph>
		</parameter>
		<parameter type="Paragraph">
			<paragraph>
			<name>other_options</name>
			<prompt>Other options</prompt>
					<parameters>
								<parameter type="Integer">
								<name>outgroup</name>
									<attributes>
										<prompt>Outgroup root (default, use as outgroup species 1) (O)</prompt>
										<format>
											<language>perl</language>
											<code>($value &amp;&amp; $value != $vdef)? "o\\n$value\\n" : "" </code>
										</format>
										<vdef><value>1</value></vdef>
										<group>1</group>
										<paramfile>params</paramfile>
										<comment>
<value> The O (Outgroup) option is valid only if the tree is not rooted by the Ancestral States option.
It specifies which species is on the line leading to the root of the tree. For example, if the outgroup is
a species "Mouse" then the root of the tree will be placed in the middle of the branch connected to
this species, with Mouse branching off on one side of the root and the lineage leading to the rest of the
tree on the other. When selected, the number of the outgroup must be identified (the species are 
numbered in the order they occur in the input file). Entering 6 causes the sixth species in the data set
to be taken as the outgroup (the sixth in the first data set if there are multiple data sets).Outgroup
rooting will not be attempted if the data have already established a root for the tree, such as from a 
user-defined tree. The inferred tree as printed out is still an unrooted tree, though the outgroup is
connected to the bottommost node so that it is easy to visually convert the tree into rooted form.</value>
										</comment>
										<comment><value>&#169;Copyright 1980-2007. University of Washington.</value></comment>
										<ctrls>
											<ctrl>
												<message>Please enter a value greater than 0</message>
												<language>perl</language>
												<code>$value &lt; 1</code>
											</ctrl>
										</ctrls>
									</attributes>
								</parameter>
					</parameters>
			</paragraph>
		</parameter>
								<parameter type="Results">
								<name>outfile</name>
									<attributes>
										<filenames>outfile</filenames>
									</attributes>
								</parameter>
								<parameter type="Results">
								<name>treefile</name>
									<attributes>
										<precond>
											<language>perl</language>
											<code>$print_treefile</code>
										</precond>
										<filenames>outtree</filenames>
										<pipe>
											<pipetype>phylip_tree</pipetype>
											<language>perl</language>
											<code>1</code>
										</pipe>
									</attributes>
								</parameter>
								<parameter type="Results">
								<name>indented_treefile</name>
									<attributes>
										<precond>
											<language>perl</language>
											<code>$print_treefile &amp;&amp; $indent_tree</code>
										</precond>
										<filenames>outtree.indent</filenames>
									</attributes>
								</parameter>
								<parameter type="Results">
								<name>params</name>
									<attributes>
										<filenames>params</filenames>
									</attributes>
								</parameter>
								<parameter ishidden="1" type="String">
								<name>confirm</name>
									<attributes>
										<format>
											<language>perl</language>
											<code>"y\\n"</code>
										</format>
<!--<group>1000</group>-->
										<group>99</group>
										<paramfile>params</paramfile>
									</attributes>
								</parameter>
								<parameter ishidden="1" type="String">
								<name>terminal_type</name>
									<attributes>
										<format>
											<language>perl</language>
											<code>"0\\n"</code>
										</format>
	<!--<group>-1</group>-->
										<group>0</group>
										<paramfile>params</paramfile>
									</attributes>
								</parameter>
								<parameter type="Results">
								<name>tmp_params</name>
									<attributes>
										<filenames>*.params</filenames>
									</attributes>
								</parameter>
<!--                   not supported in Swami                 -->
<!-- <parameter ishidden="1" type="String">
      <name>consense_confirm</name>
      <attributes>
        <format>
          <language>perl</language>
          <code>"Y\\n"</code>
        </format>
		<group>1000</group>
        <group>99</group>
        <precond>
          <language>perl</language>
          <code>$consense</code>
        </precond>
        <paramfile>consense.params</paramfile>
      </attributes>
    </parameter>
    <parameter ishidden="1" type="String">
      <name>consense_terminal_type</name>
      <attributes>
        <format>
          <language>perl</language>
          <code>"T\\n"</code>
        </format>
		<group>-2</group>
        <group>0</group>
        <precond>
          <language>perl</language>
          <code>$consense</code>
        </precond>
        <paramfile>consense.params</paramfile>
      </attributes>
    </parameter>

    <parameter type="Results">
      <name>consense_outfile</name>
      <attributes>
        <precond>
          <language>perl</language>
          <code>$consense</code>
        </precond>
        <filenames>outfile.consense</filenames>
      </attributes>
    </parameter>
    
    <parameter type="Results">
      <name>consense_treefile</name>
      <attributes>
        <precond>
        <language>perl</language>
          <code>$consense</code>
        </precond>
        <filenames>outtree.consense</filenames>
      </attributes>
    </parameter>
-->  
  </parameters>
</pise>
