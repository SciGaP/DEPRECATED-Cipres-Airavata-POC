<?xml version="1.0" encoding="ISO-8859-1"?>
<!DOCTYPE pise SYSTEM "http://www.phylo.org/dev/rami/PARSER/pise.dtd" [
<!ENTITY runtime SYSTEM "http://www.phylo.org/dev/rami/XMLDIR/triton_run_time.xml">
]>

<pise>
	<head>
		<title>FSA</title>
		<version>1.15.0</version>
		<description>Distance-based alignment of DNA, RNA and proteins.</description>
		<authors>Robert K. Bradley, Adam Roberts, Michael Smoot, Sudeep Jukevar, Jaeyoung Do, Colin Dewey, Ian Holmes, Lior Pachter</authors>
		<reference>Bradley RK, Roberts A, Smoot M, Juvekar S, Do J, et al. 2009 Fast Statistical Alignment. PLoS Comput Biol 5(5): e1000392. doi:10.1371/journal.pcbi.1000392</reference>
		<category>Phylogeny / Alignment</category>
		<doclink>http://orangutan.math.berkeley.edu/fsa/</doclink>
	</head>
	
	<command>fsa</command>
<!--

This interface was created around 8/17/2009 by mamiller 

########################################################################################
NOTE!! in each command example below, double hyphens were replaced with hyphen asterisk -*, because 
they are illegal in this XML document. 
########################################################################################

fsa - Distance-based alignment of DNA, RNA and proteins.
Usage: fsa [options] <sequence file(s)>

Input sequence file(s) must be in FASTA format.

FSA attempts to automatically figure out appropriate settings;
you can override its automated choices with the above options.

Please contact the FSA team at fsa@math.berkeley.edu with any questions or comments.

Strategy for grouping:
Group 0, fsa invocation

Group 98, infile argument
Group 99, outfile argument

Others as below:

Command-line options (righthandmost options take precedence)
*****************************************************************************
-h,-help,-*help                			display this message
-v,-*version                    			display version

Group 10 Logging options
*******************
-*log <string>                 			turn on diagnostic logging (-loghelp shows syntax)
-*logfile <file>                 			log to file
-*logcopy <file>              			log to file and standard error
-*logtime                        			timestamp standard error (logfile stamped automatically)
-*logxml                        			(default) add XML timestamps (-*nologxml to disable)
-*logerr                        				log on standard error (default)

Group 15 Output options
*****************
-*stockholm								output Stockholm alignments (default is multi-FASTA format)
-*gui                             			record alignment & statistical model for interactive Java GUI
-*write-params                 			write learned emission distributions (substitution matrices) to disk
-*write-posteriors              			write learned pairwise posterior alignment probability matrices to disk

Group 20 Parallelization options
*************************
(Parallelization not available; please see the manual for more information.)

Group 25 Database options
********************
(Database not available; please see the manual for more information.)

Group 30 Pair HMM model options
*****************************
-*nucprot                       			align input nucleotide sequences (must all be nucleotide) in protein space
-*indel2                          			(default) use two sets of indel states in Pair HMM (use -*noindel2 to use 1 set only)
-*gapopen1 <real>           			initial gap-open probability (for set 1 of indel states)
-*gapextend1 <real>        			initial gap-extend probability (for set 1 of indel states)
-*gapopen2 <real>           			initial gap-open probability (for set 2 of indel states)
-*gapextend2 <real>         			initial gap-extend probability (for set 2 of indel states)
-*model <integer>          			initial substitution model: 0 = Jukes-Cantor, 1 = Tamura-Nei / BLOSUM62-like (proteins) (default is 1)
-*time <real>                   			Jukes-Cantor/Tamura-Nei evolutionary time parameter (default is 0.4)
-*alphar <real>                 			Tamura-Nei rate alpha_R (transition: purine) (default is 1.3)
-*alphay <real>               			Tamura-Nei rate alpha_Y (transition: pyrimidine) (default is 1.3)
-*beta <real>                  			Tamura-Nei rate beta (transversion) (default is 1)
-*load-probs <string>     				load pairwise posterior probabilities from a file rather than performing inference with Pair HMM

Group 35 Parameter estimation options
**********************************
-*learngap                     			estimate indel probabilities for each pair of sequences (-*nolearngap to disable)
-*learnemit-bypair           			(default for DNA and RNA) estimate emission probabilities for each pair of sequences (-*nolearnemit-bypair to disable)
-*learnemit-all                			(default for proteins) estimate emission probabilities averaged over all sequences (-*nolearnemit-all to disable)
-*nolearn                     				disable ALL parameter learning (use ProbCons defaults)
-*regularize                  				(default) regularize learned emission and gap probabilities with Dirichlet prior (-*noregularize to disable)
-*regularization-gapscale <real>  scaling factor for transition prior
-*regularization-emitscale <real> scaling factor for emission Dirichlet prior
-*mininc <real>               			minimum fractional increase in log-likelihood per round of EM (default is 0.1)
-*maxrounds <integer>           	maximum number of iterations of EM (default is 3)
-*mingapdata <integer>           	minimum amount of sequence data (# of aligned pairs of characters) for training gap probs
-*minemitdata <integer>        		minimum amount of sequence data (# of aligned pairs of characters) for training emission probs

Group 40 Multiple alignment options: sequence annealing
*******************************************************
-*refinement <integer>          		number of iterative refinement steps (default is unlimited; 0 for none)
-*maxsn                         			maximum sensitivity (instead of highest accuracy)
-*gapfactor <real>              		gap factor; 0 for highest sensitivity (the internal effective minimum is 0.01); >1 for higher specificity (default is 1)
-*dynamicweights               		(default) enable dynamic edge re-weighting (-*nodynamicweights to disable)
-*treeweights <string>        		weights for sequence pairs based on a tree
-*require-homology            			require that there be some detectable homology between all input sequences

Group 45 Alignment speedup options: many sequences
*****************************************************
-*fast                            			fast alignment: use 5 * Erdos-Renyi threshold percent of sequence pairs for alignment and 2 * for learning
-*refalign                        			alignment to a reference sequence only (reference must be first sequence in file)
-*mst-min <integer>               	build -*mst-min minimum spanning trees on input sequences for pairwise comparisons (default is 3)
-*mst-max <integer>               	build -*mst-max maximum spanning trees on input sequences for pairwise comparisons (default is 0)
-*mst-palm <integer>              	build -*mst-palm minimum spanning palm trees on input sequences for pairwise comparisons (default is 0)
-*degree <integer>                		use -*degree number of pairwise comparisons between closest sequences (default is 0)
-*kmer <integer>                  		length of k-mers to use when determining sequence similarity
-*alignment-fraction <real>       	randomized fraction of all (n choose 2) pairs of sequences to consider during alignment inference (default is 1)
-*alignment-number <integer>    	total number of (randomized) pairs of sequences to consider during alignment inference

Group 50 Alignment speedup options: long sequences (MUMmer)
****************************************************************
-*anchored                    			use anchoring (-*noanchored to disable)
-*translated                      			perform anchoring in protein space
-*minlen <integer>                		minimum length of exact matches for anchoring
-*maxjoinlen <integer>            	maximum ungapped separation of parallel adjacent anchors to join (default is 2)
-*hardmasked                      		leave hardmasked sequence >10 nt unaligned instead of randomizing it (default for long DNA)

Group 55 Alignment speedup options: long sequences (exonerate)
*****************************************************************
-*exonerate                       		call exonerate to get anchors (implies -*anchored)
-*minscore <integer>              	minimum score of alignments found by exonerate (default is 100)
-*softmasked                      		input sequences are softmasked

Group 60 Alignment speedup options: long sequences (Mercator)
********************************************************************
-*mercator <string>               		input Mercator constraints

#################################################################################

Options below are not implemented 



Group 65 Memory savings
************************
-*maxram <integer>                	maximum RAM to use (in megabytes) (default is 25710)
-*bandwidth <integer>             	banding (default is no banding)
-*minprob <real>                  		minimum posterior probability to store (default is 0.01)

##################################################################################
-->
<!-- revisions suggested  by the authors -->

	<parameters>
		&runtime; 

		<!-- command name -->
		<parameter ishidden="1" type="String">
			<name>fsa_invoke</name>
			<attributes>
				<format>
					<language>perl</language>
					<code>"fsa"</code>
				</format>
				<group>0</group>
			</attributes>
		</parameter>

		<!-- required input file -->

		<parameter ismandatory="1" issimple="1" isinput="1" type="InFile">
			<name>infile</name>
			<attributes>
				<prompt>Sequences in FASTA Format</prompt>
				<format>
					<language>perl</language>
					<code>"infile"</code>
				</format>
				<group>98</group>
				<filenames>infile</filenames>
			</attributes>
		</parameter>
		
<!-- 
*******************************************************************************************************
Group 10 Logging options
*******************************************************************************************************
-*log <string>                 			turn on diagnostic logging (-loghelp shows syntax)
-*logfile <file>                 			log to file
-*logcopy <file>              			log to file and standard error
-*logtime                        			timestamp standard error (logfile stamped automatically)
-*logxml                        			(default) add XML timestamps (-*nologxml to disable)
-*logerr                        				log on standard error (default) 

*******************************************************************************************************
-->
<!-- HIDDEN PARAMS -->
<!-- set the logfile type -->
		<parameter type="String" ishidden="1">
			<name>logfile</name>
			<attributes>
				<format>
					<language>perl</language>
					<code>" --logfile logfile.txt"</code>
				</format>
				<filenames>logfile.txt</filenames>
				<group>10</group>
			</attributes>
		</parameter> 

<!-- next two hidden params set the output file extension based on the selected file type -->
		<parameter type="String" ishidden="1">
			<name>output_command</name>
			<attributes>
			<precond>
				<language>perl</language>
				<code>!$output_stockholm</code>
			</precond>
				<format>
					<language>perl</language>
					<code> " &gt; outfile.afa "</code>
				</format>
				<group>99</group>
			</attributes>
		</parameter>
		
		<parameter type="String" ishidden="1">
			<name>output_stockholm_file</name>
			<attributes>
				<precond>
					<language>perl</language>
					<code>$output_stockholm</code>
				</precond>
				<format>
					<language>perl</language>
					<code> " &gt; outfile.stk "</code>
				</format>
				<group>99</group>
			</attributes>
		</parameter>
		
<!-- VISIBLE PARAMS -->
<!-- SIMPLE VISIBLE PARAMS -->

<!-- this parmater does not create a command line entry, but it control some options in the interface -->

				<parameter type="Excl" ismandatory="1" issimple="1">
					<name>data_type</name>
					<attributes>
						<prompt>Data Type</prompt>
						<vlist>
							<value>protein</value>
							<label>Protein</label>
							<value>na</value>
							<label>Nucleic Acid</label>
						</vlist>
						<vdef>
							<value>na</value>
						</vdef>
					</attributes>
				</parameter>
<!-- -*anchored  use anchoring (-*noanchored to disable) >>
>> Exposing the -*anchored and -*noanchored options sounds good, although it would be great if the "default" for these and many other options were to not use the 
>> corresponding command-line flag at all so that FSA can choose appropriately unless the user requests a specific option.  Is this workable?

>>> It's tough to say what the best default behavior is, because FSA chooses default settings based on a cursory examination of the sequences in the input file.  For example, if the input sequences are DNA and have an average length < 500 bp, then -*noanchored is the default; if they have an average length >= 500 bp, then -*anchored is the default.
>>>
 -->
				<parameter type="Switch" issimple="1">
					<name>use_anchors</name>
					<attributes>
						<prompt>Use Anchoring (--anchored) </prompt>
						<vdef>
							<value>0</value>
						</vdef>
						<format>
							<language>perl</language>
							<code>$value ? " --anchored" : ""</code>
						</format>
						<precond>
							<language>perl</language>
							<code>!$no_anchors</code>
						</precond>
						<group>50</group>
						<comment>
<value>Anchoring is turned on when nucleotide sequences are longer than 200 nucleotides. This option forces it to turn on when the sequence length is less than 200. To use translated anchoring in protein space, use the option --translated. The minimum length of anchors, controlled with --minlen, is 10 for nucleotide sequence and 7 for amino acid sequence (for anchoring protein sequences or translated anchoringof nu­cleotide sequence).</value>
						</comment>
					</attributes>
				</parameter>
				
				<parameter type="Switch" issimple="1">
					<name>no_anchors</name>
					<attributes>
						<prompt>DIsable Anchoring (--noanchored) </prompt>
						<vdef>
							<value>0</value>
						</vdef>
						<precond>
							<language>perl</language>
							<code>!$use_anchors</code>
						</precond>
						<format>
							<language>perl</language>
							<code>$value ? " --noanchored" : ""</code>
						</format>
						<group>50</group>
						<comment>
<value>Long sequence alignment speedup options: Anchoring can be turned off with --noanchored. Anchoring is turned on when nucleotide sequences are longer than 200 nucleotides. Translated anchoring in protein space is invoked with --translated. The minimum length of anchors, controlled with --minlen, is 10 for nucleotide sequence and 7 for amino acid sequence (for anchoring protein sequences or translated anchoringof nu­cleotide sequence).</value>
						</comment>
					</attributes>
				</parameter>
				
				
<!-- From the program Author: - I suggest putting the following options under "Simple parameters":
		 -*anchored/-*noanchored
		-*nucprot
		-*translated
		-*maxsn
		-*fast
		-*stockholm

- Can you also move the following options to the Simple Parameters section?
    -*exonerate
    -*softmasked
-->
				<parameter type="Switch" issimple="1">
					<name>align_in_protspace</name>
					<attributes>
						<prompt>Align input nucleotide sequences (must all be nucleotide) in protein space (--nucprot)</prompt>
						<precond>
							<language>perl</language>
							<code>$data_type eq "na"</code>
						</precond>
						<vdef>
							<value>0</value>
						</vdef>
						<format>
							<language>perl</language>
							<code> ($value)?" --nucprot":""</code>
						</format>
						<group>30</group>
						<comment>
<value>Using this option, FSA aligns coding nucleotide sequences by first translating the sequences, aligning the resulting protein sequences, and then displaying the corresponding nucleotide-level alignment. All sequences must be nucleotide.</value>
						</comment>
					</attributes>
				</parameter>
				
				<!-- -*translated perform anchoring in protein space -->				
				<parameter type="Switch" issimple="1">
					<name>prot_anchor</name>
					<attributes>
						<prompt>Perform Anchoring in Protein Space (--translated) </prompt>
						<precond>
							<language>perl</language>
							<code>$data_type eq "na" &amp; !$no_anchors</code>
						</precond>
						<vdef>
							<value>0</value>
						</vdef>
						<format>
							<language>perl</language>
							<code>$value ? " --translated" : ""</code>
						</format>
						<group>50</group>
					</attributes>
				</parameter>
				
<!-- -*maxsn 	maximum sensitivity (instead of highest accuracy) -->			
				<parameter type="Switch" issimple="1">
					<name>sensitivity_max</name>
					<attributes>
						<prompt>Maximize sensitivity instead of accuracy (--maxsn)</prompt>
						<vdef>
							<value>0</value>
						</vdef> 
						<format>
							<language>perl</language>
							<code>$value ? " --maxsn" : ""</code>
						</format>
						<group>40</group>
						<comment>
<value>FSA can be run in maximum-sensitivity mode with --maxsn. For users wanting finer-grained control over the sensitivity/specificity trade-off, the gap factor can be specified with --gapfactor (the gap factor is explained in the main text).The default is --gapfactor1, which corresponds to the case where sequence annealing stops aligning characters when the probability that a character is aligned is equal to the probability that it is unaligned (aligned to a gap). The maximum-sensitivity mode is equivalent to using --gapfactor 0; values > 1 give higher specificity. Dynamic weighting can be disabled with --nodynamicweights, although this is generally not recommended (see the main text for a description of weighting).</value>
						</comment>
					</attributes>
				</parameter>
				
<!-- -*fast fast alignment: use 5 * Erdos-Renyi threshold percent of sequence pairs for alignment and 2 * for learning  -->
<!-- > What will the behavior of, e.g., leaving the -*fast box unchecked be?  Will that 
> trigger the -*nofast option, or will it just not trigger the -*fast option?

Mark Miller wrote:
> That will mean the -*fast flag is not put in the command line, so it is the latter: it will just not trigger the -*fast option.
> -->
<!-- Can you add the following note to the -*fast option?  " (recommended for aligning >50 sequences)"-->
				<parameter type="Switch" issimple="1">
					<name>fast_alignment</name>
					<attributes>
						<prompt>Run Fast Alignment (--fast) (recommended for aligning >50 sequences)</prompt>
						<vdef>
							<value>0</value>
						</vdef>
						<format>
							<language>perl</language>
							<code>$value ? " --fast" : ""</code>
						</format>
						<group>45</group>
						<comment>
<value>The --fast option is recommended for aligning >50 sequences. It uses presets which are appropriate for aligning many sequences. It sets --alignment-fraction to the Erdenyi threshold probability scaled by a factor of 5 and sets --learning-fraction to the threshold scaled by a factor of 2. As suggested by the results in the main text, the heuristics invoked by --fast are effective for difficult alignment problems.</value>
						</comment>
					</attributes>
				</parameter>
				
<!-- -*exonerate call exonerate to get anchors (implies -*anchored) -->
				<parameter type="Switch" issimple="1">
					<name>call_exonerate</name>
					<attributes>
						<prompt>Run exonerate (--exonerate)</prompt>
						<precond>
							<language>perl</language>
							<code>!$no_anchors &amp; !$align_in_protspace</code>
						</precond>
						<vdef>
							<value>0</value>
						</vdef>
						<format>
							<language>perl</language>
							<code>$value ? " --exonerate" : ""</code>
						</format>
						<group>55</group>
						<comment>
<value>FSA can call the exonerate program to obtain anchors between distant species, where there are few exact matches. Use --exonerate to trigger anchor-finding with exonerate as well as MUMmer. By default FSA only uses candidate alignments with scores _ 100; change this with --minscore. Use --softmasked to tell exonerate that the input sequences are softmasked. </value>
						</comment>
					</attributes>
				</parameter>
				
<!-- -*softmasked input sequences are softmasked -->
				<parameter type="Switch" issimple="1">
					<name>make_softmasked</name>
					<attributes>
						<prompt>Softmask input sequences (--softmasked)</prompt>
						<precond>
							<language>perl</language>
							<code>!$no_anchors</code>
						</precond>
						<vdef>
							<value>0</value>
						</vdef>
						<format>
							<language>perl</language>
							<code>$value ? " --softmasked" : ""</code>
						</format>
						<group>55</group>
					</attributes>
				</parameter>
				
<!-- -*fstockholm: output stockholm format -->
				<parameter type="Switch" issimple="1">
							<name>output_stockholm</name>
							<attributes>
								<prompt>Output Stockholm Alignments (--stockholm)</prompt>
								<vdef>
									<value>0</value>
								</vdef>
									<format>
										<language>perl</language>
										<code> ($value)?" --stockholm":""</code>
									</format>
								<group>15</group>
								<comment>
<value>Use this option to produce Stockholm-format alignments. FSA_s Stockholm-format alignments are annotated with per-column accuracy information as well as a single accuracy estimate for the entire alignment. </value>
								</comment>
							</attributes>
				</parameter>

<!-- ADVANCED VISIBLE PARAMS -->				

<!--				
*******************************************************************************************************
Group 15 Output options

*******************************************************************************************************
-*stockholm								output Stockholm alignments (default is multi-FASTA format)
-*gui                             			record alignment and statistical model for interactive Java GUI
-*write-params                 			write learned emission distributions (substitution matrices) to disk
-*write-posteriors              			write learned pairwise posterior alignment probability matrices to disk

*******************************************************************************************************
-->



		
<!-- Group 30 Pair HMM model options
*****************************
-*nucprot                       			align input nucleotide sequences (must all be nucleotide) in protein space
-*indel2                          			(default) use two sets of indel states in Pair HMM (use -*noindel2 to use 1 set only)
-*gapopen1 <real>           			initial gap-open probability (for set 1 of indel states)
-*gapextend1 <real>        			initial gap-extend probability (for set 1 of indel states)
-*gapopen2 <real>           			initial gap-open probability (for set 2 of indel states)
-*gapextend2 <real>         			initial gap-extend probability (for set 2 of indel states)

-*model <integer>          			initial substitution model: 0 = Jukes-Cantor, 1 = Tamura-Nei / BLOSUM62-like (proteins) (default is 1)
-*time <real>                   			Jukes-Cantor/Tamura-Nei evolutionary time parameter (default is 0.4)
-*alphar <real>                 			Tamura-Nei rate alpha_R (transition: purine) (default is 1.3)
-*alphay <real>               			Tamura-Nei rate alpha_Y (transition: pyrimidine) (default is 1.3)
-*beta <real>                  			Tamura-Nei rate beta (transversion) (default is 1)
-*load-probs <string>     				load pairwise posterior probabilities from a file rather than performing inference with Pair HMM -->

<!--         there is no information at all about how these are set          -->

<parameter type="Paragraph">
	<paragraph>
		<name>HMM_opts</name>
		<prompt>Pair HMM model options (click and read this)</prompt>
		<comment>
<value>FSA has a significant amount of data-handling "intelligence." Many settings are chosen automatically based on the data set provided. The advanced paramters section allows users to override default settings with a command-line option.  This interface is designed to make it possible to take advantage of this feature. Users can supply a value to be passed to FSA in place of its default behavior. If no values are entered, FSA uses its own logic to make an appropriate choice automatically.</value>
		</comment>
			<parameters>
<!-- - I recommend that no options in the Pair HMM Model Options have a default value, with the exception of the radio buttons. -->			
<!-- -*model <integer>      initial substitution model: 0 = Jukes-Cantor, 1 = Tamura-Nei / BLOSUM62-like (proteins) (default is 1)-->
<!-->>>>>>     1. for the -model option:
>>>>>>
>>>>>> a.        are alpha_R; alpha_Y; time; and beta parameters relevant for both 
>>>>>> nucleotide models?
>>>>>>
>>>>>> Time is relevant for both; alpha_{R,Y} are only relevant for the 
>>>>>> Tamura-Nei model.  However, I expect that very few users will want to adjust these parameters.
>>>>>>
>>>>>> b.       are none of these parameters  relevant for protein models?
>>>>>>
>>>>>> They're not relevant.
>>>>>>
>>>>>> c.        are none of these parameters  relevant if -nucprot is selected?
>>>>>>
>>>>>> They're not relevant.
>>>>>>
-->
				<parameter type="Excl" ismandatory="1">
					<name>subst_model</name>
					<attributes>
						<prompt>Initial substitution model (--model)</prompt>
						<precond>
							<language>perl</language>
							<code>$data_type eq "na"</code>
						</precond>
						<vlist>
							<value>1</value>
							<label>Tamura-Nei</label>
							<value>0</value>
							<label>Jukes-Cantor</label>
						</vlist>
						<vdef>
							<value>1</value>
						</vdef>
						<format>
							<language>perl</language>
							<code>"--model $value"</code>
						</format>
						<comment>
<value>The substitution model for nucleotide or amino acid sequence can be chosen with the --model option. For DNA or RNA, the model can be either the Jukes-Cantor orTamura-Nei. These models are further parameterized with the --time, --alphar, --alphay and --beta options. Protein sequences use the BLOSUM 62 substitution matrix, which is transformed such that the equilibrium distribution is equal to the empirical distribution over amino acids in the input sequences.</value>
						</comment>
						<group>30</group>
					</attributes>
				</parameter>

<!-- -*time <real> 	Jukes-Cantor/Tamura-Nei evolutionary time parameter (default is 0.4) -->
				<parameter type="Float">
					<name>evtime_param</name>
					<attributes>
						<prompt>Evolutionary time parameter (--time)</prompt>
						<format>
							<language>perl</language>
							<code>defined $value ? " --time $value":""</code>
						</format>
						<group>30</group>
						<precond>
							<language>perl</language>
							<code>!$upload_probfile</code>
						</precond>
					</attributes>
				</parameter>
				
				<parameter type="Excl" ismandatory="1">
					<name>num_indel_states</name>
					<attributes>
						<prompt>How many indel states in Pair HMM? (--noindel2)</prompt>
						<precond>
							<language>perl</language>
							<code>!$upload_probfile</code>
						</precond>
						<vdef>
							<value>indel2</value>
						</vdef>
						<vlist>
							<value>indel2</value>
							<label>2</label>
							<value>noindel2</value>
							<label>1</label>
						</vlist>
						<format>
							<language>perl</language>
							<code>" --$value"</code>
						</format>
						<group>30</group>
						<comment>
<value>The option of one indel state replaces the default 5-statePair HMM with a three-state HMM, which has only one set of Insert (I) and Delete (D) states.</value>
						</comment>
					</attributes>
				</parameter>
				
<!-- -*alphar <real>    Tamura-Nei rate alpha_R (transition: purine) (default is 1.3) -->
				<parameter type="Float">
					<name>alpha_R</name>
					<attributes>
						<prompt>Tamura-Nei rate alpha_R (transition: purine; --alphar)</prompt>
						<format>
							<language>perl</language>
							<code>defined $value ? " --alphar $value":""</code>
						</format>
						<precond>
							<language>perl</language>
							<code>$data_type eq "na" &amp; $subst_model eq "1" &amp; !$align_in_protspace &amp; !$upload_probfile</code>
						</precond>
						<group>30</group>
					</attributes>
				</parameter>

<!-- -*alphay <real>     Tamura-Nei rate alpha_Y (transition: pyrimidine) (default is 1.3) -->			
				<parameter type="Float">
					<name>alpha_Y</name>
					<attributes>
						<prompt>Tamura-Nei rate alpha_Y (transition: pyrimidine; --alphay)</prompt>
						<format>
							<language>perl</language>
							<code>defined $value ? " --alphay $value":""</code>
						</format>
						<precond>
							<language>perl</language>
							<code>$data_type eq "na" &amp; $subst_model eq "1" &amp; !$align_in_protspace &amp; !$upload_probfile</code>
						</precond>
						<group>30</group>
					</attributes>
				</parameter>
				
<!-- -*beta <real>         Tamura-Nei rate beta (transversion) (default is 1) -->				
				<parameter type="Float">
					<name>TN_beta</name>
					<attributes>
						<prompt>Tamura-Nei rate beta (transversion; --beta) </prompt>
						<format>
							<language>perl</language>
							<code>defined $value ? " --beta $value":""</code>
						</format>
						<precond>
							<language>perl</language>
							<code>$data_type eq "na" &amp; $subst_model eq "1" &amp; !$align_in_protspace &amp; !$upload_probfile</code>
						</precond>
						<group>30</group>
					</attributes>
				</parameter>

<!-- -*gapopen1 <real>   initial gap-open probability (for set 1 of indel states) -->

				<parameter type="Float">
					<name>open_set1_of_indelstates</name>
					<attributes>
						<prompt>Initial gap-open probability for set 1 of indel states ( --gapopen1)</prompt>
						<precond>
							<language>perl</language>
							<code>!$upload_probfile</code>
						</precond>
						<format>
							<language>perl</language>
							<code>defined $value ? " --gapopen1 $value":""</code>
						</format>
						<group>30</group>
						<comment>
							<value>
For protein and DNA, gap_open1 default = 0.02 for three state model (if --noindel2 is requested); default = 0.012 for five state model</value>
						</comment>
					</attributes>
				</parameter> 

<!-- -*gapextend1 <real>	initial gap-extend probability (for set 1 of indel states) -->
<!-- >>>>> e.       is it reasonable to expose the gapopen and gapextend parameters so 
>>>>>> users can set their values? is there a default value each should be given?
>>>>>>
>>>>>> Exposing these is reasonable, although I imagine that few users will 
>>>>>> adjust their values.  The default values vary depending upon whether 
>>>>>> the input sequence is nucleotide or protein, and whether -*noindel2 
>>>>>> is chosen or not.  Here are the default values:
>>>>>>
>>>>>> if DNA {
>>>>>>     if -*noindel2 is requested {
>>>>>>        gap_open1 = 0.02;
>>>>>>        gap_extend1 = 0.3;
>>>>>>        gap_open2 = 0;
>>>>>>        gap_extend2 = 0;
>>>>>>     } else {
>>>>>>        gap_open1 = 0.012;
>>>>>>        gap_extend1 = 0.4;
>>>>>>        gap_open2 = 0.008;
>>>>>>        gap_extend2 = 0.9;
>>>>>>      }
>>>>>>    }
>>>>>>
>>>>>> if protein {
>>>>>>     if -*noindel2 is requested {
>>>>>>        gap_open1 = 0.02;
>>>>>>        gap_extend1 = 0.794;
>>>>>>        gap_open2 = 0;
>>>>>>        gap_extend2 = 0;
>>>>>>      } else {
>>>>>>        gap_open1 = 0.012;
>>>>>>        gap_extend1 = 0.397;
>>>>>>        gap_open2 = 0.008;
>>>>>>        gap_extend2 = 0.899;
>>>>>>      }
>>>>>>    }
>>>>>>
-->
				<parameter type="Float">
					<name>gap_set1_of_indelstates</name>
					<attributes>
						<prompt>Initial gap-extend probability for set 1 of indel states ( --gapextend1)</prompt>
						<precond>
							<language>perl</language>
							<code>!$upload_probfile</code>
						</precond>
						<format>
							<language>perl</language>
							<code>defined $value ? " --gapextend1 $value" : ""</code>
						</format>
						<group>30</group>
						<comment>
<value>For DNA, gap_extend1, defalt value  = 0.4 for five state model (default condition). For a three state DNA/RNA model ( if --noindel2 is requested) default = 0.3. For protein gap_extend1 default = 0.397 for a five state model (default condition); for a three state model ( if --noindel2 is requested) default = 0.794. </value>
						</comment>
					</attributes>
				</parameter>

<!-- -*gapopen2 <real>   initial gap-open probability (for set 2 of indel states) -->
<!-- >>> d.       are the parameters gapopen2 and gapextend2 irrelevant if -*noindel2 is 
>>>>>> selected?
>>>>>>
>>>>>> They are irrelevant if -*noindel2 is chosen.
-->
				<parameter type="Float">
					<name>open_set2_of_indelstates</name>
					<attributes>
						<prompt>Initial gap-open probability for set 2 of indel states (--gapopen2)</prompt>
						<format>
							<language>perl</language>
							<code>defined $value ? " --gapopen2 $value" :""</code>
						</format>
						<group>30</group>
						<precond>
							<language>perl</language>
							<code>$num_indel_states eq "indel2" &amp; !$upload_probfile</code>
						</precond>
						<comment>
						<value>This parameter is only relevant for five state models. For DNA and protein, gap_open2 has a default value  = 0.008. </value>
						</comment>
					</attributes>
				</parameter> 

<!-- -*gapextend2 <real>  initial gap-extend probability (for set 2 of indel states) -->
<!-- >>> d.       are the parameters gapopen2 and gapextend2 irrelevant if -*noindel2 is 
>>>>>> selected?
>>>>>>
>>>>>> They are irrelevant if -*noindel2 is chosen.
-->
				<parameter type="Float">
					<name>gap_set2_of_indelstates</name>
					<attributes>
						<prompt>Initial gap-extend probability for set 2 of indel states (--gapextend2)</prompt>
						<format>
							<language>perl</language>
							<code>defined $value ? " --gapextend2 $value":""</code>
						</format>
						<precond>
							<language>perl</language>
							<code>$num_indel_states eq "indel2" &amp; !$upload_probfile</code>
						</precond>
						<group>30</group>
						<comment>
							<value>This parameter is only relevant for five state models.  For DNA, default gap_extend2 = 0.9; for protein, default gap_extend2 = 0.899;
   </value>
						</comment>
					</attributes>
				</parameter>

<!-- -*load-probs <string>  load pairwise posterior probabilities from a file rather than performing inference with Pair HMM -->
<!-- >>> f.         would the posterior probabilities file upload make other options in  this section irrelevant?
>>>>>>
>>>>>> Yes.
>>>>>> g.        is there any information on the format and nature of the posterior probabilities file?
>>>>>>
>>>>>> I have attached a sample posterior probabilities file to this email (tRNA.aln1.fasta.probs).  However, this is an option which only very 
>>>>>> advanced users will probably be interested in, and I think that it would be perfectly reasonable to not allow it for your webserver if 
>>>>>> you would like to avoid the difficulties associated with validating files, etc.
>>>>>> -->
				<parameter type="Switch">
					<name>upload_probfile</name>
					<attributes>
						<prompt>Upload a posterior probabilities file?</prompt>
						<vdef>
							<value>0</value>
						</vdef>
					</attributes>
				</parameter>
				
				<parameter type="InFile">
					<name>posterior_probfile</name>
					<attributes>
						<prompt>Upload pairwise posterior probabilities file (--load-probs)</prompt>
						<precond>
							<language>perl</language>
							<code>$upload_probfile</code>
						</precond>
						<filenames>postprobs.txt</filenames>
						<format>
							<language>perl</language>
							<code>" --load-probs postprobs.txt" : ""</code>
						</format>
						<group>30</group>
						<comment>
<value>This option allows you to upload pairwise posterior probabilities from a file rather than performing inference with Pair HMM. Selecting this option disables 
the other options in  this section irrelevant. A sample posterior probabilities files can be found at http://www.phylo.org/tools/tool_tests/fsa_postprobs.txt</value>
						</comment>
					</attributes>
				</parameter>

			</parameters>
		</paragraph>
	</parameter>
	
	
		<parameter type="Paragraph">
		<paragraph>
			<name>paramest_opts</name>
			<prompt>Parameter estimation options</prompt>
			<parameters>

<!-- Group 35 Parameter estimation options
**********************************
 -->		
 <!-- >>>>>> h.       are the learnemitby pair/learngapbypair and learnemitall/learngapall 
>>>>>> options mutually exclusive?
>>>>>>
>>>>>> I have changed the options within the past few months slightly, so 
>>>>>> that there is now only an option -*learngap.  It takes the place of 
>>>>>> the older option -*learngap-bypair, and -*learngap-all has been 
>>>>>> deprecated.  The options -*learnemit-bypair and -*learnemit-all are mutually exclusive, as you guessed.
>>>>>>
>>>>>> i.         is the configuration of these parameters different for proteins vs 
>>>>>> nucleic acids?
>>>>>>
>>>>>> The default settings are different-*by default protein triggers 
>>>>>> -*learnemit-all and nucleotide triggers -*learnemit-bypair-*but 
>>>>>> either option can be used with either type of sequence.
>>>>>> -->

 <!-- -*learngap  estimate indel probabilities for each pair of sequences (-*nolearngap to disable) -->	
				<parameter type="Switch">
					<name>learn_gap</name>
					<attributes>
						<prompt>Estimate indel probabilities for each pair of sequences (--learngap)</prompt>
						<format>
							<language>perl</language>
							<code>$value ? " --learngap" : ""</code>
						</format>
						<vdef>
							<value>1</value>
						</vdef>
						<precond>
							<language>perl</language>
							<code>!$no_learn &amp; !$nolearn_gap</code>
						</precond>
						<group>35</group>
						<comment>
<value>FSA query-specific learning uses unsupervised EM to learn appropriate parameters for each pair of input sequences. The --learngap, --learnemit-bypair and --learnemit-all options control whether FSA estimates pairwise transition and emission probabilities.</value>
						</comment>
					</attributes>
				</parameter>
				

<!-- -*learngap  estimate indel probabilities for each pair of sequences (-*nolearngap to disable) -->	
				<parameter type="Switch">
					<name>nolearn_gap</name>
					<attributes>
						<prompt>Disable estimation of indel probabilities for each pair of sequences (--nolearngap)</prompt>
						<format>
							<language>perl</language>
							<code>$value ? " --nolearngap" : ""</code>
						</format>
						<vdef>
							<value>0</value>
						</vdef>
						<precond>
							<language>perl</language>
							<code>!$no_learn &amp; !$learn_gap</code>
						</precond>
						<group>35</group>
						<comment>
<value>FSA query-specific learning uses unsupervised EM to learn appropriate parameters for each pair of input sequences. The --learngap, --learnemit-bypair and --learnemit-all options control whether FSA estimates pairwise transition and emission probabilities. This option allows the user to prevent calculation of a separate gap distribution for each pair of sequences.</value>
						</comment>
					</attributes>
				</parameter> 
							
<!-- -*learnemit-all (default for DNA and RNA) estimate emission probabilities for each pair of sequences (-*nolearnemit-bypair to disable) if -*learnemit-all is set then FSA learns a single emission distribution for all sequences (default for amino acid sequence). -->
<!-- >>>>>> j.         for example, if -*learnemit-all is default for proteins, is  -learnemitbypair turned off?
>>>>>>
>>>>>> That's correct.
>>>>>>-->					
				<parameter type="Switch">
					<name>learnemit_all</name>
					<attributes>
						<prompt>Estimate emission probabilities over all nuceleic acid sequences (--learnemit-all)</prompt>
						<format>
							<language>perl</language>
							<code>$value ? " --learnemit-all" : ""</code>
						</format>
						<vdef>
							<value>0</value>
						</vdef>
						<precond>
							<language>perl</language>
							<code>!$no_learn &amp; $data_type eq "na" &amp; !$not_learnemitbypair</code>
						</precond> 
						<group>35</group>
						<comment>
<value>The learnemit-all option estimates emission probabilities over all sequences, instead of by pairs. This option is active by default for proteins. If you select this for DNA/RNA, it will override the default, which is to estimate emission probabilities for each pair of sequences.</value>
						</comment>
					</attributes>
				</parameter>
				
<!-- -*learnemit-all  (default for proteins) estimate emission probabilities averaged over all sequences (-*nolearnemit-all to disable) -->					
				<parameter type="Switch">
					<name>not_learnemitbypair</name>
					<attributes>
						<prompt>Disable estimation of emission probabilities by pairs of nuceleic acid sequences ( --nolearnemit-bypair)</prompt>
							<format>
							<language>perl</language>
							<code>$value ? " --nolearnemit-bypair" : ""</code>
						</format> 
						<vdef>
							<value>0</value>
						</vdef>
						<precond>
							<language>perl</language>
							<code>!$no_learn &amp; $data_type eq "na" &amp; !$learnemit_all</code>
						</precond> 
						<group>35</group>
						<comment>
<value>Use this switch to disable estimation of emission probabilities for each pair of DNA/RNA sequences.</value>
						</comment>
					</attributes>
				</parameter> 
				
<!-- -*learnemit-bypair (default for DNA and RNA) estimate emission probabilities for each pair of sequences (-*nolearnemit-bypair to disable) if -*learnemit-all is set then FSA learns a single emission distribution for all sequences (default for amino acid sequence). -->					
				<parameter type="Switch">
					<name>learnemit_pair</name>
					<attributes>
						<prompt>Estimate emission probabilities for each pair of amino acid sequences (--learnemit-bypair)</prompt>
						<format>
							<language>perl</language>
							<code>$value ? "--learnemit-bypair":""</code>
						</format> 
						<vdef>
							<value>0</value>
						</vdef>
						<precond>
							<language>perl</language>
							<code>!$no_learn &amp; $data_type eq "protein" &amp; !$not_learnemitall</code>
						</precond>
						<group>35</group>
						<comment>
<value>The learnemit-bypair option estimates emission probabilities for each pair of sequences, instead of over all sequences. This option is active by default for DNA and RNA. If you select this for proteins, it will override the default, which is to estimate emission probabilities over all sequences.</value>
						</comment>
					</attributes>
				</parameter>
								
<!-- -*learnemit-all  (default for proteins) estimate emission probabilities averaged over all sequences (-*nolearnemit-all to disable) -->					
				<parameter type="Switch">
					<name>not_learnemitall</name>
					<attributes>
						<prompt>Disable estimation of a single emission probability for all amino acid sequences (--nolearnemit-all)</prompt>
						<format>
							<language>perl</language>
							<code>$value ? " --nolearnemit-all" : ""</code>
						</format>
						<vdef>
							<value>0</value>
						</vdef>
						<precond>
							<language>perl</language>
							<code>!$no_learn &amp; $data_type eq "protein" &amp; !$learnemit_pair</code>
						</precond>
						<group>35</group>
						<comment>
<value>-Use this switch to disable learning a single emission distribution for all amino acid sequences</value>
						</comment>
					</attributes>
				</parameter> 

<!-- -*nolearn disable ALL parameter learning (use ProbCons defaults) -->					
				<parameter type="Switch">
					<name>no_learn</name>
					<attributes>
						<prompt>Disable ALL parameter learning (--nolearn)</prompt>
						<vdef>
							<value>0</value>
						</vdef>
						<format>
							<language>perl</language>
							<code>$value ? " --nolearn" : ""</code>
						</format>
						<group>35</group>
						<comment>
							<value>The --nolearn options disables all learning, and default ProbCons parameters are used</value>
						</comment>
					</attributes>
				</parameter>
				
<!-- -*regularize 	(default) regularize learned emission and gap probabilities with Dirichlet prior (-*noregularize to disable) -->					
				<parameter type="Switch">
					<name>no_regularize</name>
					<attributes>
						<prompt>Disable regularizing of learned emission and gap probabilities with Dirichlet prior (--noregularize)</prompt>
						<vdef>
							<value>0</value>
						</vdef>
						<format>
							<language>perl</language>
							<code>$value ? " --noregularize" : ""</code>
						</format>
						<group>35</group>
						<comment>
<value>The Dirichlet transition and emission regularization scales can be adjusted with --regularization-gapscale and --regularization-emitscale; regularization can be turned off entirely with --noregularize. The emission regularization scales correspond to the total number of pseudocount emissions, because the seed distribution for pseudocount calculation (taken to be the seed emission parameters) is normalized to 1. The emission regularization scales are equal to the number of free parameters in a symmetric pair emission matrix, 4 · (4 _ 1)/2+4 = 10 for nucleotides and 20 · (20 _ 1)/2+20 = 210 for amino acids. We have observed that FSA learning is insensitive to the transition regularization scale (qualitatively because there are many transition counts for typical pairs of sequences, thereby dwarfing the effects of the weak regularizer), which is set to 3 by default.</value>
						</comment>
					</attributes>
				</parameter>
	
	<!-- -*regularization-gapscale <real>  scaling factor for transition prior -->					
				<parameter type="Float">
					<name>reg_gapscale</name>
					<attributes>
						<prompt>Scaling factor for transition prior (--regularization-gapscale) </prompt>
						<precond>
							<language>perl</language>
							<code>!$no_regularize</code>
						</precond>
						<format>
							<language>perl</language>
							<code>defined $value ? " --regularization-gapscale $value" : ""</code>
						</format>
						<group>35</group>
					</attributes>
				</parameter>
				
	<!-- -*regularization-emitscale <real> scaling factor for emission Dirichlet prior -->					
				<parameter type="Float">
					<name>reg_emitscale</name>
					<attributes>
						<prompt>Scaling factor for emission Dirichlet prior ( --regularization-emitscale)</prompt>
						<precond>
							<language>perl</language>
							<code>!$no_regularize</code>
						</precond>
						<format>
							<language>perl</language>
							<code>defined $value ? " --regularization-emitscale $value" : ""</code>
						</format>
						<group>35</group>
					</attributes>
				</parameter>
				
<!---*mininc <real> minimum fractional increase in log-likelihood per round of EM (default is 0.1)-->					
				<parameter type="Float">
					<name>min_increase</name>
					<attributes>
						<prompt>Minimum fractional increase in log-likelihood per round of expectation maximization EM (--mininc)</prompt>
						<format>
							<language>perl</language>
							<code>defined $value ? " --mininc $value":""</code>
						</format>
						<group>35</group>
					</attributes>
				</parameter>
				
<!-- -*maxrounds <integer>  maximum number of iterations of EM (default is 3)-->					
				<parameter type="Integer">
					<name>max_rounds</name>
					<attributes>
						<prompt>Maximum number of iterations of expectation maximization (EM) (--maxrounds)</prompt>
						<format>
							<language>perl</language>
							<code>defined $value ? " --maxrounds $value":""</code>
						</format>
						<group>35</group>
					</attributes>
				</parameter>
	
<!-- -*mingapdata <integer> minimum amount of sequence data (# of aligned pairs of characters) for training gap probs-->	
<!-- >>>>>> k.        is there a default value for the parameter -mingapdata?
>>>>>>
>>>>>> For nucleotides, -*mingapdata and -*minemitdata are both set to 60.  
>>>>>> For protein, -*mingapdata is set to 60 and -*minemitdata is set to 1596. -->				
				<parameter type="Integer">
					<name>min_gapdata</name>
					<attributes>
						<prompt>Minimum number of aligned pairs of characters required for training gap probs (--mingapdata)</prompt>
						<format>
							<language>perl</language>
							<code>defined $value ? " --mingapdata $value" : ""</code>
						</format>
						<group>35</group>
						<comment>
<value>The minimum amount of sequence data for learning transition and emission probabilities can be controlled with --mingapdata and --minemitdata. By default the minimum data for learning gap probabilities corresponds approximately to 60 characters.</value>
						</comment>
					</attributes>
				</parameter>	

<!-- -*minemitdata <integer> minimum amount of sequence data (# of aligned pairs of characters) for training emission probs-->					
				<parameter type="Integer">
					<name>min_emitdata</name>
					<attributes>
						<prompt>Minimum number of aligned pairs of characters for training emission probs (--minemitdata) 60 (dna) or 1596 (aa)</prompt>
						<format>
							<language>perl</language>
							<code>defined $value ? " --minemitdata $value" : ""</code>
						</format>
						<group>35</group>
						<comment>
<value>The minimum amount of sequence data for learning transition and emission probabilities can be controlled with --mingapdata and --minemitdata. By default the minimum data for learning emission probabilities corresponds approximately to two DNA or RNA sequences of length 60 nucleotides (minemitdata = 60) or four protein sequences of length 266 amino acids (minemitdata = 1596), which  corresponds to observing each of independent parameter of a substitution matrix four times.</value>
						</comment>
					</attributes>
				</parameter>
						
			</parameters>
		</paragraph>
	</parameter>

<!-- Group 40 Multiple alignment options: sequence annealing
*******************************************************
 -->

	<parameter type="Paragraph">
		<paragraph>
			<name>mult_opts</name>
			<prompt>Multiple alignment: Sequence annealing options</prompt>
			<parameters>
			
<!-- -*gapfactor <real> gap factor; 0 for highest sensitivity (the internal effective minimum is 0.01); >1 for higher specificity (default is 1) -->
				<parameter type="Float">
					<name>gap_factor</name>
					<attributes>
						<prompt>Gap factor (-gapfactor)</prompt>
						<vdef>
							<value>1.0</value>
						</vdef>
						<format>
							<language>perl</language>
							<code>" --gapfactor $value"</code>
						</format>
						<group>40</group>
						<comment>
<value>For the gap factor: Use 0 for highest sensitivity (the internal effective minimum is 0.01); use values greater than 1 for higher specificity (default is 1) </value>
						</comment>
					</attributes>
				</parameter>

<!-- -*refinement <integer>   number of iterative refinement steps (default is unlimited; 0 for none) ***HOW MANY DEFAULT*** -->			
				<parameter type="Integer">
					<name>num_iterations</name>
					<attributes>
						<prompt>Limit the number of iterative refinement steps (no entry here means unlimited steps) (--refinement)</prompt>
						<format>
							<language>perl</language>
							<code>defined $value ? " --refinement $value" : ""</code>
						</format>
						<group>40</group>
						<comment>
<value> The number of rounds of iterative refinement is controlled with --refinement.  </value>
						</comment>
					</attributes>
				</parameter>
				
<!---*dynamicweights  (default) enable dynamic edge re-weighting (-*nodynamicweights to disable) -->
				<parameter type="Switch">
					<name>no_dynweight</name>
					<attributes>
						<prompt>Disable dynamic edge re-weighting. NOT GENERALLY RECOMMENDED (--nodynamicweights)</prompt>
						<vdef>
							<value>0</value>
						</vdef> 
						<format>
							<language>perl</language>
							<code>$value ? " --nodynamicweights" : ""</code>
						</format>
						<group>40</group>
					</attributes>
				</parameter>
				
<!-- -*treeweights <string>  weights for sequence pairs based on a tree	
>>>>>>
>>>>>>     3. for multiple alignment options
>>>>>>
>>>>>> l.         is the -treeweights option for a newick formatted tree? is there a 
>>>>>> program that produces this tree? should this option be exposed?
>>>>>>
>>>>>> This doesn't take a tree as input, but rather a set of weights for 
>>>>>> each pair of sequences.  This option is highly experimental, so I recommend that it be hidden.
>>>>>> -->
<!--	this param is experimental and will be hidden for now			
					<parameter type="InFile">
					<name>use_tree</name>
					<attributes>
						<prompt>Provide a treeweights for sequence pairs (-treeweights)</prompt>
						<format>
							<language>perl</language>
							<code>defined $value ? " -*treeweights treefile.tre" : ""</code>
						</format>
						<filenames>treefile.tre</filenames>
						<group>40</group>
					</attributes>
				</parameter> -->
			
<!--  -*require-homology  require that there be some detectable homology between all input sequences	-->
				<parameter type="Switch">
					<name>require_homology</name>
					<attributes>
						<prompt>Require detectable homology between all input sequences (--require-homology)</prompt>
						<vdef>
							<value>0</value>
						</vdef> 
						<format>
							<language>perl</language>
							<code>$value ? " --require-homology" : ""</code>
						</format>
						<group>40</group>
					</attributes>
				</parameter>
				
			</parameters>
		</paragraph>
</parameter>

	<parameter type="Paragraph">
		<paragraph>
			<name>speedup_many_opts</name>
			<prompt>Speedup options for alignments with many sequences</prompt>
			<parameters>
			
<!-- Group 45 Alignment speedup options: many sequences
*****************************************************
 -->

<!-- -*refalign alignment to a reference sequence only (reference must be first sequence in file) -->
				<parameter type="Switch">
					<name>ref_alignment</name>
					<attributes>
						<prompt>Use First Sequence as Reference for the Alignment (--refalign) </prompt>
						<vdef>
							<value>0</value>
						</vdef>
						<format>
							<language>perl</language>
							<code>$value ? " --refalign" : ""</code>
						</format>
						<group>45</group>
						<comment>
<value>The refalign option uses the first sequence in the input file as a reference alignment. No other pairwise comparisons are performed, so a total of (N _ 1) comparisons are made. 
</value>
						</comment>
					</attributes>
				</parameter>
				
<!-- -*mst-min <integer> build -*mst-min minimum spanning trees on input sequences for pairwise comparisons (default is 3) -->
				<parameter type="Integer">
					<name>min_spantree</name>
					<attributes>
						<prompt>Specify how many minimum spanning trees on input sequences for pairwise comparisons, default 3 (--mst-min)</prompt>
						<format>
							<language>perl</language>
							<code>defined $value ? " --mst-min $value":""</code>
						</format>
						<group>45</group>
					</attributes>
				</parameter>

<!-- -*mst-max <integer>  build -*mst-max maximum spanning trees on input sequences for pairwise comparisons (default is 0)) -->
				<parameter type="Integer">
					<name>max_spantree</name>
					<attributes>
						<prompt>Specify how many maximum spanning trees on input sequences for pairwise comparisons, default 0 (--mst-max)</prompt>
						<format>
							<language>perl</language>
							<code>defined $value ? " --mst-max $value":""</code>
						</format>
						<group>45</group>
					</attributes>
				</parameter>			

<!-- -*mst-palm <integer> build -*mst-palm minimum spanning palm trees on input sequences for pairwise comparisons (default is 0) -->
				<parameter type="Integer">
					<name>max_palmtree</name>
					<attributes>
						<prompt>Specify how many minimum spanning palm trees on input sequences for pairwise comparisons, default 0 (--mst-palm)</prompt>
						<format>
							<language>perl</language>
							<code>defined $value ? " --mst-palm $value":""</code>
						</format>
						<group>45</group>
					</attributes>
				</parameter>								
	
<!-- -*degree <integer> use -*degree number of pairwise comparisons between closest sequences (default is 0) -->
				<parameter type="Integer">
					<name>number_degree</name>
					<attributes>
						<prompt>Specify how many pairwise comparisons between closest sequences default 0 (--degree)</prompt>
						<format>
							<language>perl</language>
							<code>defined $value ?" --degree $value":""</code>
						</format>
						<group>45</group>
					</attributes>
				</parameter>	
									
<!-- -*kmer <integer>	length of k-mers to use when determining sequence similarity -->
<!-->The setting for -*kmer is chosen on the fly using the following formula:
>>>
>>> 1 + floor (log (L) / log (N))
>>>
>>> where L is the median input sequence length and N is the size of the alphabet (4 for nucleotide and 20 for protein).
>>> -->
				<parameter type="Integer">
					<name>kmer_length</name>
					<attributes>
						<prompt>Length of k-mers to use when determining sequence similarity (--kmer)</prompt>
						<format>
							<language>perl</language>
							<code>defined $value ? " --kmer $value" :" "</code>
						</format>
						<group>45</group>
					</attributes>
				</parameter>

<!-- -*alignment-fraction <real>       	randomized fraction of all (n choose 2) pairs of sequences to consider during alignment inference (default is 1) -->
<!-- 9/1/2009 - The -*alignment-fraction option should have no default value. -->
				<parameter type="Float">
					<name>alignment_fraction</name>
					<attributes>
						<prompt>Randomized fraction of all pairs of sequences to consider during alignment inference (--alignment-fraction)</prompt>
						<precond>
							<language>perl</language>
							<code>!defined $alignment_number</code>
						</precond>
						<format>
							<language>perl</language>
							<code>defined $value ? " --alignment-fraction $value":""</code>
						</format>
						<comment>
<value>Alignment speedup options: many sequences. The user can control the fraction or total number of pairwise comparisons made when building a multiple alignment with the --alignment-fraction and --alignment-number options. The number of comparisons used when aligning N sequences can lie be­tween (N _ 1) and N · (N _ 1)/2;as discussed in the main text, we observe good performance even when only a subset of pairs are used. The number of pairwise comparisons used for parameter learning when --learnemit-all (the default for proteins) is enabled can be similarly controlled with--learning-fraction and --learning-number. Gen­erally fewer pairwise comparisons are necessary for effective parameter learning than for constructing a multiple alignment. </value>
						</comment>
						<group>45</group>
					</attributes>
				</parameter>
				
<!-- -*alignment-number <integer>    	total number of (randomized) pairs of sequences to consider during alignment inference -->
				<parameter type="Integer">
					<name>alignment_number</name>
					<attributes>
						<prompt>Total number of (randomized) pairs of sequences to consider during alignment inference (--alignment-number)</prompt>
						<precond>
							<language>perl</language>
							<code>!$alignment_fraction</code>
						</precond>
						<format>
							<language>perl</language>
							<code>defined $value ? " --alignment-number $value" :" "</code>
						</format>
						<group>45</group>
						<comment>
<value>Alignment speedup options: many sequences. The user can control the fraction or total number of pairwise comparisons made when building a multiple alignment with the -alignment-fraction and -alignment-number options. The number of comparisons used when aligning N sequences can lie be­tween (N _ 1) and N · (N _ 1)/2; as discussed in the main text, we observe good performance even when only a subset of pairs are used. The number of pairwise comparisons used for parameter learning when -learnemit-all (the default for proteins) is enabled can be similarly controlled with--learning-fraction and -learning-number. Generally fewer pairwise comparisons are necessary for effective parameter learning than for constructing a multiple alignment. </value>
						</comment>
					</attributes>
				</parameter>
				
			</parameters>
		</paragraph>
	</parameter>
								
	<parameter type="Paragraph">
		<paragraph>
			<name>speedup_long_opts</name>
			<prompt>Speedup options for alignments with long sequences (MUMmer)</prompt>
			<parameters>
			
<!-- Group 50 Alignment speedup options: long sequences (MUMmer)
****************************************************************
 -->

<!-- -*minlen <integer>  minimum length of exact matches for anchoring -->				
				<parameter type="Integer">
					<name>min_anchorlen</name>
					<attributes>
						<prompt>Minimum length of exact matches for anchoring (--minlen) </prompt>
						<precond>
							<language>perl</language>
							<code>!$no_anchors</code>
						</precond>
						<format>
							<language>perl</language>
							<code>defined $value ? " --minlen $value" : ""</code>
						</format>
						<group>50</group>
						<comment>
<value> By default, the minimum length of anchors is 10 for nucleotide sequence and 7 for amino acid sequence (for anchoring protein sequences or translated anchoring of nucleotide sequence).</value>
						</comment>
					</attributes>
				</parameter>
				
<!-- -*maxjoinlen <integer> 	maximum ungapped separation of parallel adjacent anchors to join (default is 2) -->				
				<parameter type="Integer">
					<name>max_joinlen</name>
					<attributes>
						<prompt>Maximum ungapped separation of parallel adjacent anchors to join (--maxjoinlen) </prompt>
						<precond>
							<language>perl</language>
							<code>!$no_anchors</code>
						</precond>
						<vdef>
							<value>2</value>
						</vdef>
						<format>
							<language>perl</language>
							<code>defined $value ? " --maxjoinlen $value" : ""</code>
						</format>
						<group>50</group>
						<comment>
<value> Because MUMmer reports only exact matches, by default FSA concatenates adjacent parallel anchors which are separated by at most 2 mismatches; this can be controlled with --maxjoinlen
</value>
						</comment>
					</attributes>
				</parameter>

<!-- -*hardmasked  leave hardmasked sequence >10 nt unaligned instead of randomizing it (default for long DNA) -->				
				<parameter type="Switch">
					<name>use_hardmask</name>
					<attributes>
						<prompt>Leave hardmasked sequences greater than 10 nt unaligned instead of randomizing (--hardmasked)</prompt>
						<precond>
							<language>perl</language>
							<code>!$no_anchors &amp; !$align_in_protspace</code>
						</precond>
						<format>
							<language>perl</language>
							<code>$value ? " --hardmasked" : ""</code>
						</format>
						<group>50</group>
						<comment>
<value>The --hardmasked option is the default for long DNA sequences</value>
						</comment>
					</attributes>
				</parameter>
									
			</parameters>
		</paragraph>
	</parameter>
							
	<parameter type="Paragraph">
		<paragraph>
			<name>speedup_long_opts2</name>
			<prompt>Speedup options for alignments with long sequences</prompt>
			<parameters>
			
<!-- Group 55 Alignment speedup options: long sequences (exonerate)
*****************************************************************
 -->

<!-- -*minscore <integer> minimum score of alignments found by exonerate (default is 100) -->
				<parameter type="Integer">
					<name>exon_minscore</name>
					<attributes>
						<prompt>Minimum score of alignments found by exonerate (--minscore)</prompt>
						<precond>
							<language>perl</language>
							<code>!$no_anchors &amp; !$align_in_protspace</code>
						</precond>
						<vdef>
							<value>100</value>
						</vdef>
						<format>
							<language>perl</language>
							<code>" --minscore $value"</code>
						</format>
						<group>55</group>
					</attributes>
				</parameter>
				
				
<!-- Group 60 Alignment speedup options: long sequences (Mercator)
********************************************************************
-*mercator <string>   input Mercator constraints -->
				<parameter type="InFile">
					<name>provide_mercator</name>
					<attributes>
						<prompt>Provide a file with constraint maps produced by the Mercator (--mercator)</prompt>
						<format>
							<language>perl</language>
							<code>defined $value ? " --mercator mercfile.txt" : ""</code>
						</format>
						<filenames>mercfile.txt</filenames>
						<group>40</group>
						<comment>
<value>The Mercator option is used for aligning long sequences. FSA can use the constraint maps produced by the homology-mapping program Mercator to constrain the multiple alignment.
Mercator is found here: Dewey CN (2006) Whole-Genome Alignments and Polytopes for Comparative Genomics. Ph.D. Thesis, EECS Department, University of California, Berkeley. URL http://www.eecs.berkeley.edu/Pubs/TechRpts/2006/EECS-2006-104.html</value>
						</comment>
					</attributes>
				</parameter>
				
			</parameters>
		</paragraph>
	</parameter>	
	<!-- I suggest that you don't allow people to use the -*gui option, because it can generate very large files.  1 GB files are not uncommon, and they can become even larger if many sequences (>
100) are aligned.-->

	<!--		<parameter type="Paragraph">
			<paragraph>
				<name>output_opts</name>
				<prompt>Output Options</prompt>
					<parameters>
						
						<parameter type="Switch">
							<name>output_gui</name>
							<attributes>
								<prompt>Record alignment and statistical model for interactive Java GUI (-gui)</prompt>
								<precond>
									<language>perl</language>
									<code>!$align_in_protspace</code>
								</precond>
								<vdef>
									<value>0</value>
								</vdef>
									<format>
										<language>perl</language>
										<code> ($value)?" -*gui":""</code>
									</format>
								<group>15</group>
								<comment>
<value>You can recordand subsequently viewall intermediate alignments produced by the sequence anneal­ing process. Use the GUI option to produce files formatted for the Java interactive GUI. This option is also used to record the statistical model estimated by FSA in order to graphically view the expected accuracy of the alignment. 
</value>
								</comment>
							</attributes>
						</parameter> -->
						
<!-- I dont know how to return these values yet -->	
<!--											
						<parameter type="Switch">
							<name>output_learned</name>
							<attributes>
								<prompt>Write learned emission distributions (substitution matrices) to a file</prompt>
								<vdef>
									<value>0</value>
								</vdef>
									<format>
										<language>perl</language>
										<code> ($value) ? " -*write-params":""</code>
									</format>
								<group>15</group>
								<comment>
<value>Use -*write-params and -*write-posteriors to record the learned emission parameters (substitution matrices) and pairwise posterior probability matrices to files. See Section6for information on how to view these graphically. </value>
								</comment>

							</attributes>
						</parameter>  -->
						
	<!-- I dont know how to return these values yet -->						
	<!--					<parameter type="Switch">
							<name>output_learned</name>
							<attributes>
								<prompt>Write learned pairwise posterior alignment probability matrices to a file</prompt>
								<vdef>
									<value>0</value>
								</vdef>
									<format>
										<language>perl</language>
										<code> ($value)?" -*write-posteriors":""</code>
									</format>
								<group>15</group>
							</attributes>
						</parameter> 
						
					</parameters>
			</paragraph>
		</parameter> -->

<!-- ******************Here we return all input files************************* -->

		<parameter type="Results">
			<name>all_commandline</name>
			<attributes>
				<filenames>COMMANDLINE</filenames>
			</attributes>
		</parameter>

		<parameter type="Results">
			<name>input_matrix</name>
			<attributes>
				<filenames>infile</filenames>
			</attributes>
		</parameter>
		
		<parameter type="Results">
			<name>input_postprobs</name>
			<attributes>
				<filenames>postprobs.txt</filenames>
			</attributes>
		</parameter>
		
		<parameter type="Results">
			<name>input_anchors</name>
			<attributes>
				<filenames>infile.anchors</filenames>
			</attributes>
		</parameter>

<!-- ******************Here we return all output files************************* -->		

		<parameter type="Results">
			<name>all_results</name>
			<attributes>
				<filenames>*</filenames>
			</attributes>
		</parameter>

		<parameter type="Results">
			<name>stockholm_results</name>
			<attributes>
				<filenames>*.stk</filenames>
			</attributes>
		</parameter>

		<parameter type="Results">
			<name>fasta_results</name>
			<attributes>
				<filenames>*.afa</filenames>
			</attributes>
		</parameter>
		
<!-- these two files come from the -*gui option -->

		<parameter type="Results">
			<name>gui_results1</name>
			<attributes>
				<filenames>*.gui</filenames>
			</attributes>
		</parameter>
		
		<parameter type="Results">
			<name>gui_results2</name>
			<attributes>
				<filenames>*.probs</filenames>
			</attributes>
		</parameter>	

	</parameters>
</pise>
