<?xml version="1.0" encoding="ISO-8859-1"?>
<!DOCTYPE pise SYSTEM "http://www.phylo.org/dev/rami/PARSER/pise2.dtd">
<!--
Final updates for 0.96 suggested by Derrick Zwickl, 11/14/2008.

One general point is that the defaults for datatype = codon-aminoacid should be exactly the same as aminoacid.  

The analyses are exactly the same, the translation from codons to amino acids is just handled internally by GARLI in the case of codon-aminoacid.  The only difference in settings is that the genetic code must be specified for codon-aminoacid.  In particular, this means that a number of extra settings need to be added to the codon-aminoacid set:
invariantsites this is done
numratecats this is done
ratehetmodel this is done

Cant implement yet:
The only other normal entry that you are missing is outputcurrentbesttree.  There is probably no reason for you to use this (unless you would want access to the current best tree during a run), and the default is 0 anyway.

Added this in group 2; 
One undocumented (and semi-experimental) feature that you might want to add would be the "collapsebranches" boolean entry in the general section.  This tells the program to collapse minimum length branches (effectively zero length) branch upon output of the final trees.  

Otherwise the final trees are always fully bifurcating, even when returning a polytomy makes more sense.  For some datasets this can make a big difference because final trees may in fact be identical with those branches collapsed, but they will appear different if they are compared on the basis of the topology alone (for example, when calculating tree to tree distances).  If simply visualized with the branches proportional to their lengths the trees will look identical because the tiny branches will be indistinguishable from a polytomy.  This feature can be particularly important in the case of bootstrapping, where you don't really want branches that effectively don't exist (and are an arbitrary resolution of a polytomy) to be counted in the support values.  The only downside of this setting is that GARLI's test at the end of a run for whether the trees from each replicates are identical may be wrong if branches are collapsed.  I don't know if you use or return that information anyway (the .screen.log file), so it may not be a big deal.

Specific changes:
-Change all genthreshfortopoterm from 10K to 20K DONE

-For both aminoacid and codon-aminoacid, numratecats should be 4 DONE

-I would have the ratematrix for aminoacid and codon-aminoacid default to WAG.  The user should really be making a conscious choice about which to use, but (knowing users) they often just go with the defaults.  I don't think I've ever seen a dataset that actually statistically prefers dayhoff, and 95% of them seem to prefer either WAG or jones (JTT). DONE

-statefrequencies should be empirical for both aminoacid and codon-aminoacid DONE

-In terms of starting tree options, would go with streefname = stepwise instead of random.  This will give it a much better starting point, and especially on large datasets this can both reduce runtimes and improve results.  If you do that you'll also need to add attachmentspertaxon to the general section of the config.  I'd suggest a default value of 50.   DONE

Previously the portal was providing a parsimony starting tree to GARLI generated by PAUP (I think), in which case streefname would be the name of that file.  Providing the PAUP tree was probably a good idea with version 0.951, but it may not be necessary because GARLI can now create its own likelihood stepwise addition trees.  Providing the user the option to go either way might be good.

-->
<!--
*********************************************************************************************************************************************************************************************
Updates for Garli 0.96 on Oct 21, 2008 by mamiller

New in version 0.96

1. Rigorous reading of Nexus datasets using Paul Lewis and Mark Holder's Nexus Class Library (NCL)

2. Ability to read Nexus starting trees using NCL

3. Ability to perform inference under amino acid and codon-based models of sequence evolution (datatype = aminoacid, datatype = codon)

4. Ability to specify multiple search replicates in a single config file (searchreps = #)

5. Ability to specify outgroups for orientation of inferred trees (outgroup = # # #)

6. Ability to use backbone as well as normal topological constraints

7. Ability to create fast likelihood stepwise addition starting trees (streefname = stepwise)

8. MPI version that spreads a specified number of serial runs across processors using a single config file, writing output to different output files (for example, to do 25 bootstrap replicates simultaneously on each of 8 processors)

9. Ability to perform nucleotide inference using any sub-model of the General Time-Reversible model (GTR), in addition to all of the common "named" models (K2P, HKY, etc)

10. Speed increases for non-parametric bootstrapping


Substitution models available in version 0.96 include:

Nucleotide models: All models nested within the General Time Reversible (GTR) model, optionally with discrete gamma distributed rate heterogeneity and/or an inferred proportion of invariable sites. 

Amino acid models: Many of the well known fixed amino acid rate matrices (Dayhoff, Jones, WAG, mtRev, mtmam), with either fixed or observed (aka "+F") amino acid frequencies, and discrete gamma 
distributed rate heterogeneity and/or an inferred proportion of invariable sites 

Codon models: The basic Goldman and Yang (1994) model and other related models, with a number of options for codon frequencies (equal, "F1x4", "F3x4", observed) and one or more estimated non-synonymous rate categories (aka dN/dS or omega parameters)

*********************************************************************************************************************************************************************************************-->

<!--
	Update for mpi version of garli on lonestar - Terri

	To run garli in parallel you specify the number of times you want garli to execute the config file on the commandline, eg, "garli-mpi -10"
	tells garli to execute the config file 10 times.  Each run can be done in parallel, so this is also the number of processors we
	say we can use in the cpu_count parameter.

	We don't let the user specify the number of times to run the config file, instead we consider the number of bootstrapreps and searchreps
	he's requested, eg, if the user sets searchreps=10, we change that to searchreps=1 in the config file and tell garli to execute the 
	config file 10 times.  The user is required to select either multiple searchreps or multiple bootstrapreps or both on teragrid; otherwise
	it would just be a serial run.

	The slightly tricky part is that if the user selects bootstrapping, searchreps specifies the number of searches to be done on each
	bootstrapped tree.  So we can do each bootstrap and it's related searches on a separate processor.  Thus if bootstrapping is 
	specified, we set bootstrapreps to 1 in the config file and specify the number of bootstrap reps on the command line (leaving searchreps 
	at whatever value the user set in the config file).  
-->

<!--
	This is garli version 0.951 (GARLI v. 0.951) by Derek Zwickl.  I believe the only command line option is the name of the configuration file.  All other options are specified in the configuration file.   

	It seems that all of garli's parameters must be specified in the garli.conf, even if you're leaving them at their default values (I may be wrong, but creating a  garli.conf with just a few obvious parameters doesn't work ... I don't know which are mandatory).  So, I'm going to put them all in here and fix their attributes  and move them to the right paragraphs as I have time to enhance this. 
	
	6/22/08, mamiller added the pickup and presentation of phylip files (.phy) preconditioned on the switch outputphyliptree_g.
-->
<!-- This interface was updated in oct 2010 by mamiller to support submissions to Lonestar in a more efficient way  -->
<!-- This interface was adapted to use on Abe by mamiller on or around Nov 1, 2010 -->
<!-- This interface was adapted to use on Trestles only on March 18, 2011 or so -->
<pise>
	<head>
		<title>GARLI 2.0 on XSEDE</title>
		<version>2.0</version>
		<description>Genetic Algorithm for Rapid Likelihood Inference - run on XSEDE.</description>
		<authors>Derrick J. Zwickl (zwickl@nescent.org)</authors>
		<reference> Zwickl, D. J., 2006. Genetic algorithm approaches for the phylogenetic analysis of large biological sequence datasets under the maximum likelihood criterion. Ph.D. dissertation, The University of Texas at Austin. http://garli.nescent.org 
		</reference>
		<category>Phylogeny / Alignment</category>
	</head>
	
	<command>garli2_tgb</command>
	<parameters>

		<!-- command name -->
		<parameter ishidden="1" type="String">
			<name>garli</name>
			<attributes>
				<format>
					<language>perl</language>
					<code>"garli2.0_wrap.sh"</code>
				</format>
				<group>0</group>
			</attributes>
		</parameter>


<!-- required input file, this is selected outside the parameters gui -->
		<parameter isinput="1" type="InFile">
			<name>infile</name>
			<attributes>
				<prompt>Alignment file (non-interleaved phylip or nexus format) (s)</prompt>
				<group>0</group>
				<filenames>infile</filenames>
			</attributes>
		</parameter>

<!--

Sample input files, run scripts, and output files are at

   /home/pfeiffer/garli-1.0_trestles

As for the rules to run GARLI, I think we no longer need to place limits on the number of searches allowed.
Instead, we can just limit runs to a single 32-core node.  Here are the rules that I suggest.

- Check searchreps and bootstrapreps.

- If bootstrapreps = 0, set nruns=searchreps and searchreps=1

- If bootstrapreps != 0, set nruns=bootstrapreps and bootstrapreps=1.

- If nruns < 32, run MPI version of GARLI on nruns cores in the shared queue.

- If nruns >= 32, run MPI version of GARLI on all 32 cores of a single node in the normal queue.

-->

		
<!-- Each element specifying mpi procs is accompanied by a command line that specifies the number of searchreps (if bootstrapreps=0) 
	or the number of bootstrapreps (if bootstrapreps ne 0), This goes on the command line, eg. "garli-mpi 10", for 10 searchreps.  
	It specifies the number of times the garli parameter file will be executed.  Each execution can be done in parallel so we request
	the same number of processors via the mpi_processes parameter above.  -->

<!-- first we deal with making the command line correct; this value is appended to "garliwrap.sh" they must be group 1 -->
<!-- these values are correct, independent of whether the file is uploaded or generated in situ; so we dont need to make
	 multiple configurations -->
		
<!-- If bootstrapreps = 0, set nruns=searchreps -->		
	  	<parameter type="Integer" ishidden="1" >
			<name>number_of_runssearchrep1</name>
			<attributes>
				<group>1</group>
				<precond>
					<language>perl</language>
					<code>$bootstrapreps &lt; 1 &amp;&amp; $searchreps_value &gt; 0</code>
				</precond>
				<format>
					<language>perl</language>
					<code>"$searchreps_value"</code>
				</format>
			</attributes>
		</parameter>
		
<!-- If bootstrapreps != 0, set nruns=bootstrapreps -->	
	    <parameter type="Integer" ishidden="1" >
			<name>number_of_runsbootrep</name>
			<attributes>
				<group>1</group>
				<precond>
					<language>perl</language>
					<code>$bootstrapreps &gt; 0 </code>
				</precond>
				<format>
					<language>perl</language>
					<code>"$bootstrapreps"</code>
				</format>
			</attributes>
		</parameter>
		
<!-- now we create scheduler.conf -->
<!-- scheduler.conf is also independent of whether garli.conf is uploaded or not -->
<!-- wall time can be 0.1 - 168 hrs -->
		<parameter type="Float" issimple="1" ismandatory="1">
			<name>runtime</name> 
			<attributes>
				<group>1</group>
				<paramfile>scheduler.conf</paramfile>
				<prompt>Maximum Hours to Run (click here for help setting this correctly)</prompt>
				<vdef><value>0.5</value></vdef>
				<ctrls>
					<ctrl>
						<message>Maximum Hours to Run must be between 0.1 - 168.0.</message>
						<language>perl</language>
						<code>$runtime &lt; 0.1 || $runtime &gt; 168.0</code>
					</ctrl>
				</ctrls>
				<format>
					<language>perl</language>
					<code>"runhours=$value\\n"</code>
				</format>
				<comment>
<value>Estimate the maximum time your job will need to run. We recommend testimg initially with a &lt; 0.5hr test run because Jobs set for 0.5 h or less depedendably run immediately in the "debug" queue. 
Once you are sure the configuration is correct, you then increase the time. The reason is that jobs &gt; 0.5 h are submitted to the "normal" queue, where jobs configured for 1 or a few hours times may
run sooner than jobs configured for the full 168 hours. 
</value>
				</comment>	
			</attributes>
		</parameter>
		
<!-- Garli is always run mpi -->		
		<parameter type="String" ishidden="1" >
			<name>jobtype</name>
			<attributes>
				<group>1</group>
				<paramfile>scheduler.conf</paramfile>
				<format>
					<language>perl</language>
					<code>"jobtype=mpi\\n"</code>
				</format>
			</attributes>
		</parameter>

<!-- all garli runs are on a single node now that we use trestles; it might run in a shared node or a dedicated node, depending on proc number -->		
		<parameter type="Integer" ishidden="1" >
			<name>searchrep_mpi_processes_nodeslt32</name>
			<attributes>
				<group>1</group>
				<paramfile>scheduler.conf</paramfile>
				<format>
					<language>perl</language>
					<code>"nodes=1 \\n"</code>
				</format>
			</attributes>
		</parameter> 

<!-- now set the value of mpi_processes in scheduler.conf -->		
<!-- If bootstrapreps = 0, set mpi_processes=searchreps; this value will never be greater than 8 -->		  	
	    <parameter type="Integer" ishidden="1" >
			<name>searchrep_mpi_processes</name>
			<attributes>
				<group>1</group>
				<paramfile>scheduler.conf</paramfile>
				<precond>
					<language>perl</language>
					<code>$bootstrapreps &lt; 1 &amp;&amp; $searchreps_value &gt; 0</code>
				</precond>
				<format>
					<language>perl</language>
					<code>"mpi_processes=$searchreps_value \\n"</code>
				</format>
			</attributes>
		</parameter> 

<!-- If bootstrapreps != 0, set mpi_processes as follows: -->	
<!-- If nruns < 32; mpi_processes = $bootstrapreps; this will go on a shared node -->	
		<parameter type="Integer" ishidden="1" >
			<name>mpi_processes_1-32</name>
			<attributes>
				<group>1</group>
				<paramfile>scheduler.conf</paramfile>
				<precond>
					<language>perl</language>
					<code>$bootstrapreps &gt; 0 &amp;&amp; $bootstrapreps &lt; 32</code>
				</precond>
				<format>
					<language>perl</language>
					<code>"mpi_processes=$bootstrapreps \\n"
					</code>
				</format>
			</attributes>
		</parameter>
		
<!-- If nruns >= 32; mpi_processes = 32; this will go on a dedicated node-->		
		<parameter type="Integer" ishidden="1" >
			<name>mpi_processes_gt32</name>
			<attributes>
				<group>1</group>
				<paramfile>scheduler.conf</paramfile>
				<precond>
					<language>perl</language>
					<code>$bootstrapreps &gt; 31</code>
				</precond>
				<format>
					<language>perl</language>
					<code>"mpi_processes=32 \\n"
					</code>
				</format>
			</attributes>
		</parameter>

<!-- visible parameters -->		
<!-- now we let the user advise us if they wish to provide their own garli_conf file; this turns off the parts of the interface
	 that generates garli.conf; but it retains the parameters that configure the command line  -->
					<parameter issimple="1" type="Switch" >
					<name>user_conffile</name>
						<attributes>
							<group>1</group>
							<prompt>I would like to provide my own GARLI configuration file (for help, see the GARLI.conf Creator tool)</prompt>
							<comment>
<value>This option allows the user to upload a garli.conf file that has multiple partitions. One can create a garli.conf file with up to 5 partitions using the GARLI.conf Creator tool here, or follow the instructions in the GARLI manual to create your own file.
The files created using GARLI.conf Creator can be edited manually .to manage more (unlimited) partitions. </value>
							</comment>
						</attributes>
					</parameter>
									
<!-- It is a little tricky to set the values for searchreps and bootstrap reps in the garli.conf file, but our tool does it correctly, so we dont worry if we made it -->		
					<parameter issimple="1" type="Switch" >
					<name>userconffilehere</name>
						<attributes>
							<group>1</group>
							<prompt>The garli.conf file was created using GARLI.conf Creator or the GARLI2_TG interface</prompt>
							<precond>
								<language>perl</language>
								<code>$user_conffile &amp;&amp; !$userconffilethere</code>
							</precond>
							<ctrls>
								<ctrl>
									<message>Please specify whether the garli.conf file was created using the CIPRES GARLI.conf Creator tool, or elsewhere</message>
									<language>perl</language>
									<code>!$userconffilethere &amp;&amp; !$userconffilehere</code>
								</ctrl>
							</ctrls>
							<comment>
<value>A garli.conf file created by the Garli Conf Creator will be configured correctly for the CIPRES Science Gateway, so no further adjustments will be needed.</value>
							</comment>
						</attributes>
					</parameter>
		
<!-- Ask if the user created their own garli.conf file -->		
					<parameter issimple="1" type="Switch" >
						<name>userconffilethere</name>
							<attributes>
								<group>1</group>
								<prompt>The garli.conf file was created outside of CIPRES</prompt>
								<precond>
									<language>perl</language>
									<code>$user_conffile &amp;&amp; !$userconffilehere</code>
								</precond>
								<warns>
									<warn>
										<message>Please be sure that in the garli.conf file you uploaded, searchreps=1 (even though this seems counterintuitive; it is essential for the mpi code), then click the box that says I have set the values of searchreps and bootstrapreps correctly</message>
										<language>perl</language>
										<code>$user_conffile &amp;&amp; $userconffilethere &amp;&amp; $bootstrapreps &lt; 1 &amp;&amp; $searchreps_value &gt; 1 </code>
									</warn>
									<warn>
										<message>Please be sure that in the garli.conf file you uploaded, bootstrapreps=1 (even though this seems counterintuitive; it is essential for the mpi code), then click the box that says I have set the values of searchreps and bootstrapreps correctly</message>
										<language>perl</language>
										<code>$user_conffile &amp;&amp; $userconffilethere &amp;&amp; $bootstrapreps &gt; 1 </code>				
									</warn> 
								</warns>
								<comment>
<value>A garli.conf file created without using the Garli Conf Creator may not be configured correctly for the CIPRES Science Gateway.
Please make sure your file conforms to the following characteristics: If bootstrap reps=0 please be sure that searchreps=1. If bootstrapreps > 0 please be sure thta in the garli.conf file you uploaded
bootstrapreps = 1 ; and searchreps = the number of searchreps you actually want (even though this seems counterintuitive; it is essential for the mpi code.</value>
							</comment>
							</attributes>
					</parameter>
				
					<parameter issimple="1" type="InFile" >
						<name>upload_conffile</name>
							<attributes>
								<prompt>Select the GARLI configuration file</prompt>
								<precond>
									<language>perl</language>
									<code>$user_conffile &amp;&amp; ($userconffilethere || $userconffilehere)</code>		
								</precond>
								<group>1</group>
								<filenames>garli.conf</filenames>
								<ctrls>
									<ctrl>
										<message>Please Select a garli.conf file</message>
										<language>perl</language>
										<code>!defined $upload_conffile &amp;&amp; ($userconffilethere || $userconffilehere)</code>
									</ctrl>
								</ctrls>
							</attributes>
					</parameter>
					
<!-- It is a little tricky to set the values for searchreps and bootstrap reps in the garli.conf file, this tool reminds people to set the garli.conf file correctly if they bring their own. -->								
					<parameter issimple="1" type="Switch" >
						<name>userconffileconfirm</name>
							<attributes>
								<group>1</group>
								<prompt>I have set the values of searchreps and bootstrapreps correctly</prompt>
								<precond>
									<language>perl</language>
									<code>$userconffilethere</code>
								</precond>
							</attributes>
					</parameter>
		
<!-- this section is for file return. there are three types of files: input for garli, teragrid run files, and results files -->
<!-- to return all results just uncomment this element 
		<parameter type="Results">
			<name>all_outputfiles</name>
			<attributes>
				<filenames>*</filenames>
			</attributes>
		</parameter> -->

<!-- Input for Garli -->		
		<parameter type="Results">
			<name>a_matrix_file</name>
			<attributes>
				<prompt>Input</prompt>
				<filenames>infile</filenames>
			</attributes>
		</parameter>
				
		<parameter type="Results">
			<name>b_command_line</name>
			<attributes>
				<prompt>commandline</prompt>
				<filenames>COMMANDLINE</filenames>
			</attributes>
		</parameter>
		
		<parameter type="Results">
			<name>c_garli_configuration</name>
			<attributes>
				<prompt>Input parameters</prompt>
				<filenames>garli.conf</filenames>
			</attributes>
		</parameter>
		
		<parameter type="Results">
			<name>d_starting_tree</name>
			<attributes>
				<prompt>Input starting tree/model</prompt>
				<filenames>starting.txt</filenames>
				<precond>
					<language>perl</language>
					<code> defined $streefname_pasted || defined $streefname_userdata </code>
				</precond>
			</attributes>
		</parameter>
				
		<parameter type="Results">
			<name>e_constraint_file</name>
			<attributes>
				<prompt>Input topology constraints</prompt>
				<filenames>constraint.txt</filenames>
				<precond>
					<language>perl</language>
					<code>defined $constraintfile_control</code>
				</precond>
			</attributes>
		</parameter>
		
<!-- TeraGrid run files -->
		<parameter type="Results">
			<name>f_scheduler_configuration</name>
			<attributes>
				<prompt>Scheduling parameters</prompt>
				<filenames>scheduler.conf</filenames>
			</attributes>
		</parameter>
		
		<parameter type="Results">
			<name>ff_scheduler_configuration</name>
			<attributes>
				<prompt>Scheduling stderr</prompt>
				<filenames>scheduler_stderr.txt</filenames>
			</attributes>
		</parameter>
		
		<parameter type="Results">
			<name>g_jobinfo_txt</name>
			<attributes>
				<prompt>jobinfo_parameters</prompt>
				<filenames>*_JOBINFO.TXT</filenames>
			</attributes>
		</parameter>
		
		<parameter type="Results">
			<name>h_start_txt</name>
			<attributes>
				<prompt>start_txt</prompt>
				<filenames>start.txt</filenames>
			</attributes>
		</parameter>		
		
		<parameter type="Results">
			<name>hh_done_txt</name>
			<attributes>
				<prompt>done_txt</prompt>
				<filenames>done.txt</filenames>
			</attributes>
		</parameter>
	
	<!-- Results files -->
		<parameter type="Results">
			<name>i_garli_log00_results</name>
			<attributes>
				<filenames>*.log00.log</filenames>
			</attributes>
		</parameter>		

		<parameter type="Results">
			<name>j_garli_screenlog_results</name>
			<attributes>
				<filenames>*.screen.log</filenames>
			</attributes>
		</parameter>		

		<parameter type="Results">
			<name>k_garli_boottree_results</name>
			<attributes>
				<filenames>*boot.tre</filenames>
			</attributes>
		</parameter>

		<parameter type="Results">
			<name>l_garli_allboottree_results</name>
			<attributes>
				<filenames>allBootTrees.tre</filenames>
			</attributes>
		</parameter>		

		<parameter type="Results">
			<name>m_garli_besttree_results</name>
			<attributes>
				<filenames>*best.tre</filenames>
			</attributes>
		</parameter>

		<parameter type="Results">
			<name>n_garli_besttree_results</name>				
			<attributes>
				<filenames>all.tre</filenames>
				<precond>
					<language>perl</language>
					<code>$bootstrapreps &lt; 1</code>
				</precond>	
			</attributes>
		</parameter>	

		<parameter type="Results">
			<name>o_garli_bestalltree_results</name>
			<attributes>
				<filenames>*best.all.tre</filenames>
			</attributes>
		</parameter>		

<!--	<parameter type="Results">
			<name>garli_phytree</name>
			<attributes>
				<filenames>*.phy</filenames>
				<precond>
					<language>perl</language>
					<code>$outputphyliptree_g</code>
				</precond>
			</attributes>
		</parameter> -->

<!-- return all results when  testing -->
		<parameter type="Results">
			<name>all_results</name>
			<attributes>
				<filenames>*</filenames>
			</attributes>
		</parameter>
		
<!-- The following parameters build the configuration file, garli.conf --> 
<!-- parameters are grouped into labeled sections. everything in the "general" section should specify group=2, everything in the "master" section should use group=4, all of these parameters are switched off if
	  the user uploads a garli.conf file -->

<!--	 "general" section header is group 1: terms in "general" (group 2) are-->
		<parameter type="String" ishidden="1">
			<name>general_section</name>
			<attributes>
				<paramfile>garli.conf</paramfile>
				<precond>
					<language>perl</language>
					<code>!$user_conffile</code>
				</precond>
				<group>1</group>
				<format>
					<language>perl</language>
					<code>"[general]\\n"</code>
				</format>
			</attributes>
		</parameter>
		
<!--	 "master" section header is group 3 :)	-->	
		<parameter type="String" ishidden="1">
			<name>master_section</name>
			<attributes>
				<paramfile>garli.conf</paramfile>
				<precond>
					<language>perl</language>
					<code>!$user_conffile</code>
				</precond>
				<group>3</group>
				<format>
					<language>perl</language>
					<code>"\n\n[master]\\n"</code>
				</format>
			</attributes>
		</parameter>

<!-- name of input data file, hardcoded to infile -->
		<parameter type="String" ishidden="1">
			<name>datafname</name>
			<attributes>
				<paramfile>garli.conf</paramfile>
				<precond>
					<language>perl</language>
					<code>!$user_conffile</code>
				</precond>
				<group>2</group>
				<format>
					<language>perl</language>
					<code>"datafname = infile\\n"</code>
				</format>
				<group>2</group>
			</attributes>
		</parameter>
		
<!--	datafname = infile	-->
<!-- prefix for output filenames -->
		<parameter type="String" ishidden="1">
			<name>ofprefix</name>
			<attributes>
				<paramfile>garli.conf</paramfile>
				<precond>
					<language>perl</language>
					<code>!$user_conffile</code>
				</precond>
				<group>2</group>
				<format>
					<language>perl</language>
					<code>"ofprefix = garli_run\\n"</code>
				</format>
				<group>3</group>
			</attributes>
		</parameter>

<!--	availablememory = 2000 on trestles -->
		<parameter type="Integer" ishidden="1">
			<name>availablememory</name>
			<attributes>
				<paramfile>garli.conf</paramfile>
				<precond>
					<language>perl</language>
					<code>!$user_conffile</code>
				</precond>
				<group>2</group>
				<format>
					<language>perl</language>
					<code>"availablememory = 2000\\n"</code>
				</format>
			</attributes>
		</parameter>

<!-- VISIBLE PARAMETERS -->
<!-- Configure Partitions -->		
<!-- ==================================================================================================== -->
		<parameter type="Paragraph">
			<paragraph>
				<name>configure_partitions</name>
				<prompt>Partition Configuration</prompt>
				<parameters>
<!-- now we let the user advise us if the data set is partitioned -->
		<parameter type="Switch" >
			<name>is_partitioned</name>
			<attributes>
				<precond>
					<language>perl</language>
					<code>!$user_conffile</code>
				</precond>
				<group>1</group>
				<prompt>The input is a Nexus file that specifies at least two partitions</prompt>
			</attributes>
		</parameter>
					
<!-- apply all the model parameters selected here to all partitions-->
					<parameter type="Switch">
						<name>linkmodels</name>
						<attributes>
							<prompt>Apply selected model parameters to all partitions</prompt>
							<group>2</group>
							<precond>
									<language>perl</language>
									<code>$is_partitioned &amp;&amp; !$user_conffile</code>
							</precond>
							<format>
								<language>perl</language>
								<code>($value) ? "linkmodels = 1\\n":""</code>
							</format>
							<paramfile>garli.conf</paramfile>
<!-- this control lets the user know that individual rates cannot be set with this interface -->
							<ctrls>
								<ctrl>
									<message>Sorry, you cannot apply different rates to each partition unless you upload a garli.conf file</message>
									<language>perl</language>
									<code>!$linkmodels &amp;&amp; !$user_conffile</code>
								</ctrl>
							</ctrls>
						</attributes>			
					</parameter>
					
<!-- Specifying the models
DO SOME SORT OF MODEL TESTING! The parameter estimates under partitioned models are currently somewhat erratic if the models are 
over-parameterized. Use ModelTest or some other means for finding the best model for each data subset. Note that the best model
for each subset separately is not necessarily the best when they are combined in a partitioned model, but they will give a useful
measure of which parameters are justified in each subset. 

As usual for GARLI, the models are specified in the configuration file. If you aren't familiar with the normal way that models
are configured in GARLI, see the info in the manual here. 

There are two new configuration entries that relate to partitioned models: 

linkmodels = 0 or 1
subsetspecificrates = 0 or 1
	
linkmodels means to use a single set of model parameters for all subsets. 

subsetspecificrates means to infer overall rate multipliers for each data subset. This is equivalent to *prset ratepr=variable* in MrBayes 

So, there are various combinations here: 

linkmodels subsetspecificrates meaning  
0  0  different models, branch lengths equal  
0  1  different models, different subset rates  
1  0  single model, one set of branch lengths (equivalent to non-partitioned analysis)  
1  1  single model, different subset rates (like site-specific rates model in PAUP*)  

The normal model configuration entries are the following, with the defaults in *bold*: -->

<!-- apply all the model parameters selected here to all partitions-->
					<parameter type="Switch">
						<name>subsetspecificrates</name>
						<attributes>
							<prompt>Infer overall rate multipliers for each data partition</prompt>
							<group>2</group>
							<precond>
									<language>perl</language>
									<code>!$user_conffile &amp;&amp; $is_partitioned</code>
							</precond>
							<format>
								<language>perl</language>
								<code>($value) ? "subsetspecificrates = $value\\n" : ""</code>
							</format>
							<vdef>
								<value>0</value>
							</vdef>
							<paramfile>garli.conf</paramfile>
							<comment>
								<value>The parameter subsetspecificrates means to infer overall rate multipliers for each data subset.
This is equivalent to *prset ratepr=variable* in MrBayes So, using this interface you can make the following settings:
subsetspecificrates = 0  single model, one set of branch lengths (equivalent to non-partitioned analysis)  
subsetspecificrates = 1  single model, different subset rates (like site-specific rates model in PAUP*)  
								</value>
							</comment>
						</attributes>			
					</parameter>
		</parameters>
	</paragraph>
</parameter>
<!-- End Partition Configuration -->

<!-- Run Configuration Paragraph -->
<!-- ======================================================================================== -->
<parameter type="Paragraph">
	<paragraph>
		<name>run_configuration</name>
		<prompt>Run Configuration</prompt>
		<parameters>
<!-- streefname (random, stepwise, <filename>)  Specifies where the starting tree topology and/or model parameters will come from.  The tree topology may be a completely random topology (constraints will be enforced), a tree provided by the user in a file, or a tree generated by the program using a fast ML stepwise-addition algorithm (see attachmentspertaxon below). Starting or fixed model parameter values may also be provided in the specified file, with or without a tree topology.   Some notes on starting trees/models: 
 	New in version 0.96: Nexus starting trees are allowed. 
 	New in version 0.96: Specified starting trees may have polytomies, which will be
arbitrarily resolved before the run begins.

 	Starting tree formats: 
 	Plain newick tree string (with taxon numbers or names, with or without branch lengths) 
 	NEXUS trees block.  The trees block can appear in the same file as a NEXUS data or characters block that contains the alignment, although the same filename should then be specified on both the datafname and streefname lines. 
 
 	If multiple trees appear in the specified file and multiple search replicates are specified (see searchreps setting), 
	then the first tree is used in the first replicate, the second in the second replicate, etc. 

In terms of starting tree options, I would go with streefname = stepwise instead of random.  This will give it a much better starting point, and especially on large datasets this can both reduce runtimes and improve results.  If you do that you'll also need to add attachmentspertaxon to the general section of the config.  I'd suggest a default value of 50.  
Previously the portal was providing a parsimony starting tree to GARLI generated by PAUP (I think), in which case streefname would be the name of that file.  Providing the PAUP tree was probably a good idea with version 0.951, but it may not be necessary because GARLI can now create its own likelihood stepwise addition trees.  Providing the user the option to go either way might be good.-->

<!-- Add line setting streefname=[starting.txt | random] in garli.conf -->								
<!-- tree from userdata, now in starting.txt -->
<!-- general section 2 -->
								<parameter ismandatory="1" type="Excl">
									<name>streefname_choose</name>
									<attributes>
										<prompt>Specify where the starting tree topology comes from (streefname)</prompt>
										<precond>
											<language>perl</language>
											<code>!$user_conffile</code>
										</precond>
										<vdef>
											<value>stepwise</value>
										</vdef>
										<vlist>
											<value>random</value>
											<label>random</label>
											<value>stepwise</value>
											<label>stepwise</label>
											<value>upload</value>
											<label>upload</label>
										</vlist>
										<flist>
											<value>random</value>
											<code>"streefname = random\\n"</code>
											<value>stepwise</value>
											<code>"streefname = stepwise\\n"</code>
											<value>upload</value>
											<code>"streefname = starting.txt\\n"</code>
										</flist>
										<paramfile>garli.conf</paramfile>
										<group>2</group>
										<comment>
<value>streefname Specifies where the starting tree topology and/or model parameters will come from. The tree topology may be a completely random topology (constraints will be enforced), a tree provided by the user in
a file, or a tree generated by the program using a fast ML stepwise-addition algorithm (see attachmentspertaxon below). The author recommends stepwise over random. This will give it a much better starting point; on large
datasets this can both reduce runtimes and improve results.Starting or fixed model parameter values may also be provided in the specified file, with or without a tree topology.</value>

<value>Some notes on starting trees/models: Nexus starting trees are allowed. Specified starting trees may have polytomies, which will be arbitrarily resolved before the run begins. Allowed Starting tree formats: 
Plain newick tree string (with taxon numbers or names, with or without branch lengths) or NEXUS trees block. The trees block can appear in the same file as a NEXUS data or characters block that contains the
alignment, but it must specfied a second time in this box. If multiple trees appear in the specified file and multiple search replicates are specified (see searchreps setting), then the first tree is used in the first replicate
the second in the second replicate, etc.</value>

										</comment>
									</attributes>
								</parameter>
								
								<parameter type="InFile">
									<name>streefname_userdata</name> 
									<attributes>
<!-- I think this parameter will work for an upload even if the user supplies garli.conf as long as the line streefname = starting.txt appears in the garli.conf file-->
										<precond>
											<language>perl</language>
											<code>$streefname_choose ne "random" &amp;&amp; $streefname_choose ne "stepwise" </code>
										</precond>
										<paramfile>garli.conf</paramfile>
										<group>2</group>
										<prompt>Choose a Starting Tree (streefname file)</prompt>
										<filenames>starting.txt</filenames>
										<warns>
											<warn>
												<message>In order to work, your garli.conf file must contain the one line streefname = starting.txt in the [general] section of garli.conf. No other streefname = lines should be present.</message>
												<language>perl</language>
												<code>($userconffilethere || $userconffilehere) &amp;&amp; $streefname_choose eq "upload" </code>
											</warn>
										</warns>
										<comment>
<value>Specify the name of the file containing the population starting conditions. Starting model parameters and/or a starting
	topology may be specified. If both model and topology are specified, the model must come first, and both must appear on the
	same line of the file. Each model parameter is specified by a letter representing the parameter type, followed by the value
	or values assigned. Thus r 1.4 3.4 0.55 1.09 4.94 b 0.297 0.185 0.213 0.305 a 0.66 p 0.43 ((((((140:..etc specifies starting
	values for the rate matrix (in the order AC, AG, AT, CG, CT), base frequencies (in the order A, C, G, T), alpha shape of the
	gamma rate-heterogeneity distribution and the proportion of invariable sites, and is followed by the starting tree. If starting
	parameters are not specified, the base frequencies begin at their empirical values, the proportion of invariable sites begins
	at 20% of the observed proportion of invariants sites, alpha starts at 0.5 and the rate matrix starts at values equivalent to
	a kappa value of 5.0. If included, the tree specification should appear in Newick format (parenthetical notation), with the
	taxa represented by either their name or their number in the data matrix (starting at 1). Starting branch lengths on the tree
	are optional. The sample dataset included with the program comes with an example of a starting model/tree file. As of version 0.95,
	various models may be specified and various parameter values fixed. Any model parameters that appear in the starting condition
	file must correspond to the model chosen in the config file. In addition, any parameters specified as fixed in the config file
	must have their values specified here. If no file is specified, a random start tree and default model parameters will be inferred.</value>
										</comment>
									</attributes>
								</parameter>
								
<!-- New Param for V 0.96. attachmentspertaxon (1 to infinity, 50)  The number of attachment branches evaluated for each taxon to be added to the tree during the creation of an ML stepwise-addition starting tree. 
Briefly, stepwise addition is an algorithm used to make a tree, and involves adding taxa in a random order to a growing tree.  For each taxon to be added, a number of randomly chosen attachment branches are tried
and scored, and then the best scoring one is chosen as the location of that taxon.  The attachmentspertaxon setting controls how many attachment points are evaluated for each taxon to be added.  A value of one
is equivalent to a completely random tree (only one randomly chosen location is evaluated).  A value of greater than 2 times the number of taxa in the dataset means that all attachment points will be evaluated for each
taxon, and will result in very good starting trees (but may take a while on large datasets).  Even fairly small values (< 10) can result in starting trees that are much, much better than random, but still fairly different from
one another. -->
<!--in section 2-->
								<parameter ismandatory="1" type="Integer">
									<name>attachments_val</name>
									<attributes>
										<prompt>Specify the number of attachment branches evaluated for each taxon (attachmentspertaxon)</prompt>
										<precond>
											<language>perl</language>
											<code>!$user_conffile &amp;&amp; $streefname_choose eq "stepwise"</code>
										</precond>
										<vdef>
											<value>50</value>
										</vdef>
										<format>
											<language>perl</language>
											<code>"attachmentspertaxon=$value\\n"</code>
										</format>
										<paramfile>garli.conf</paramfile>
										<group>2</group>
										<comment>
<value>New Param for V 0.96. The number of attachment branches evaluated for each taxon to be added to the tree during the creation of an ML stepwise-addition starting tree.  Briefly, stepwise addition is an algorithm used to make a tree, and involves adding taxa in a random order to a growing tree.  For each taxon to be added, a number of randomly chosen attachment branches are tried and scored, and then the best scoring one is chosen as the location of that taxon.  The attachmentspertaxon setting controls how many attachment points are evaluated for each taxon to be added.  A value of one is equivalent to a completely random tree (only one randomly chosen location is evaluated).  A value of greater than 2 times the number of taxa in the dataset means that all attachment points will be evaluated for each taxon, and will result in very good starting trees (but may take a while on large datasets).  Even fairly small values (less than 10) can result in starting trees that are much, much better than random, but still fairly different from one another. </value>
										</comment>
									</attributes>
								</parameter>
								
<!--searchreps (1 to infinity, 2)  The number of independent search replicates to perform during a program execution.  You should always either do multiple search replicates or multiple program executions with any dataset
to get a feel for whether you are getting consistent results, which suggests that the program is doing a decent job of searching.  Note that if this is greater than 1 and you are performing a bootstrap analysis, this is the number
of search replicates to be done per bootstrap replicate.  That can increase the chance of finding the best tree per bootstrap replicate, but will also increase bootstrap runtimes enormously. -->

<!--section 2 general-->	
<!-- If bootstrapreps = 0, searchreps=1 -->
<!-- If bootstrapreps != 0, set bootstrapreps=1. -->
<!-- we are going to split this up, because when a user uploads a file, we will not be writing to garli.conf -->						
							<parameter ismandatory="1"  issimple="1" type="Integer">
									<name>searchreps_value</name>
									<attributes>
										<prompt>Specify the number of independent search replicates to perform during a program execution.(searchreps)</prompt>
										<vdef>
											<value>2</value>
										</vdef>
										<ctrls>
											<ctrl>
												<message>The value for this parameter cannot be less than 1</message>
												<language>perl</language>
												<code>$searchreps_value &lt; 1</code>
											</ctrl>
											<ctrl>
												<message>You must specify multiple searchreps and/or multiple bootstrapreps to do a parallel run on teragrid.</message>
												<language>perl</language>
												<code>$searchreps_value &lt; 2 &amp;&amp; $bootstrapreps &lt; 2</code>
											</ctrl>
											<ctrl>
												<message>Sorry, the number of searchreps must be no more than 8.</message>
												<language>perl</language>
												<code>$searchreps_value &gt; 8</code>
											</ctrl>
											<ctrl>
												<message>Please enter an integer value for search repetitions</message>
												<language>perl</language>
												<code>!defined $searchreps_value</code>
											</ctrl>
										</ctrls> 
										<comment>
<value>The number of independent search replicates to perform during a program execution.  You should always either do multiple search replicates or multiple program executions with any dataset to get a feel for whether you are getting consistent results, which suggests that the program is doing a decent job of searching.  Note that if this is greater than 1 and you are performing a bootstrap analysis, this is the number of search replicates to be done per bootstrap replicate.  That can increase the chance of finding the best tree per bootstrap replicate, but will also increase bootstrap runtimes enormously.  When you specify multiple searchreps or multiple bootstraps, we will automatically run garli multiple times in parallel.</value>
										</comment>
									</attributes>
								</parameter>

<!-- a little hidden string adds the values to garli.conf if there is no upload -->								
								<parameter ismandatory="1" ishidden="1" type="String">
									<name>searchreps_value_no_upload</name>
									<attributes>
										<prompt>Specify the number of independent search replicates to perform during a program execution.(searchreps)</prompt>
										<precond>
											<language>perl</language>
											<code>!$user_conffile</code>
										</precond>
										<format>
											<language>perl</language>
											<code>($bootstrapreps &gt; 1) ? "searchreps=$searchreps_value\\n" : "searchreps=1\\n"</code>
										</format>
										<paramfile>garli.conf</paramfile>
										<group>2</group>
									</attributes>
								</parameter>
								
<!-- we are going to split this up, because when a user uploads a garli.conf file, we will not be writing to garli.conf -->
								<parameter ismandatory="1" issimple="1" type="Integer">
									<name>bootstrapreps</name> 
									<attributes>
										<prompt>Bootstrap Repetitions (-bootstrapreps)</prompt>
										<precond>
											<language>perl</language>
											<code>!$inferinternalstateprobs_g</code>
										</precond>
										<vdef>
											<value>0</value>
										</vdef>
										<ctrls>
											<ctrl>
												<message>Bootstrap Repititions must be 0 or an integer 2 or greater for parallel runs on teragrid.</message>
												<language>perl</language>
												<code>$value &lt; 0 || $value ==  1</code>
											</ctrl> 
											<!-- added by mamiller to control for the number of processes launched -->
											<ctrl>
												<message>Sorry, the number of bootstrapreps must be no more than 100.</message>
												<language>perl</language>
												<code>$bootstrapreps &gt; 100 </code>
											</ctrl>
											<ctrl>
												<message>Sorry, the number of bootstrap reps times the number of searchreps must be no more than 100. Please decrease the number of searchreps, and/or the number bootstrapreps to meet this criterion. You may make addtional identical runs, if you require more bootstrapreps.</message>
												<language>perl</language>
												<code>$searchreps_value * $bootstrapreps &gt; 100 </code>
											</ctrl>
											<ctrl>
												<message>Please enter an integer value for Bootstrap Repititions</message>
												<language>perl</language>
												<code>!defined $bootstrapreps</code>
											</ctrl>
										</ctrls>									
										<comment>
<value>The number of bootstrap reps to perform. If the value entered is 0,normal searching will be performed. If a value greater than 0 is entered, 
normal searching will not be performed. The resulting bootstrap trees (one per rep) will be output to a file named ofprefix.boot.tre. 
To obtain the bootstrap proportions they will then need to be read into PAUP* or a similar program to obtain a majority rule consensus.  
Note that it is probably safe to reduce the strictness of the termination conditions during bootstrapping (perhaps halve 
genthreshfortopoterm), which will greatly speed up the bootstrapping process with negligible effects on the results.   
When multiple bootstrapreps or multiple searchreps are specified we will automatically run garli multiple times in parallel.
</value>
										</comment>
									</attributes>
								</parameter>

<!--- If bootstrapreps != 0, set nruns=bootstrapreps and bootstrapreps=1; this controls for when there is galri.conf file uploaded -->
								<parameter type="String" ishidden="1">
									<name>hidden_group4_bootstrap</name>
									<attributes>
										<paramfile>garli.conf</paramfile>
										<precond>
											<language>perl</language>
											<code>!$user_conffile</code>
										</precond>
										<group>4</group>
										<format>
											<language>perl</language>
											<code>
												($bootstrapreps  &gt; 1) ? "bootstrapreps=1\\n" : "bootstrapreps=$bootstrapreps\\n" 
											</code>
										</format>
									</attributes>
								</parameter>
								
<!-- outgroup (outgroup taxa numbers, separated by spaces) This option allow for orienting the tree topologies in a consistent way when they are written to file.  Note that this has NO effect whatsoever on the actual inference and the specified outgroup is NOT constrained to be present in the inferred trees.  If multiple outgroup taxa are specified and they do not form a monophyletic group, this setting will be ignored.  If you specify a single outgroup taxon it will always be present, and the tree will always be consistently oriented.  To specify an outgroup consisting of taxa 1, 3 and 5 the format is this: outgroup = 1 3 5   group 2 -->
								<parameter type="String">
									<name>outgroup_tax</name> 
									<attributes>
										<paramfile>garli.conf</paramfile>
										<group>2</group>
										<prompt>Outgroup taxa numbers, separated by spaces (outgroup)</prompt>
										<precond>
											<language>perl</language>
											<code>!$user_conffile</code>
										</precond>
										<format>
											<language>perl</language>
											<code>"outgroup = $value\\n"</code>
										</format>
										<comment>
<value>The outgroup option allow for orienting tree topologies in a consistent way when they are written to file.  Note that this has NO effect whatsoever on the actual inference and the specified outgroup is NOT constrained to be present in the inferred trees.  If multiple outgroup taxa are specified and they do not form a monophyletic group, this setting will be ignored.  If you specify a single outgroup taxon it will always be present, and the tree will always be consistently oriented.  To specify an outgroup consisting of taxa 1, 3 and 5 the format is this: outgroup = 1 3 5</value>
</comment>
									</attributes>
								</parameter>
<!-- One undocumented (and semi-experimental) feature that you might want to add would be the "collapsebranches" boolean entry in the general section.  
This tells the program to collapse minimum length branches (effectively zero length) branch upon output of the final trees.  
Otherwise the final trees are always fully bifurcating, even when returning a polytomy makes more sense.  
For some datasets this can make a big difference because final trees may in fact be identical with those branches collapsed, 
but they will appear different if they are compared on the basis of the topology alone (for example, when calculating tree to tree distances).  
If simply visualized with the branches proportional to their lengths the trees will look identical because the tiny branches will be indistinguishable from a polytomy. 
This feature can be particularly important in the case of bootstrapping, where you don't really want branches that effectively don't exist (and are an arbitrary resolution of a polytomy)
to be counted in the support values.  The only downside of this setting is that GARLI's test at the end of a run for whether the trees from each replicates are identical may be wrong 
if branches are collapsed.  I don't know if you use or return that information anyway (the .screen.log file), so it may not be a big deal.-->
<!-- from garli 1.0 manual:
collapsebranches = (0 or 1, 1) Before version 1.0, all trees that are returned were fully resolved. This is true even if the maximum-likelihood estimate of some internal branch lengths
are effectively zero (or GARLI's minimum, which is 1e-8). In such cases, collapsing the branch into a polytomy would be a better representation. Note that GARLI will never return a
tree with an actual branch length of zero, but rather with its minimum value of 1.0e-8. The drawback of always returning fully resolved trees is that what is effectively a polytomy
can be resolved in three ways, and different independent searches may randomly return one of those resolutions. Thus, if you compare the trees by
topology only, they will look different. If you pay attention to the branch lengths and likelihood scores of the trees it will be apparent that they are effectively the same. 

I think that collapsing of branches is particularly important when bootstrapping, since no support should be given to a branch that doesn't really exist, 
i.e., that is a random resolution of a polytomy. Collapsing is also good when calculating tree to tree distances such as the symmetric tree distance, for 
example when calculating phylogenetic error to a known target tree. Zero-length branches would add to the distances (~error) although they really should not.  -->

								<parameter type="Switch">
									<name>collapsebranches_g</name> 
									<attributes>
										<prompt>Collapse minimum length branches (effectively zero length) branch upon output of the final tree</prompt>
										<vdef>
											<value>0</value>
										</vdef>
										<precond>
											<language>perl</language>
											<code>!$user_conffile &amp;&amp; $bootstrapreps == 0</code>
										</precond>
									</attributes>
								</parameter>
								
								<parameter ishidden="1" type="String">
									<name>collapsebranches</name> 
									<attributes>
										<paramfile>garli.conf</paramfile>
										<precond>
											<language>perl</language>
											<code>!$user_conffile &amp;&amp; $collapsebranches_g</code>
										</precond>
										<group>2</group>
										<format>
											<language>perl</language>
											<code>"collapsebranches = $collapsebranches_g\\n" </code>
										</format>
										<comment>
											<value>ollapsebranches = (0 or 1, 1) Before version 1.0, all trees that are returned were fully resolved. This is true even if the maximum-likelihood estimate of some internal branch lengths
are effectively zero (or GARLI's minimum, which is 1e-8). In such cases, collapsing the branch into a polytomy would be a better representation. Note that GARLI will never return a
tree with an actual branch length of zero, but rather with its minimum value of 1.0e-8. The drawback of always returning fully resolved trees is that what is effectively a polytomy
can be resolved in three ways, and different independent searches may randomly return one of those resolutions. Thus, if you compare the trees by
topology only, they will look different. If you pay attention to the branch lengths and likelihood scores of the trees it will be apparent that they are effectively the same. 
I think that collapsing of branches is particularly important when bootstrapping, since no support should be given to a branch that doesn't really exist, 
i.e., that is a random resolution of a polytomy. Collapsing is also good when calculating tree to tree distances such as the symmetric tree distance, for 
example when calculating phylogenetic error to a known target tree. Zero-length branches would add to the distances (~error) although they really should not.</value>
										</comment>
									</attributes>
								</parameter>
<!-- try to add the collapse branch parameter -->	
							
<!--constraint file group 2-->
								<parameter type="InFile" issimple="1">
									<name>constraintfile_control</name> 
									<attributes>
										<group>2</group>
										<prompt>Choose a Constraint File in Newick Format (constraintfile)</prompt>
										<filenames>constraint.txt</filenames>
										<warns>
											<warn>
												<message>To use this file correctly, you must also add the line constraintfile = constraint.txt to the [General] section of the garli.conf file, and remove any other lines containing constraintfile = </message>
												<language>perl</language>
												<code>$userconffilethere &amp;&amp; defined $constraintfile_control</code>
											</warn>
										</warns>
										<comment>
<value>The constraint file contains any topology constraint specifications, or none if there are no constraints. With Version 0.96, backbone constraints can be uploaded. A backbone constraint is the same as
any other constraint file, but not all taxa need be represented. Format: Consider a dataset of 8 taxa, in which your constraint consists of grouping taxa 1, 3 and 5. You may specify either positive constraints 
(inferred tree MUST contain constrained group) or negative constraints (also called converse constraints, inferred tree CANNOT contain constrained group). These are specified with either a + or a - at the beginning
of the constraint specification, for positive and negative constraints, respectively. For a positive constraint on a grouping of taxa 1, 3 and 5: +((1,3,5), 2, 4, 6, 7, 8); For a negative constraint on a grouping on taxa 1, 3 and 5:
-((1,3,5), 2, 4, 6, 7, 8); (Note that there are many other equivalent parenthetical representations of this constraint.) GARLI also accepts another constraint format that may be easier to use in some cases. This involves
specifying a single branch to be constrained with a string of * (asterisk) and . (period) characters, with one character per taxon. Each taxon specified with a * falls on one side of the constrained branch, and all those 
specified with a . fall on the other. This should be familiar to anyone who has looked at PAUP* bootstrap output. With this format, a positive constraint on a grouping of taxa 1, 3 and 5 would look like this: +*.*.*... or alternatively 
like this: +.*.*.***
With this format each line only designates a single branch, so multiple constrained branches may be specified as multiple lines in the file.</value>
</comment>
									</attributes>
								</parameter>
								
	<!--these values are loaded in the param above-->
								<parameter type="String" ishidden="1">
									<name>constraintfile</name>
									<attributes>
										<group>2</group>
										<paramfile>garli.conf</paramfile>
										<precond>
											<language>perl</language>
											<code>!$user_conffile</code>
										</precond>
										<format>
											<language>perl</language>
											<code>
												(defined $constraintfile_control) ? "constraintfile = constraint.txt\\n" :
													"constraintfile = none\\n"
											</code>
										</format>
									</attributes>
								</parameter>
							</parameters>

						</paragraph>
					</parameter> 
<!-- End Configure Run Paragraph-->

<!-- Initialization -->
<!-- ======================================================================================== -->
	<parameter type="Paragraph">
		<paragraph>
		<name>model_initialization</name>
			<prompt>Initialization</prompt>
				<parameters>

								<parameter type="String"  ishidden="1">
									<name>model_initialization_hidden</name> 
									<attributes>
										<paramfile>garli.conf</paramfile>
										<precond>
											<language>perl</language>
											<code>!$user_conffile</code>
										</precond>
										<group>2</group>
										<format>
											<language>perl</language>
											<code> 
												"refinestart = $refinestart\\n" .
												"randseed = $randseed\\n" 
											</code>
										</format>
									</attributes>
								</parameter>
								
<!--these values are loaded in the param above-->
								<parameter type="Switch">
									<name>refinestart</name> 
									<attributes>
										<prompt>Perform Initial Rough Optimization (refinestart)</prompt>
										<precond>
											<language>perl</language>
											<code>!$user_conffile</code>
										</precond>
										<vdef>
											<value>1</value>
										</vdef>
										<comment>
<value>Specifies whether some initial rough optimization is performed on the starting branch lengths and alpha parameter. This is always recommended. </value>
										</comment>
									</attributes>
								</parameter>

<!--these values are loaded in the param above-->
								<parameter type="Integer">
									<name>randseed</name> 
									<attributes>
										<prompt>Random Seed ( -1 means it will be chosen for you)</prompt>
										<precond>
											<language>perl</language>
											<code>!$user_conffile</code>
										</precond>
										<vdef>
											<value>-1</value>
										</vdef>
										<comment>
<value>The random number seed used by the random number generator. Specify -1 to have a seed chosen for you.
Specifying the same seed number in multiple runs will result in exactly identical runs, if all other parameters are also identical.</value>
										</comment>
									</attributes>
								</parameter>

							</parameters>
						</paragraph>
					</parameter> 
<!--  End Initialization Paragraph-->
				
<!-- Model -->		
<!-- ==================================================================================================== -->
		<parameter type="Paragraph">
			<paragraph>
				<name>model</name>
				<prompt>Model Parameters</prompt>
				<parameters>

<!--datatype (nucleotide, aminoacid, codon-aminoacid, codon)  The type of data and model that is to be used during tree inference.  The codon-aminoacid datatype means that the data will be supplied as a nucleotide alignment, 
but will be internally translated and analyzed using an amino acid model. The codon and codon-aminoacid datatypes require nucleotide sequence that is aligned in the correct reading frame. 
In other words, all gaps in the alignment should be a multiple of 3 in length, and the alignment should start at the first position of a codon.  If the alignment has extra columns at the start, 
middle or end, they should be removed or excluded with a Nexus exset (see the FAQ for an example of exset usage).  The correct geneticcode must also be set.  
-->
					<parameter ismandatory="1" type="Excl">
						<name>datatype_value</name>
						<attributes>
							<prompt>The type of data (datatype)</prompt>
							<precond>
								<language>perl</language>
								<code>!$user_conffile</code>
							</precond>
							<vdef>
								<value>nucleotide</value>
							</vdef>
							<vlist>
								<value>nucleotide</value>
								<label>nucleotide</label>
								<value>aminoacid</value>
								<label>amino acid</label>
								<value>codon-aminoacid</value>
								<label>codon-aminoacid</label>
								<value>codon</value>
								<label>codon</label>
							</vlist>
							<flist>
								<value>nucleotide</value>
								<code>"datatype = nucleotide\\n"</code>
								<value>aminoacid</value>
								<code>"datatype = aminoacid\\n"</code>
								<value>codon-aminoacid</value>
								<code>"datatype = codon-aminoacid\\n"</code>
								<value>codon</value>
								<code>"datatype = codon\\n"</code>
							</flist>
							<paramfile>garli.conf</paramfile>
							<group>2</group>
							<comment>
<value>The codon-aminoacid datatype means that the data will be supplied as a nucleotide alignment, but will be internally translated and analyzed using an amino acid model. The codon and codon-aminoacid datatypes require nucleotide sequence that is aligned in the correct reading frame. In other words, all gaps in the alignment should be a multiple of 3 in length, and the alignment should start at the first position of a codon.  If the alignment has extra columns at the start, middle or end, they should be removed or excluded with a Nexus exset (see the FAQ for an example of exset usage).  The correct geneticcode must also be set.</value>
							</comment>
						</attributes>
					</parameter>

<!--One general point is that the defaults for datatype = codon-aminoacid should be exactly the same as aminoacid.The analyses are exactly the same, the translation from codons to amino acids is just
handled internally by GARLI in the case of codon-aminoacid.  The only difference in settings is that the genetic code must be specified for codon-aminoacid.  In particular, this means that a number of extra
settings need to be added to the codon-aminoacid set:
invariantsites
numratecats
ratehetmodel -->
<!--geneticcode (standard, vertmito, invertmito)  The genetic code to be used in translating codons into amino acids. -->					
					<parameter ismandatory="1" type="Excl">
						<name>geneticcode_value</name>
						<attributes>
							<prompt>Select the Genetic Code (geneticcode)</prompt>
								<precond>
									<language>perl</language>
									<code>!$user_conffile &amp;&amp; ($datatype_value eq "codon" || $datatype_value eq "codon-aminoacid")</code>
									</precond>
							<format>
								<language>perl</language>
								<code>"geneticcode = $value\\n"</code>
							</format>
							<vlist>
								<value>standard</value>
								<label>Standard</label>
								<value>vertmito</value>
								<label>Vertebrate Mitochondria</label>
								<value>invertmito</value>
								<label>Invertebrate Mitochondria</label>
							</vlist>
							<vdef>
								<value>standard</value>
							</vdef>
							<paramfile>garli.conf</paramfile>
							<group>2</group>
							<comment>
<value>The codon-aminoacid datatype means that the data will be supplied as a nucleotide alignment, but will be internally translated and analyzed using an amino acid model. The codon and codon-aminoacid datatypes require nucleotide sequence that is aligned in the correct reading frame. In other words, all gaps in the alignment should be a multiple of 3 in length, and the alignment should start at the first position of a codon.  If the alignment has extra columns at the start, middle or end, they should be removed or excluded with a Nexus exset (see the FAQ for an example of exset usage).  The correct geneticcode must also be set. </value>
							</comment>
						</attributes>
					</parameter>

					<!-- Nucleotide Model -->
					<!-- ======================================================================================== -->

					<parameter type="Paragraph">
						<paragraph>						
							<name>model_nucleotide</name>
							<prompt>Nucleotide Model</prompt>
							<comment>
								<value>JC (Jukes-Cantor model): Rate Matrix = 1 rate, Base Frequencies = equal</value>
								<value>K2P (Kimura 2-Parameter model): Rate Matrix = 2 rate, Base Frequencies = equal</value>
								<value>F81 (Felsenstein 1981 model): Rate Matrix = 1 rate, Base Frequencies = estimate</value>
								<value>HKY (Hasegawa, Kishino and Yano model): Rate Matrix = 2 rate, Base Frequencies = estimate</value>
								<value>GTR (General Time-Reversible model): Rate Matrix = 6 rate, Base Frequencies = estimate</value>
							</comment>

							<parameters>
							
<!--	 "general" section ratematrix = 6rate -->
								<parameter type="Excl" ismandatory="1">
									<name>d_ratematrix</name> 
									<attributes>
										<paramfile>garli.conf</paramfile>
										<prompt>Rate Matrix (ratematrix)</prompt>
										<precond>
											<language>perl</language>
											<code>!$user_conffile &amp;&amp; $datatype_value eq "nucleotide"</code>
										</precond>
										<vlist>
											<value>1rate</value>
											<label>All Rates Equal (1rate)</label>
											<value>2rate</value>
											<label>HKY (2rate)</label>
											<value>6rate</value>
											<label>General time-reversible (6 rate)</label>
											<value>fixed</value>
											<label>fixed rate</label>
											<value>custom_string</value>
											<label>User Specified</label>
										</vlist>
										<flist>
											<value>1rate</value>
											<code>"ratematrix = $value\\n"</code>
											<value>2rate</value>
											<code>"ratematrix = $value\\n"</code>
											<value>6rate</value>
											<code>"ratematrix = $value\\n"</code>
											<value>fixed</value>
											<code>"ratematrix = $value\\n"</code>
											<value>custom_string</value>
											<code>"ratematrix = ($ACsubrates $AGsubrates $ATsubrates $CGsubrates $CTsubrates $GTsubrates)\\n"</code> 
										</flist>
										<vdef><value>6rate</value></vdef>
										<paramfile>garli.conf</paramfile>
										<group>2</group>
										<comment>
<value>Parameters for any submodel of the GTR model may be estimated.  The format for specifying this is very similar to that used in the rclass setting of PAUP*.  Within parentheses, six letters are specified, with spaces between them.  The six letters represent the rates of substitution between the six pairs of nucleotides, with the order being A-C, A-G, A-T, C-G, C-T and G-T. Letters within the parentheses that are the same mean that a single parameter is shared by multiple nucleotide pairs.  For example, ratematrix = (a b a a b a) would specify the HKY 2-rate model (equivalent to ratematrix = 2rate).  This entry, ratematrix = (a b c c b a) would specify 3 estimated rates of substitution, with one rate shared by A-C and G-T substitutions, another rate shared by A-G and C-T substitutions, and the final rate shared by A-T and C-G substitutions.</value>
										</comment>
									</attributes>
								</parameter>

<!-- the six individual user-specified rates-->
								<parameter type="String">
									<name>ACsubrates</name> 
									<attributes>
										<prompt>User specified AC substitution rates (custom ratematrix)</prompt>
										<precond>
											<language>perl</language>
											<code>$datatype_value eq "nucleotide" &amp;&amp; $d_ratematrix eq "custom_string"</code>
										</precond>
										<format>
											<language>perl</language>
											<code>""</code>
										</format>
									</attributes>
								</parameter>
							
								<parameter type="String">
									<name>AGsubrates</name> 
									<attributes>
										<prompt>User specified AG substitution rates (custom ratematrix)</prompt>
										<precond>
											<language>perl</language>
											<code>$datatype_value eq "nucleotide" &amp;&amp; $d_ratematrix eq "custom_string"</code>
										</precond>
										<format>
											<language>perl</language>
											<code>""</code>
										</format>
									</attributes>
								</parameter>
								
								<parameter type="String">
									<name>ATsubrates</name> 
									<attributes>
										<prompt>User specified AT substitution rates (custom ratematrix)</prompt>
										<precond>
											<language>perl</language>
											<code>$datatype_value eq "nucleotide" &amp;&amp; $d_ratematrix eq "custom_string"</code>
										</precond>
										<format>
											<language>perl</language>
											<code>""</code>
										</format>
									</attributes>
								</parameter>
								
								<parameter type="String">
									<name>CGsubrates</name> 
									<attributes>
										<prompt>User specified CG substitution rates (custom ratematrix)</prompt>
										<precond>
											<language>perl</language>
											<code>$datatype_value eq "nucleotide" &amp;&amp; $d_ratematrix eq "custom_string"</code>
										</precond>
										<format>
											<language>perl</language>
											<code>""</code>
										</format>
									</attributes>
								</parameter>
								
								<parameter type="String">
									<name>CTsubrates</name> 
									<attributes>
										<prompt>User specified CT subsitution rates (custom ratematrix)</prompt>
										<precond>
											<language>perl</language>
											<code>$datatype_value eq "nucleotide" &amp;&amp; $d_ratematrix eq "custom_string"</code>
										</precond>
										<format>
											<language>perl</language>
											<code>""</code>
										</format>
									</attributes>
								</parameter>
								
								<parameter type="String">
									<name>GTsubrates</name> 
									<attributes>
										<prompt>User specified GT substitution rates (custom ratematrix)</prompt>
										<precond>
											<language>perl</language>
											<code>$datatype_value eq "nucleotide" &amp;&amp; $d_ratematrix eq "custom_string"</code>
										</precond>
										<format>
											<language>perl</language>
											<code>""</code>
										</format>
									</attributes>
								</parameter>

<!-- end of the six individual user-specified rates-->
<!---general" section statefrequencies = estimate	-->

								<parameter type="Excl"  ismandatory="1">
									<name>d_statefrequencies</name> 
									<attributes>
										<paramfile>garli.conf</paramfile>
										<prompt>Base Frequencies (statefrequencies)</prompt>
										<precond>
											<language>perl</language>
											<code>!$user_conffile &amp;&amp; $datatype_value eq "nucleotide"</code>
										</precond>
										<format>
											<language>perl</language>
											<code>"statefrequencies = $value\\n" </code>
										</format>
										<vlist>
											<value>equal</value>
											<label>equal</label>
											<value>empirical</value>
											<label>empirical</label>
											<value>estimate</value>
											<label>estimate</label>
											<value>fixed</value>
											<label>fixed</label>
										</vlist>
										<vdef><value>estimate</value></vdef>
										<group>2</group>
									</attributes>
								</parameter>
								
<!-- general section  invariantsites = estimate -->
								<parameter type="Excl"  ismandatory="1">
									<name>d_invariantsites</name> 
									<attributes>
										<paramfile>garli.conf</paramfile>
										<prompt>Proportion of invariant sites (invariantsites)</prompt>
										<precond>
											<language>perl</language>
											<code>!$user_conffile &amp;&amp; $datatype_value eq "nucleotide"</code>
										</precond>
										<format>
											<language>perl</language>
											<code>"invariantsites = $value\\n" </code>
										</format>
										<vlist>
											<value>none</value>
											<label>none</label>
											<value>estimate</value>
											<label>estimate</label>
										</vlist>
										<vdef><value>estimate</value></vdef>
										<group>2</group>
										<comment>
<value>Specifies whether a parameter representing the proportion of sites that are unable to change (i.e. have a substitution rate of zero) will be included.  This is typically referred to as invariant sites, but would better be termed invariable sites.</value>
										</comment>
									</attributes>
								</parameter>

<!-- general section ratehetmodel = gamma  -->
								<parameter type="Excl"  ismandatory="1">
									<name>d_ratehetmodel</name> 
									<attributes>
										<paramfile>garli.conf</paramfile>
										<prompt>The model of rate heterogeneity (ratehetmodel)</prompt>
										<precond>
											<language>perl</language>
											<code>!$user_conffile &amp;&amp; $datatype_value eq "nucleotide"</code>
										</precond>
										<format>
											<language>perl</language>
											<code>
											($d_ratehetmodel eq "none") ? "numratecats = 1\\nratehetmodel = $value\\n" : 
												"numratecats = $d_numratecats\\nratehetmodel = $value\\n"
											</code>
										</format>
										<vlist>
											<value>none</value>
											<label>Equal Rates For All Sites (none)</label>
											<value>gamma</value>
											<label>Gamma Distribution (gamma)</label>
										</vlist>
										<vdef>
											<value>gamma</value>
										</vdef>
										<group>2</group>
										<comment>
<value>The model of rate heterogeneity assumed. gammafixed requires that the alpha shape parameter is provided, and a setting of gamma estimates it.</value>
										</comment>
									</attributes>
								</parameter>
								
<!-- general section numratecats = 4  -->
								<parameter type="Integer">
									<name>d_numratecats</name> 
									<attributes>
										<prompt>Number of rate categories (numratecats)</prompt>
										<precond>
											<language>perl</language>
											<code>!$user_conffile &amp;&amp; $datatype_value eq "nucleotide" &amp;&amp; $d_ratehetmodel eq "gamma"</code>
										</precond>
										<format>
											<language>perl</language>
											<code>"numratecats=$value\\n"</code>
										</format>
										<vdef>
											<value>4</value>
										</vdef>
										<ctrls>
											<ctrl>
												<message>:Number of rate categories: must be an integer between 1 and 20</message>
												<language>perl</language>
												<code>$d_numratecats &lt; 2 || $d_numratecats &gt; 20</code>
											</ctrl>
										</ctrls>
										<paramfile>garli.conf</paramfile>
										<group>2</group>
										<comment>
<value>The number of categories of variable rates (not including the invariant site class if it is being used). Must be set to 1 if ratehetmodel is set to none.  Note that runtimes and memory usage scale linearly with this setting.</value>
										</comment>
									</attributes>
								</parameter>

							</parameters>
						</paragraph>
					</parameter>
					<!-- Nucleotide Model Paragraph -->
					
					<!-- Protein Model: applies to protein datatype or protein:codon datatype -->
					<!-- ======================================================================================== -->
	<parameter type="Paragraph">
		<paragraph>					
			<name>model_protein</name>
			<prompt>Protein Model</prompt>
				<comment>
								<value>dayhoff 	Dayhoff, Schwartz and Orcutt. 1978 </value>
								<value>jones 	Jones, Taylor and Thornton (JTT), 1992 </value>
								<value>WAG 	Whelan and Goldman, 2001 </value>
								<value>mtREV 	Adachi and Hasegawa, 1996 </value>
								<value>mtmam 	Yang, Nielsen and Hasegawa. 1998 </value>
				</comment>
							
<!--For datatype = aminoacid or codon-aminoacid: Amino acid analyses are typically done using fixed rate matrices that have been estimated on large datasets and published. Typically the only model parameters that are estimated during tree inference relate to the rate heterogeneity distribution.  Each of the named matrices also has corresponding fixed amino acid frequencies, and a given matrix can either be used with those frequencies or with the amino acid frequencies observed in your dataset.  This second option is often denoted as +F in a model description, although in terms of the GARLI configuration settings this is referred to as empirical frequencies.  In GARLI the Dayhoff model would be specified by setting both the ratematrix and statefrequencies options to dayhoff.  The Dayhoff+F model would be specified by setting the ratematrix to dayhoff, and statefrequencies to empirical. The following named amino acid models are implemented:
ratematrix/statefrequencies.

dayhoff 	Dayhoff, Schwartz and Orcutt. 1978 
jones 	Jones, Taylor and Thornton (JTT), 1992 
WAG 	Whelan and Goldman, 2001 
mtREV 	Adachi and Hasegawa, 1996 
mtmam 	Yang, Nielsen and Hasegawa. 1998 

Note that most programs allow either the use of a named rate matrix and its corresponding state frequencies, or a named rate matrix and empirical frequencies. GARLI technically allows the mixing of different named matrices and equilibrium frequencies (for example, wag matrix with jones equilibrium frequencies), but this is not recommended. ratematrix (poisson, jones, dayhoff, wag, mtmam, mtrev)  The fixed amino acid rate matrix to use. You should use the matrix that gives the best likelihood, and could use a program like PROTTEST (very much like MODELTEST, but for amino acid models) to determine which fits best for your data. Poisson assumes a single rate of substitution between all amino acid pairs, and is a very poor model. -->

							<parameters>
								
<!--general section ratematrix -->						
								<parameter type="Excl" ismandatory="1">
									<name>p_ratematrix</name> 
									<attributes>
										<group>2</group>
										<prompt>Protein Rate Matrix (ratematrix)</prompt>
										<precond>
											<language>perl</language>
											<code>!$user_conffile &amp;&amp; ($datatype_value eq "aminoacid" || $datatype_value eq "codon-aminoacid")</code>
										</precond>
										<format>
											<language>perl</language>
											<code>"ratematrix = $value\\n" </code>
										</format>
										<vdef>
											<value>wag</value>
										</vdef>
<!---I would have the ratematrix for aminoacid and codon-aminoacid default to WAG.  The user should really be making a conscious choice about which to use, but (knowing users) they often just go with the defaults.  I don't think I've ever seen a dataset that actually statistically prefers dayhoff, and 95% of them seem to prefer either WAG or jones (JTT).-->		
										<vlist>
											<value>poisson</value>
											<label>Poisson</label>
											<value>jones</value>
											<label>Jones</label>
											<value>dayhoff</value>
											<label>Dayhoff</label>
											<value>wag</value>
											<label>WAG</label>
											<value>mtmam</value>
											<label>mtMAM</label>
											<value>mtrev</value>
											<label>mtREV</label>
										</vlist>
										<paramfile>garli.conf</paramfile>
										<comment>
<value>You should use the matrix that gives the best likelihood, and could use a program like PROTTEST (very much like MODELTEST, but for amino acid models) to determine which fits best for your data.  Poisson assumes a single rate of substitution between all amino acid pairs, and is a very poor model.</value>
										</comment>
									</attributes>
								</parameter>

<!-- general section statefrequencies -->
								<parameter type="Excl"  ismandatory="1">
									<name>p_statefrequencies</name> 
									<attributes>
										<paramfile>garli.conf</paramfile>
										<group>2</group>
										<prompt>Amino Acid Frequencies (statefequencies)</prompt>
										<precond>
											<language>perl</language>
											<code>!$user_conffile &amp;&amp; ($datatype_value eq "aminoacid" || $datatype_value eq "codon-aminoacid")</code>
										</precond>
										<format>
											<language>perl</language>
											<code>"statefrequencies = $value\\n" </code>
										</format>
										<vlist>
											<value>equal</value>
											<label>equal</label>
											<value>empirical</value>
											<label>empirical (+F)</label>
											<value>estimate</value>
											<label>estimate</label>
											<value>fixed</value>
											<label>fixed</label>
											<value>jones</value>
											<label>Jones</label>
											<value>dayhoff</value>
											<label>Dayhoff</label>
											<value>wag</value>
											<label>WAG</label>
											<value>mtmam</value>
											<label>mtMAM</label>
											<value>mtrev</value>
											<label>mtREV</label>
										</vlist>
										<vdef><value>empirical</value></vdef>
										<!---statefrequencies should be empirical for both aminoacid and codon-aminoacid-->
										<comment>
<value>Specifies how the equilibrium state frequencies of the 20 amino acids are treated. The empirical option fixes the frequencies at their observed proportions (when describing a model this is often termed +F).</value>
										</comment>
									</attributes>
								</parameter>
								
 

<!-- invariantsites = estimate general section 2 (none, estimate)
 
a number of extra settings need to be added to the codon-aminoacid set:

invariantsites (none, estimate, fixed)  Specifies whether a parameter representing the proportion of sites that are unable to change (i.e. have a substitution rate of zero) will be included. 
This is typically referred to as invariant sites, but would better be termed invariable sites. 

ratehetmodel ratehetmodel (none, gamma, gammafixed)  The model of rate heterogeneity assumed. gammafixed requires that the alpha shape parameter is provided, and a setting of gamma estimates it.

numratecats (1 to 20, 4)  The number of categories of variable rates (not including the invariant site class if it is being used).  Must be set to 1 if ratehetmodel is set to none.  Note that runtimes and memory usage scale linearly with this
setting
-->

									<parameter type="Excl"  ismandatory="1">
									<name>p_invariantsites</name> 
									<attributes>
										<paramfile>garli.conf</paramfile>
										<group>2</group>
										<prompt>Proportion of invariable sites (invariantsites)</prompt>
										<precond>
											<language>perl</language>
											<code>!$user_conffile &amp;&amp; ($datatype_value eq "aminoacid" || $datatype_value eq "codon-aminoacid")</code>
										</precond>
										<format>
											<language>perl</language>
											<code>"invariantsites = $value\\n" </code>
										</format>
										<vlist>
											<value>none</value>
											<label>none</label>
											<value>estimate</value>
											<label>estimate</label>
										</vlist>
										<vdef>
											<value>estimate</value>
										</vdef>
										<comment>
<value>Specifies whether a parameter representing the proportion of sites that are unable to change (i.e. have a substitution rate of zero) will be included.  This is typically referred to as invariant sites, but would better be termed invariable sites.</value>
										</comment>
									</attributes>
								</parameter>
								
<!--ratehetmodel general section 2 -->
<!-- invariantsites = estimate general section 2  
a number of extra settings need to be added to the codon-aminoacid set:
invariantsites
numratecats
ratehetmodel
-->
								<parameter type="Excl"  ismandatory="1">
									<name>p_ratehetmodel</name> 
									<attributes>
										<group>2</group>
										<prompt>Model of rate heterogeneity (ratehetmodel)</prompt>
										<precond>
											<language>perl</language>
											<code>!$user_conffile &amp;&amp; ($datatype_value eq "aminoacid" || $datatype_value eq "codon-aminoacid")</code>
										</precond>
										<format>
											<language>perl</language>
											<code>
											($p_ratehetmodel eq "none") ? "numratecats = 1\\nratehetmodel = $value\\n" : 
												"numratecats = $p_numratecats\\nratehetmodel = $value\\n"
											</code>
										</format>
										<vlist>
											<value>none</value>
											<label>Equal Rates For All Sites (none)</label>
											<value>gamma</value>
											<label>Gamma Distribution (gamma)</label>
										</vlist>
										<vdef>
											<value>gamma</value>
										</vdef>
										<paramfile>garli.conf</paramfile>
										<comment>
<value>The model of rate heterogeneity assumed. gammafixed requires that the alpha shape parameter is provided, and a setting of gamma estimates it.</value>
										</comment>
									</attributes>
								</parameter>
								
<!--general section numratecats =20-->
<!-- invariantsites = estimate general section 2  
a number of extra settings need to be added to the codon-aminoacid set:
invariantsites
numratecats
ratehetmodel
-->
								<parameter type="Integer">
									<name>p_numratecats</name> 
									<attributes>
										<paramfile>garli.conf</paramfile>
										<group>2</group>
										<prompt>Number of rate categories (numratecats; set at no more than 8)</prompt>
										<precond>
											<language>perl</language>
											<code>!$user_conffile &amp;&amp; $p_ratehetmodel eq "gamma"  &amp;&amp; ($datatype_value eq "aminoacid" || $datatype_value eq "codon-aminoacid")</code>
										</precond>
										<format>
											<language>perl</language>
											<code>"numratecats=$value\\n"</code>
										</format>
										<vdef>
											<value>4</value>
										</vdef>
<!-- -For both aminoacid and codon-aminoacid, vdef for numratecats should be 4 -->
										<ctrls>
											<ctrl>
												<message>Number of rate categories: must be an integer between 1 and 20</message>
												<language>perl</language>
												<code>$p_numratecats &lt; 2 || $p_numratecats &gt; 20</code>
											</ctrl>
										</ctrls>
										<comment>
<value>The number of categories of variable rates (not including the invariant site class if it is being used). Must be set to 1 if ratehetmodel is set to none.  Note that runtimes and memory usage scale linearly with this setting.</value>
										</comment>
									</attributes>
								</parameter>
								
							</parameters>
							
						</paragraph>
						
					</parameter>
					
					<!-- Protein Model Paragraph -->
<!-- general section 2 -->					
					<!-- Codon Model: -->
					<!-- ======================================================================================== -->
	<parameter type="Paragraph">
		<paragraph>
			<name>model_codon</name>
			<prompt>Codon Model</prompt>
				<comment>
<value>The codon models are built with three components: (1) parameters describing the process of individual nucleotide substitutions, (2) equilibrium codon
	frequencies, and (3) parameters describing the relative rate of nonsynonymous to synonymous substitutions.  The nucleotide substitution parameters within the codon
	models are exactly the same as those possible with standard nucleotide models in GARLI, and are specified with the ratematrix configuration entry.  Thus, they can
	be of the 2rate variety (inferring different rates for transitions and transversions, K2P or HKY-like), the 6rate variety (inferring different rates for all nucleotide
	pairs, GTR-like) or any other sub-model of GTR. The options for codon frequencies are specified with the statefrequencies configuration entry.  The options are to use
	equal frequencies (not a good option), the frequencies observed in your dataset (termed empirical in GARLI), or the codon frequencies implied by the F1x4 or F3x4
	methods (using PAML's terminology). These last two options calculate the codon frequencies as the product of the frequencies of the three nucleotides that make up
	each codon.  In the F1x4 case the nucleotide frequencies are those observed in the dataset across all codon positions, while the F3x4 option uses the nucleotide frequencies
	observed in the data at each codon position separately.  The final component of the codon models is the nonsynonymous to synonymous relative rate parameters  (aka dN/dS or 
	omega parameters).  The default is to infer a single dN/dS value.  Alternatively, a model can be specified that infers a given number of dN/dS categories, with the dN/dS values
	and proportions falling in each category estimated (ratehetmodel = nonsynonymous).  This is the discrete or M3 model in PAML's terminology.</value>
<value>From the Author: No stop codons under the chosen genetic code are allowed. These are: standard code (TAG, TAA and TGA); vertebrate mitochondria
	(TAG, TAA, AGA and AGG); invertebrate mitochondria (TAG and TAA). One might argue that stop codons should just be ignored and treated as missing,
	but this can be dangerous. Sometimes they will come from a sequencing error, but more often from an alignment problem, an incorrectly chosen genetic code, or a
	sequence that is not really coding (e.g. an intron). In any case, error should be examined and resolved consciously by the user. 
</value>
<value> One thing to note is that codon models for tree inference require that you align the protein coding sequences along a correct reading frame; (e.g., gaps of 1 or 2
bases will impair the analysis). Maintaining the reading frame makes alignment much easier even if your analysis will be at the nucleotide level. Just running
sequences through a sequence alignment program without looking is almost guaranteed
to return an alignment that will not work for codon based inference.</value>
<value>The other important restriction to note is that GARLI expects the alignment to begin on the first base of a codon. It can't figure out where the reading frame is, so if the
alignment starts with a partial codon it needs to be removed or excluded from the alignment. Version 0.96 does allow normal NEXUS exclusions through an assumptions block,
so the following would work to exclude the first two bases of an alignment and tell GARLI that the reading frame starts on the third.
begin assumptions;
exset * myexset = 1 2;
end;.</value>
							</comment>

<!--For datatype = codon: The codon models are built with three components: (1) parameters describing the process of individual nucleotide substitutions, (2) equilibrium codon frequencies, and
(3) parameters describing the relative rate of nonsynonymous to synonymous substitutions.  The nucleotide substitution parameters within the codon models are exactly the same as those possible
with standard nucleotide models in GARLI, and are specified with the ratematrix configuration entry.  Thus, they can be of the 2rate variety (inferring different rates for transitions and transversions,
K2P or HKY-like), the 6rate variety (inferring different rates for all nucleotide pairs, GTR-like) or any other sub-model of GTR.  The options for codon frequencies are specified with the statefrequencies
configuration entry.  The options are to use equal frequencies (not a good option), the frequencies observed in your dataset (termed empirical in GARLI), or the codon frequencies implied by the F1x4 
or F3x4 methods (using PAML's terminology).  These last two options calculate the codon frequencies as the product of the frequencies of the three nucleotides that make up each codon.  In the F1x4
case the nucleotide frequencies are those observed in the dataset across all codon positions, while the F3x4 option uses the nucleotide frequencies observed in the data at each codon position separately.
The final component of the codon models is the nonsynonymous to synonymous relative rate parameters (aka dN/dS or omega parameters).  The default is to infer a single dN/dS value.  Alternatively, a
model can be specified that infers a given number of dN/dS categories, with the dN/dS values and proportions falling in each category estimated (ratehetmodel = nonsynonymous).  This is 
the discrete or M3 model in PAML's terminology. -->

<!-- ratematrix (1rate, 2rate, 6rate, fixed, custom string)  This determines the relative rates of nucleotide substitution assumed by the codon model.  The options are exactly the same as those allowed
 under a normal nucleotide model.  A codon model with ratematrix = 2rate specifies the standard Goldman and Yang (1994) model, with different substitution rates for transitions and transversions. -->

						<parameters> 
								<parameter type="Excl" ismandatory="1">
									<name>c_ratematrix</name> 
									<attributes>
										<paramfile>garli.conf</paramfile>
										<group>2</group>
										<prompt>Codon Rate Matrix (ratematrix)</prompt>
										<precond>
											<language>perl</language>
											<code>!$user_conffile &amp;&amp;  $datatype_value eq "codon"</code>
										</precond>
										<format>
											<language>perl</language>
											<code>"ratematrix = $value\\n" </code>
										</format>
										<vdef>
											<value>2rate</value>
										</vdef>
										<vlist>
											<value>1rate</value>
											<label>1rate</label>
											<value>2rate</value>
											<label>2rate</label>
											<value>6rate</value>
											<label>6rate</label>
											<value>fixed</value>
											<label>fixed</label>
											<value>custom</value>
											<label>custom</label>
											<value>string</value>
											<label>string</label>
										</vlist>
										<comment>
<value>This determines the relative rates of nucleotide substitution assumed by the codon model. The options are exactly the same as those allowed under a normal nucleotide model.  A codon model with ratematrix = 2rate specifies the standard Goldman and Yang (1994) model, with different substitution rates for transitions and transversions.</value>
										</comment>
									</attributes>
								</parameter>

<!-- statefrequencies (equal, empirical, f1x4, f3x4) - The options are to use equal codon frequencies (not a good option), the frequencies observed in your dataset (termed empirical in GARLI), or the codon frequencies
 implied by the F1x4 or F3x4 methods (using PAML's terminology).  These last two options calculate the codon frequencies as the product of the frequencies of the three nucleotides that make up each codon.  In the
 F1x4 case the nucleotide frequencies are those observed in the dataset across all codon positions, while the F3x4 option uses the nucleotide frequencies observed in the data at each codon position separately. -->

<!-- general section 2-->

								<parameter type="Excl"  ismandatory="1">
									<name>c_statefrequencies</name> 
									<attributes>
										<paramfile>garli.conf</paramfile>
										<group>2</group>
										<prompt>Codon Frequencies (statefequencies)</prompt>
										<precond>
											<language>perl</language>
											<code>!$user_conffile &amp;&amp; $datatype_value eq "codon"</code>
										</precond>
										<format>
											<language>perl</language>
											<code>"statefrequencies = $value\\n" </code>
										</format>
										<vlist>
											<value>equal</value>
											<label>equal</label>
											<value>empirical</value>
											<label>empirical (+F)</label>
											<value>f1x4</value>
											<label>F1x4</label>
											<value>f3x4</value>
											<label>F3x4</label>
										</vlist>
										<vdef><value>f3x4</value></vdef>
										<comment>
<value>The options are to use equal codon frequencies (not a good option), the frequencies observed in your dataset (termed empirical in GARLI), or the codon frequencies implied by the F1x4 or F3x4 methods (using PAML's terminology).  These last two options calculate the codon frequencies as the product of the frequencies of the three nucleotides that make up each codon.  In the F1x4 case the nucleotide frequencies are those observed in the dataset across all codon positions, while the F3x4 option uses the nucleotide frequencies observed in the data at each codon position separately.</value>
										</comment>
									</attributes>
								</parameter>
								
<!-- ratehetmodel (none, nonsynonymous)  For codon models, the default is to infer a single dN/dS parameter.  Alternatively, a model can be specified that infers a given number of dN/dS categories, 
with the dN/dS values and proportions falling in each category estimated (ratehetmodel = nonsynonymous).  This is the discrete or M3 model of Yang et al. (2000). . -->

<!--general section 2 -->
								<parameter type="Excl"  ismandatory="1">
									<name>c_ratehetmodel</name> 
									<attributes>
										<paramfile>garli.conf</paramfile>
										<group>2</group>
										<prompt>dN/dS categories (or Omega) (ratehetmodel)</prompt>
										<precond>
											<language>perl</language>
											<code>!$user_conffile &amp;&amp; $datatype_value eq "codon"</code>
										</precond>
										<vlist>
											<value>none</value>
											<label>A single dN/dS parameter (none)</label>
											<value>nonsynonymous</value>
											<label>discrete or M3 model (nonsynonymous)</label>
										</vlist>
										<flist>
											<value>none</value>
											<code>"ratehetmodel = none\\ninvariantsites = none\\nnumratecats = 1\\n" </code>
											<value>nonsynonymous</value>
											<code>"ratehetmodel = nonsynonymous\\ninvariantsites = none\\n" </code>
										</flist>
										<vdef>
											<value>none</value>
										</vdef>
										<comment>
<value>For codon models, the default is to infer a single dN/dS parameter. Alternatively, a model can be specified that infers a given number of dN/dS categories, with the dN/dS values and proportions falling in each category estimated (ratehetmodel = nonsynonymous). This is the discrete or M3 model of Yang et al. (2000).</value>
										</comment>
									</attributes>
								</parameter>

<!-- numratecats  When ratehetmodel = nonsynonymous, this is the number of dN/dS parameter categories. -->
 <!--numratecats general section 2-->
								<parameter type="Integer">
									<name>c_numratecats</name> 
									<attributes>
										<prompt>Number of dN/dS parameter categories (numratecats)</prompt>
										<paramfile>garli.conf</paramfile>
										<precond>
											<language>perl</language>
											<code>!$user_conffile &amp;&amp; $datatype_value eq "codon" &amp;&amp; $c_ratehetmodel eq "nonsynonymous"</code>
										</precond>
										<format>
											<language>perl</language>
											<code>"numratecats = $value\\n"</code>
										</format>
										<vdef>
											<value>3</value>
										</vdef>
										<ctrls>
											<ctrl>
												<message>Number of rate categories: must be an integer between 1 and 8</message>
												<language>perl</language>
												<code>$c_numratecats &lt; 1 || $c_numratecats &gt; 8</code>
											</ctrl>
										</ctrls>
										<group>2</group>
										<comment>
<value>When ratehetmodel = nonsynonymous, this is the number of dN/dS parameter categories. </value>
										</comment>
									</attributes>
								</parameter>

							</parameters>
						</paragraph>
					</parameter>
<!-- Codon Model Paragraph -->

					<!-- Trees -->

				</parameters>
			</paragraph>
		</parameter> 
<!-- End Model Paragraph-->
<!-- Population paragraph -->
<!-- ======================================================================================== -->
<parameter type="Paragraph">
		<paragraph>
			<name>algorithm_population</name>
			<prompt>Population</prompt>
				<parameters>
<!-- this paramter receives values from the three below it -->
								<parameter type="String"  ishidden="1">
									<name>poplulation_hidden</name> 
									<attributes>
										<paramfile>garli.conf</paramfile>
										<precond>
											<language>perl</language>
											<code>!$user_conffile</code>
										</precond>
										<group>4</group>
										<format>
											<language>perl</language>
											<code> 
												"selectionintensity = $selectionintensity\\n" .
												"nindivs = $nindivs\\n" .
												"holdover = $holdover\\n" 
											</code>
										</format>
									</attributes>
								</parameter>
								
<!--these values are loaded in the param above-->
								<parameter type="Float">
									<name>selectionintensity</name> 
									<attributes>
										<prompt>Selection Intensity (0.01 to 5.0) (selectionintensity)</prompt>
										<precond>
											<language>perl</language>
											<code>!$user_conffile</code>
										</precond>
										<vdef>
											<value>0.5</value>
										</vdef>
										<ctrls>
											<ctrl>
												<message>Selection Intensity must be between 0.01 - 5.0</message>
												<language>perl</language>
												<code>$selectionintensity &lt; 0.01 || $selectionintensity &gt; 5.0</code>
											</ctrl>
										</ctrls>
										<comment>
<value>Controls the strength of selection, with larger numbers denoting stronger selection. The relative probability of reproduction of two
individuals depends on the difference in their log likelihoods (delta lnL) and is formulated very similarly to the procedure of calculating Akaike
weights. The relative probability of reproduction of the less fit individual is equal to: 
In  general this setting does not seem to have much of an effect on the progress of a run. In theory higher values should cause scores to
increase more quickly, but make the search more likely to be entrapped in a local optimum. The following table gives the relative probabilities
of reproduction for different values of the selection intensity when the difference in log likelihood is 1.0 
Selection intensity 	Ratio of probabilities of reproduction 
0.05 	0.95:1.0 
0.1 	0.90:1.0 
0.25 	0.78:1.0 
0.5 	0.61:1.0 	
0.75 	0.47:1.0 	
1 	0.37:1.0 	
2 	0.14:1.0 	
</value>
										</comment>
									</attributes>
								</parameter>

								<parameter type="Integer">
									<name>nindivs</name> 
									<attributes>
										<prompt>Number of Individuals (nindivs 2 to 100)</prompt>
										<precond>
											<language>perl</language>
											<code>!$user_conffile</code>
										</precond>
										<vdef>
											<value>4</value>
										</vdef>
										<ctrls>
											<ctrl>
												<message>Number of individuals must be between 2 - 100</message>
												<language>perl</language>
												<code>$nindivs &lt; 2 || $nindivs &gt; 100</code>
											</ctrl>
										</ctrls>
										<comment>
<value>The number of individuals in the population. This may be increased, but generally seems to slow the rate of score increase.</value></comment>
									</attributes>
								</parameter>
					
<!-- the manual recommends the value of holdover not be changed -->
								<parameter ishidden="1" type="Integer">
									<name>holdover</name> 
									<attributes>
										<precond>
											<language>perl</language>
											<code>!$user_conffile</code>
										</precond>
										<vdef>
											<value>1</value>
										</vdef>
									</attributes>
								</parameter>

							</parameters> 
						</paragraph>
					</parameter>
<!-- End Population paragraph -->
<!-- ======================================================================================== -->
<!-- Branch length optimizations -->
					<parameter type="Paragraph">
						<paragraph>
							<name>algorithm_brlen</name>
							<prompt>Branch-length Optimization</prompt>
							<parameters>

<!-- this parameter receives values from the three below it -->
								<parameter type="String"  ishidden="1">
									<name>brlen_hidden</name> 
									<attributes>
										<paramfile>garli.conf</paramfile>
										<precond>
											<language>perl</language>
											<code>!$user_conffile</code>
										</precond>
										<group>4</group>
										<format>
											<language>perl</language>
											<code> 
												"startoptprec = $startoptprec\\n" .
												"minoptprec = $minoptprec\\n"  .
												"numberofprecreductions = $numberofprecreductions\\n" 
											</code>
										</format>
									</attributes>
								</parameter>
								
<!--these values are loaded in the param above-->
								<parameter type="Float">
									<name>startoptprec</name> 
									<attributes>
										<prompt>Starting Precision (startoptprec: 0.005 - 5.0)</prompt>
										<vdef>
											<value>0.5</value>
										</vdef>
										<precond>
											<language>perl</language>
											<code>!$user_conffile</code>
										</precond>
										<ctrls>
											<ctrl>
												<message>Starting Precision must be between 0.005 - 5.0</message>
												<language>perl</language>
												<code>$startoptprec &lt; 0.005 || $startoptprec &gt; 5.0</code>
											</ctrl>
										</ctrls>
									</attributes>
								</parameter>

								<parameter type="Float">
									<name>minoptprec</name> 
									<attributes>
										<prompt>Minimum Precision (minoptprec: 0.001 - 0.01)</prompt>
										<precond>
											<language>perl</language>
											<code>!$user_conffile</code>
										</precond>
										<vdef>
											<value>0.01</value>
										</vdef>
										<ctrls>
											<ctrl>
												<message>Minimum Precision must be between 0.001 - 0.01</message>
												<language>perl</language>
												<code>$minoptprec &lt; 0.001 || $minoptprec &gt; 0.01</code>
											</ctrl>
										</ctrls>
									</attributes>
								</parameter>

								<parameter type="Integer">
									<name>numberofprecreductions</name> 
									<attributes>
										<prompt>Number of Precision Reductions (0 - 100)</prompt>
										<precond>
											<language>perl</language>
											<code>!$user_conffile</code>
										</precond>
										<vdef>
											<value>20</value>
										</vdef>
										<ctrls>
											<ctrl>
												<message>Number of Precision Reductions must be between 0 - 100</message>
												<language>perl</language>
												<code>$minoptprec &lt; 0 || $minoptprec &gt; 100</code>
											</ctrl>
										</ctrls>
										<comment>
<value>Specify the number of steps that it will take for the optimization precision to decrease from startoptprec to minoptprec.
In version 0.95, the reduction from startoptprec to minoptprec is linear, rather than geometric. </value>
										</comment>
									</attributes>
								</parameter>

							</parameters>
						</paragraph>
					</parameter> 
<!-- End Branch length optimizations -->
<!-- Mutation Prior Weighting paragraph -->					
<!-- ======================================================================================== -->
					<parameter type="Paragraph">
						<paragraph>
							<name>algorithm_mutation_prior_weighting</name>
							<prompt>Mutation Prior Weighting</prompt>
							<parameters>

								<parameter type="String"  ishidden="1">
									<name>prior_weighting_hidden</name> 
									<attributes>
										<paramfile>garli.conf</paramfile>
										<precond>
											<language>perl</language>
											<code>!$user_conffile</code>
										</precond>
										<group>4</group>
										<format>
											<language>perl</language>
											<code> 
												"modweight = $modweight\\n" .
												"brlenweight = $brlenweight\\n" .
												"topoweight = $topoweight\\n" .
												"randnniweight = $randnniweight\\n" .
												"randsprweight = $randsprweight\\n" .
												"limsprweight = $limsprweight\\n" 
											</code>
										</format>
									</attributes>
								</parameter>

								<parameter type="Float">
									<name>modweight</name> 
									<attributes>
										<prompt>Model Mutations (modweight)</prompt>
										<precond>
											<language>perl</language>
											<code>!$user_conffile</code>
										</precond>
										<vdef>
											<value>0.05</value>
										</vdef>
										<ctrls>
											<ctrl>
												<message>Model Mutations must be 0 or greater.</message>
												<language>perl</language>
												<code>$modweight &lt; 0</code>
											</ctrl>
										</ctrls>
										<comment>
<value>The prior weight assigned to the class of model mutations. Note that setting this at 0.0 fixes the model during the run. </value></comment>
									</attributes>
								</parameter>

								<parameter type="Float">
									<name>brlenweight</name> 
									<attributes>
										<prompt>Branch-length Mutations (brlenweight)</prompt>
										<precond>
											<language>perl</language>
											<code>!$user_conffile</code>
										</precond>
										<vdef>
											<value>0.2</value>
										</vdef>
										<ctrls>
											<ctrl>
												<message>Branch-length Mutations must be 0 or greater.</message>
												<language>perl</language>
												<code>$brlenweight &lt; 0</code>
											</ctrl>
										</ctrls>
										<comment>
											<value>The prior weight assigned to branch-length mutations. </value>
										</comment>
									</attributes>
								</parameter>

								<parameter type="Float">
									<name>topoweight</name> 
									<attributes>
										<paramfile>garli.conf</paramfile>
										<precond>
											<language>perl</language>
											<code>!$user_conffile</code>
										</precond>
										<group>4</group>
										<prompt>All Topology Mutations (topoweight)</prompt>
										<vdef>
											<value>1.0</value>
										</vdef>
										<ctrls>
											<ctrl>
												<message>:All Topology Mutations: must be 0 or greater.</message>
												<language>perl</language>
												<code>$topoweight &lt; 0</code>
											</ctrl>
										</ctrls>
										<comment>
<value>The prior weight assigned to the class of topology mutations (NNI, SPR and limSPR).</value>
										</comment>
									</attributes>
								</parameter>

								<parameter type="Float">
									<name>randnniweight</name> 
									<attributes>
										<prompt>NNI Mutations (randnniweight)</prompt>
										<precond>
											<language>perl</language>
											<code>!$user_conffile</code>
										</precond>
										<vdef>
											<value>0.1</value>
										</vdef>
										<ctrls>
											<ctrl>
												<message>NNI Mutations must be 0 or greater.</message>
												<language>perl</language>
												<code>$randnniweight &lt; 0</code>
											</ctrl>
										</ctrls>
										<comment>
											<value>The prior weight assigned to NNI mutations.</value>
										</comment>
									</attributes>
								</parameter>

								<parameter type="Float">
									<name>randsprweight</name> 
									<attributes>
										<prompt>SPR Mutations (randsprweight)</prompt>
										<precond>
											<language>perl</language>
											<code>!$user_conffile</code>
										</precond>
										<vdef><value>0.3</value></vdef>
										<ctrls>
											<ctrl>
												<message>SPR Mutations must be 0 or greater.</message>
												<language>perl</language>
												<code>$randsprweight &lt; 0</code>
											</ctrl>
										</ctrls>
										<comment>
<value>randsprweight (0 to infinity, 0.3) -The prior weight assigned to random SPR mutations.
For very large datasets it is often best to set this to 0.0, as random SPR mutations essentially never result in score increases.
</value>
										</comment>
									</attributes>
								</parameter>

								<parameter type="Float">
									<name>limsprweight</name> 
									<attributes>
										<prompt>Limited SPR Mutations (limsprweight)</prompt>
										<precond>
											<language>perl</language>
											<code>!$user_conffile</code>
										</precond>
										<vdef>
											<value>0.6</value>
										</vdef>
										<ctrls>
											<ctrl>
												<message>Limited SPR Mutations must be 0 or greater.</message>
												<language>perl</language>
												<code>$limsprweight &lt; 0</code>
											</ctrl>
										</ctrls>
										<comment>
<value>The prior weight assigned to SPR mutations with the reconnection branch limited to being a maximum of limsprrange
branches away from where the branch was detached.</value>
										</comment>
									</attributes>
								</parameter>

							</parameters>
						</paragraph>
					</parameter>  
<!-- End Mutation Prior Weighting paragraph -->		
<!-- Set Mutation Details paragraph -->	
<!-- ======================================================================================== -->
					<parameter type="Paragraph">
						<paragraph>
							<name>algorithm_mutation_details</name>
							<prompt>Set Mutation Details</prompt>
							<parameters>

								<parameter type="String"  ishidden="1">
									<name>mutation_details_hidden</name> 
									<attributes>
										<paramfile>garli.conf</paramfile>
										<precond>
											<language>perl</language>
											<code>!$user_conffile</code>
										</precond>
										<group>4</group>
										<format>
											<language>perl</language>
											<code> 
												"limsprrange= $limsprrange\\n" .
												"uniqueswapbias = $uniqueswapbias\\n" .
												"distanceswapbias = $distanceswapbias\\n" 
											</code>
										</format>
									</attributes>
								</parameter>
								
<!--these values are loaded in the param above-->
								<parameter type="Integer">
									<name>limsprrange</name> 
									<attributes>
										<prompt>Max Limited SPR Branch Movement (limsprrange)</prompt>
										<precond>
											<language>perl</language>
											<code>!$user_conffile</code>
										</precond>
										<vdef><value>6</value></vdef>
										<ctrls>
											<ctrl>
												<message>Limited SPR Branch Movement must be 0 or greater.</message>
												<language>perl</language>
												<code>$limsprrange &lt; 0</code>
											</ctrl>
										</ctrls>
										<comment>
	<value>The maximum number of branches away from its original location that a branch may be reattached during a limited SPR move.
	Setting this too high (> 10) can seriously degrade performance. </value>
										</comment>
									</attributes>
								</parameter>

								<parameter type="Float">
									<name>uniqueswapbias</name> 
									<attributes>
										<prompt>Unique Swap Bias (uniqueswapbias)</prompt>
										<precond>
											<language>perl</language>
											<code>!$user_conffile</code>
										</precond>
										<vdef>
											<value>0.1</value>
										</vdef>
										<ctrls>
											<ctrl>
												<message>Unique Swap Bias must be between 0.01 - 1.0</message>
												<language>perl</language>
												<code>$uniqueswapbias  &lt; 0.01 || $uniqueswapbias &gt; 1.0</code>
											</ctrl>
										</ctrls>
									</attributes>
								</parameter>

<!-- Made this hidden because Derrick says it doesn't work and should be left at 1.0 -->
								<parameter type="Float"  ishidden="1">
									<name>distanceswapbias</name> 
									<attributes>
										<prompt>Distance Swap Bias (distanceswapbias)</prompt>
										<precond>
											<language>perl</language>
											<code>!$user_conffile</code>
										</precond>
										<vdef><value>1.0</value></vdef>
									</attributes>
								</parameter>

							</parameters>
						</paragraph>
					</parameter> 
<!-- Set Mutation Details paragraph -->	
<!-- ==================================================================================================== -->
<!-- Configure Logs Paragraph-->
<!-- ======================================================================================== -->
					<parameter type="Paragraph">
						<paragraph>
							<name>general_logs</name>
							<prompt>Configure Logs</prompt>
							<parameters>
								<parameter type="Integer">
									<name>saveevery_g</name> 
									<attributes>
										<prompt>Save best tree with interval (saveevery)</prompt>
										<precond>
											<language>perl</language>
											<code>!$user_conffile</code>
										</precond>
										<vdef>
											<value>100</value>
										</vdef>
										<ctrls>
											<ctrl>
												<message>Save best tree with interval must be greater than 1</message>
												<language>perl</language>
												<code>$value &lt; 1</code>
											</ctrl>
										</ctrls>
									</attributes>
								</parameter>
								
<!--these values are loaded in the param above-->
								<parameter type="Integer" ishidden="1">
									<name>saveevery</name> 
									<attributes>
										<paramfile>garli.conf</paramfile>
										<precond>
											<language>perl</language>
											<code>!$user_conffile</code>
										</precond>
										<group>2</group>
										<format>
											<language>perl</language>
											<code>"saveevery = $saveevery_g\\n"</code>
										</format>
									</attributes>
								</parameter>
								
<!--outputcurrentbesttopology (0 or 1.0)  If true, the current best tree of the current search replicate is written to 
	<ofprefix>.best.current.tre every saveevery generations.  In versions before 0.96 the current best topology was always
	written to file, but that is no longer the case. Seeing the current best tree has no real use apart from satisfying your
	curiosity about how a run is going. -->
					
								<parameter type="Switch">
									<name>outputcurrentbesttopology</name> 
									<attributes>
										<prompt>Output current best tree at "savevery" interval (outputcurrentbesttopology)</prompt>
										<paramfile>garli.conf</paramfile>
										<precond>
											<language>perl</language>
											<code>!$user_conffile</code>
										</precond>
										<group>2</group>
										<format>
											<language>perl</language>
											<code>($value) ? "outputcurrentbesttopology = 1\\n" : "outputcurrentbesttopology = 0\\n"</code>
										</format>
									</attributes>
								</parameter>

<!-- not sure how to deliver this, will ask terri -->
<!--								<parameter  ismandatory="1" type="Excl">
									<name>loutputbesttop</name> 
									<attributes>
										<prompt>Save best score with interval</prompt>
										<vdef><value>10</value></vdef>
										<ctrls>
											<ctrl>
												<message>Save best score with interval must be greater than 1</message>
												<language>perl</language>
												<code>$value &lt; 1</code>
											</ctrl>
										</ctrls>
									</attributes>
								</parameter>
	
								<parameter type="Integer" ishidden="1">
									<name>logevery</name> 
									<attributes>
										<paramfile>garli.conf</paramfile>
										<group>2</group>
										<format>
											<language>perl</language>
											<code>"logevery = $logevery_g\\n"</code>
										</format>
									</attributes>
								</parameter>
	 -->
								
<!-- terri built many of these simple params as match-mated pairs: they are hidden switches with integer inputs;
	the first param is visible and is named param_g, the second is names param; they can' t function alone so be careful -->
								
								<parameter type="Integer">
									<name>logevery_g</name> 
									<attributes>
										<prompt>Save best score with interval (logevery)</prompt>
										<precond>
											<language>perl</language>
											<code>!$user_conffile</code>
										</precond>
										<vdef>
											<value>10</value>
										</vdef>
										<ctrls>
											<ctrl>
												<message>Save best score with interval must be greater than 1</message>
												<language>perl</language>
												<code>$value &lt; 1</code>
											</ctrl>
										</ctrls>
										<comment>
				<value>The frequency with which the best score is written to the log file. </value>
										</comment>
									</attributes>
								</parameter>
								
								<parameter type="Integer" ishidden="1">
									<name>logevery</name> 
									<attributes>
										<paramfile>garli.conf</paramfile>
										<precond>
											<language>perl</language>
											<code>!$user_conffile</code>
										</precond>
										<group>2</group>
										<format>
											<language>perl</language>
											<code>"logevery = $logevery_g\\n"</code>
										</format>
									</attributes>
								</parameter>
								
<!-- terri built many of these simple params as match-mated pairs: they are hidden switches with integer inputs; the first param is visible and is named param_g, the second is names param; they can' t function alone so be careful -->
								<parameter type="Switch">
									<name>outputeachbettertopology_g</name> 
									<attributes>
										<prompt>Save each improved topology (outputeachbettertopology; can result in a very large file)</prompt>
										<precond>
											<language>perl</language>
											<code>!$user_conffile</code>
										</precond>
										<vdef>
											<value>0</value>
										</vdef>
										<comment>
<value>If true, each new topology encountered with a better score than the previous best is written to file. In some cases this can result in really big files, possibly hundreds of MB, especially for random starting topologies on large datasets. Note that this file is interesting to get an idea of how the topology changed as the searches progressed, but the collection of trees should NOT be interpreted in any meaningful way. This option is not available while bootstrapping.</value>
										</comment>
									</attributes>
								</parameter>
								
								<parameter type="Switch"  ishidden="1">
									<name>outputeachbettertopology</name> 
									<attributes>
										<paramfile>garli.conf</paramfile>
										<precond>
											<language>perl</language>
											<code>!$user_conffile</code>
										</precond>
										<group>2</group>
										<format>
											<language>perl</language>
											<code>"outputeachbettertopology = $outputeachbettertopology_g\\n" </code>
										</format>
									</attributes>
								</parameter>

<!-- terri built many of these simple params as match-mated pairs: they are hidden switches with integer inputs; the first param is visible and is named param_g, the second is names param; they can' t function alone so be careful -->
								<parameter type="Switch">
									<name>inferinternalstateprobs_g</name> 
									<attributes>
										<prompt>Output state probabilities of internal nodes (inferinternalstateprobs)</prompt>
										<precond>
											<language>perl</language>
											<code>!$user_conffile</code>
										</precond>
										<vdef>
											<value>0</value>
										</vdef>
										<precond>
											<language>perl</language>
											<code>$bootstrapreps == 0</code>
										</precond>
									</attributes>
								</parameter>
								
								<parameter type="Switch" ishidden="1">
									<name>inferinternalstateprobs</name> 
									<attributes>
										<paramfile>garli.conf</paramfile>
										<group>4</group>
										<precond>
											<language>perl</language>
											<code>!$user_conffile</code>
										</precond>
										<format>
											<language>perl</language>
											<code>"inferinternalstateprobs = $inferinternalstateprobs_g\\n" </code>
										</format>
										<comment>
											<value>Use this flag to have GARLI infer the marginal posterior probability of each character at each internal node. This is done at the very end of the run, just before termination. The results are output to a file named ofprefix.internalstates.log. </value>
										</comment>
									</attributes>
								</parameter>

<!-- terri built many of these simple params as match-mated pairs: they are hidden switches with integer inputs; the first param is visible and is named param_g, the second is names param; they can' t function alone so be careful -->
								<parameter type="Switch">
									<name>outputphyliptree_g</name> 
									<attributes>
										<prompt>Output PHYLIP-format tree (outputphyliptree)</prompt>
										<vdef><value>0</value></vdef>
										<precond>
											<language>perl</language>
											<code>!$user_conffile</code>
										</precond>
									</attributes>
								</parameter>
								
								<parameter type="Switch"  ishidden="1">
									<name>outputphyliptree</name> 
									<attributes>
										<paramfile>garli.conf</paramfile>
										<precond>
											<language>perl</language>
											<code>!$user_conffile</code>
										</precond>
										<group>2</group>
										<format>
											<language>perl</language>
											<code>"outputphyliptree = $outputphyliptree_g\\n" </code>
										</format>
									</attributes>
								</parameter>

<!-- terri built many of these simple params as match-mated pairs: they are hidden switches with integer inputs; the first param is visible and is named param_g, the second is names param; they can' t function alone so be careful -->

								<parameter type="Switch">
									<name>outputmostlyuselessfiles_g</name> 
									<attributes>
										<prompt>Output fate, problog, and swaplog files</prompt>
										<precond>
											<language>perl</language>
											<code>!$user_conffile</code>
										</precond>
										<vdef>
											<value>0</value>
										</vdef>
									</attributes>
								</parameter>

								<parameter type="Switch"  ishidden="1">
									<name>outputmostlyuselessfiles</name> 
									<attributes>
										<paramfile>garli.conf</paramfile>
										<precond>
											<language>perl</language>
											<code>!$user_conffile</code>
										</precond>
										<group>2</group>
										<format>
											<language>perl</language>
											<code>"outputmostlyuselessfiles = $outputmostlyuselessfiles_g\\n" </code>
										</format>
										<comment>
<value>Whether to output three files of little general interest: the fate, problog, and swaplog files. The fate file shows the 
	parentage, mutation types and scores of every individual in the population during the entire search. The problog shows how 
	the proportions of the different mutation types changed over the course of the run. The swaplog shows the number of unique 
	swaps and the number of total swaps on the current best tree over the course of the run.</value>
										</comment>
									</attributes>
								</parameter>
							</parameters> 

						</paragraph> 
					</parameter> 			
<!-- End Logs Paragraph -->
<!-- Configure Run Termination Paragraph-->
<!-- ======================================================================================== -->
	<parameter type="Paragraph">
						<paragraph>
							<name>general_run</name>
							<prompt> Configure Run Termination</prompt>
							<parameters>

<!-- terri built these simple params as a hidden parameter that proivide the single submission point for values collected from user input boxes; the user input box parmaters have no executive component of their own. they can' t function alone so be careful -->

								<parameter type="String" ishidden="1">
									<name>hidden_group2</name>
									<attributes>
										<paramfile>garli.conf</paramfile>
										<precond>
											<language>perl</language>
											<code>!$user_conffile</code>
										</precond>
										<group>2</group>
										<format>
											<language>perl</language>
											<code>
												"enforcetermconditions = $enforcetermconditions\\n" .
												"genthreshfortopoterm = $genthreshfortopoterm\\n" .
												"significanttopochange = $significanttopochange\\n" .
												"scorethreshforterm = $scorethreshforterm\\n" 
											</code>
										</format>
									</attributes>
								</parameter>

<!-- Stopgen and stoptime are always applied, regardless of whether enforcetermconditions has been set.  -->
								<parameter type="String" ishidden="1">
									<name>hidden_group4</name>
									<attributes>
										<paramfile>garli.conf</paramfile>
										<precond>
											<language>perl</language>
											<code>!$user_conffile</code>
										</precond>
										<group>4</group>
										<format>
											<language>perl</language>
											<code>
												"stopgen = $stopgen\\n" .
												"stoptime = $stoptime\\n"
											</code>
										</format>
									</attributes>
								</parameter>

								<parameter type="Switch">
									<name>enforcetermconditions</name> 
									<attributes>
										<prompt>Automatically terminate run (enforcetermconditions; recommended)</prompt>
										<vdef>
											<value>1</value>
										</vdef>
										<precond>
											<language>perl</language>
											<code>!$user_conffile</code>
										</precond>
									</attributes>
								</parameter>

								<parameter type="Integer">
									<name>genthreshfortopoterm</name> 
									<attributes>
										<precond>
											<language>perl</language>
											<code>!$user_conffile &amp;&amp; $enforcetermconditions</code>
										</precond>
										<prompt>Generations without improving topology (genthreshfortopoterm)</prompt>
										<vdef>
											<value>20000</value>
										</vdef>
<!---Change default genthreshfortopoterm from 10K to 20K-->
										<ctrls>
											<ctrl>
												<message>Generations without improving topology must be a positive integer</message>
												<language>perl</language>
												<code>$value &lt; 0</code>
											</ctrl>
										</ctrls>
										<comment>
<value>This specifies the first part of the termination condition.  When no new significantly better scoring topology see significanttopochange below) has been encountered in greater than this number of generations, this condition is met. Increasing this parameter may improve the lnL scores obtained (especially on large datasets), but will also increase runtimes. </value>
										</comment>
									</attributes>
								</parameter>

								<parameter type="Float">
									<name>significanttopochange</name> 
									<attributes>
										<precond>
											<language>perl</language>
											<code>!$user_conffile &amp;&amp; $enforcetermconditions</code>
										</precond>
										<prompt>lnL increase for significantly better topology (significanttopochange)</prompt>
										<vdef><value>0.01</value></vdef>
										<ctrls>
											<ctrl>
												<message>lnL increase for significantly better topology must be a positive number</message>
												<language>perl</language>
												<code>$value &lt; 0</code>
											</ctrl>
										</ctrls>
										<comment>
<value>The lnL increase required for a new topology to be considered significant as far as the termination condition is concerned. It probably doesn't need to be played with, but you might try increasing it slightly if your runs reach a stable score and then take a very long time to terminate due to very minor changes in topology.</value>
										</comment>
									</attributes>
								</parameter>

								<parameter type="Float">
									<name>scorethreshforterm</name> 
									<attributes>
										<precond>
											<language>perl</language>
											<code>!$user_conffile &amp;&amp; $enforcetermconditions</code>
										</precond>
										<prompt>Score improvement threshold (scorethreshforterm)</prompt>
										<vdef><value>0.05</value></vdef>
										<ctrls>
											<ctrl>
												<message>Score improvement threshold must be a positive number.</message>
												<language>perl</language>
												<code>$value &lt; 0</code>
											</ctrl>
										</ctrls>
										<comment>
<value>The second part of the termination condition.  When the total improvement in score over the last intervallength x intervalstostore generations (default is 500 generations, see below) is less than this value, this condition is met.  This does not usually need to be changed. </value>
										</comment>
									</attributes>
								</parameter>

								<parameter type="Integer">
									<name>stopgen</name> 
									<attributes>
										<prompt>Limit generations to maximum of (stopgen); default =214783646 </prompt>
										<precond>
											<language>perl</language>
											<code>!$user_conffile</code>
										</precond>
										<vdef>
											<value>214783646</value>
										</vdef>
										<ctrls>
											<ctrl>
												<message>Limit generations to maximum of must be a positive number; unless you are experienced, we recommend the default, 214783646</message>
												<language>perl</language>
												<code>$value &lt; 1</code>
											</ctrl>
										</ctrls>
										<comment>
<value>The maximum number of generations to run. Note that this supersedes the automated stopping criterion (see enforcetermconditions above), and should therefore be set to a very large value if automatic termination is desired.</value>
										</comment>
									</attributes>
								</parameter>

								<parameter type="Integer">
									<name>stoptime</name> 
									<attributes>
										<prompt>Limit run time to maximum of (stoptime, in seconds) default=214783646 </prompt>
										<vdef>
											<value>214783646</value>
										</vdef>
										<precond>
											<language>perl</language>
											<code>!$user_conffile</code>
										</precond>
										<ctrls>
											<ctrl>
												<message>:Limit run time to maximum of: must be a positive number; unless you are experienced, we recommend the default, 214783646</message>
												<language>perl</language>
												<code>$value &lt; 1</code>
											</ctrl>
										</ctrls>
										<comment>
<value>The maximum number of seconds for the run to continue. Note that this supersedes the automated stopping criterion (see enforcetermconditions above), and should therefore be set to a very large value if automatic termination is desired. </value>
										</comment>
									</attributes>
								</parameter>

<!--When bootstrapreps are less than 0, this setting allows for bootstrap-like resampling, but with the pseudoreplicate datasets having a different number of alignment columns than the real data.  Setting values greater than 1.0 is akin to jackknifing. -->

								<parameter type="Switch">
									<name>resampleproportion</name> 
									<attributes>
										<prompt>Use Resampling where the pseudoreplicate datasets have a different number of alignment columns than the real data (resampleproportion)</prompt>
										<precond>
											<language>perl</language>
											<code>!$user_conffile &amp;&amp; $bootstrapreps &gt; 0</code>
										</precond>
									</attributes>
								</parameter>
								
								<parameter type="Float">
									<name>resampleproportion_val</name> 
									<attributes>
										<prompt>Enter the value for resampling proportion (resampleproportion)</prompt>
										<precond>
											<language>perl</language>
											<code>!$user_conffile &amp;&amp; $resampleproportion</code>
										</precond>
										<group>4</group>
										<vdef>
											<value>1.0</value>
										</vdef>
										<format>
											<language>perl</language>
											<code>"resampleproportion = $resampleproportion_val\\n"</code>
										</format>
										<ctrls>
											<ctrl>
												<message>Resample proportion must be a positive number less than 10</message>
												<language>perl</language>
												<code>$value &lt; 0 || $value &gt; 10</code>
											</ctrl>
										</ctrls> 
										<comment>
<value>When bootstrapreps is greater than 0, this setting allows for bootstrap-like resampling, but with the pseudoreplicate datasets having a different number of alignment columns than the real data.  Setting values less than 1.0 is akin to jackknifing 
</value>
										</comment>
									</attributes>
								</parameter>
							</parameters>
								
						</paragraph>
					</parameter>

<!-- End Run Termination-->
<!-- ============================================================================================================= -->
<!-- All of the following are hidden, therefore the ctrls and preconds that would be required
if users could change them have not been filled in. -->
<!-- ============================================================================================================= -->

<!-- checkpoint and restart are disabled for now, not sure how we'd do it in swami -->
<parameter type="Switch"  ishidden="1">
	<name>writecheckpoints</name> 
	<attributes>
		<paramfile>garli.conf</paramfile>
		<precond>
			<language>perl</language>
			<code>!$user_conffile</code>
		</precond>
		<group>2</group>
		<prompt>Write Checkpoints (writecheckpoints)</prompt>
		<format>
			<language>perl</language>
			<code>"writecheckpoints = $vdef\\n" </code>
		</format>
		<vdef>
			<value>0</value>
		</vdef>
	</attributes>
</parameter>
		
<!-- checkpoint and restart are disabled for now, not sure how we'd do it in swami -->
<parameter type="Switch"  ishidden="1">
	<name>restart</name> 
	<attributes>
		<paramfile>garli.conf</paramfile>
		<group>2</group>
		<precond>
			<language>perl</language>
			<code>!$user_conffile</code>
		</precond>
		<prompt>Restart (restart)</prompt>
		<format>
			<language>perl</language>
			<code>"restart = $vdef\\n" </code>
		</format>
		<vdef>
			<value>0</value>
		</vdef>
	</attributes>
</parameter>

<!-- I don't think the OSX GUI version of garli lets users set the following parameters -->
<parameter type="Integer"  ishidden="1">
	<name>holdoverpenalty</name> 
	<attributes>
		<paramfile>garli.conf</paramfile>
		<group>4</group>
		<prompt>Holdover Penalty (holdoverpenalty)</prompt>
		<precond>
			<language>perl</language>
			<code>!$user_conffile</code>
		</precond>
		<format>
			<language>perl</language>
			<code>"holdoverpenalty = $vdef\\n" </code>
		</format>
		<vdef>
			<value>0</value>
		</vdef>
	</attributes>
</parameter>

<parameter type="Float"  ishidden="1">
	<name>treerejectionthreshold</name> 
	<attributes>
		<paramfile>garli.conf</paramfile>
		<group>4</group>
		<prompt>treerejectionthreshold</prompt>
		<precond>
			<language>perl</language>
			<code>!$user_conffile</code>
		</precond>
		<format>
			<language>perl</language>
			<code>"treerejectionthreshold = $vdef\\n" </code>
		</format>
		<vdef>
			<value>50.0</value>
		</vdef>
	</attributes>
</parameter>

<parameter type="Integer"  ishidden="1">
	<name>intervallength</name> 
	<attributes>
		<paramfile>garli.conf</paramfile>
		<precond>
			<language>perl</language>
			<code>!$user_conffile</code>
		</precond>
		<group>4</group>
		<prompt>intervallength</prompt>
		<format>
			<language>perl</language>
			<code>"intervallength = $vdef\\n" </code>
		</format>
		<vdef>
			<value>100</value>
		</vdef>
	</attributes>
</parameter>

<parameter type="Integer"  ishidden="1">
	<name>intervalstostore</name> 
	<attributes>
		<paramfile>garli.conf</paramfile>
		<precond>
			<language>perl</language>
			<code>!$user_conffile</code>
		</precond>
		<group>4</group>
		<prompt>intervalstostore</prompt>
		<format>
			<language>perl</language>
			<code>"intervalstostore = $vdef\\n" </code>
		</format>
		<vdef>
			<value>5</value>
		</vdef>
	</attributes>
</parameter>

<parameter type="Integer"  ishidden="1">
	<name>meanbrlenmuts</name> 
	<attributes>
		<paramfile>garli.conf</paramfile>
		<precond>
			<language>perl</language>
			<code>!$user_conffile</code>
		</precond>
		<group>4</group>
		<prompt>Mean Branch-length mutations (1 - # taxa)</prompt>
		<format>
			<language>perl</language>
			<code>"meanbrlenmuts = $vdef\\n" </code>
		</format>
		<vdef>
			<value>5</value>
		</vdef>
	</attributes>
</parameter>

<parameter type="Integer"  ishidden="1">
	<name>gammashapebrlen</name> 
	<attributes>
		<paramfile>garli.conf</paramfile>
		<precond>
			<language>perl</language>
			<code>!$user_conffile</code>
		</precond>
		<group>4</group>
		<prompt>gammashapebrlen</prompt>
		<format>
			<language>perl</language>
			<code>"gammashapebrlen = $vdef\\n" </code>
		</format>
		<vdef>
			<value>1000</value>
		</vdef>
	</attributes>
</parameter>

<parameter type="Integer"  ishidden="1">
	<name>gammashapemodel</name> 
	<attributes>
		<paramfile>garli.conf</paramfile>
		<precond>
			<language>perl</language>
			<code>!$user_conffile</code>
		</precond>
		<group>4</group>
		<prompt>gammashapemodel</prompt>
		<format>
			<language>perl</language>
			<code>"gammashapemodel = $vdef\\n" </code>
		</format>
		<vdef>
			<value>1000</value>
		</vdef>
	</attributes>
</parameter>

</parameters>
</pise>

<!--
Rami advised using multiple ctrl elements instead of logical
operators within a ctrl.  The perl code is translated to javascript
and run in the client's browser.  In the future, Jeremy will try to
run the same logic in java validators.

Note that the code expresses the ERROR condition.  In other words
if the code evaluates to true, there is an error.
-->
