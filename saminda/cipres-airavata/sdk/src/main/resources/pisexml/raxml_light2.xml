<?xml version="1.0" encoding="ISO-8859-1"?>
<!DOCTYPE pise SYSTEM "http://www.phylo.org/dev/rami/PARSER/pise2.dtd">
<pise>
	<head>
		<title>RAxML Light on XSEDE (BETA)</title>
		<version>1.0.9</version>
		<description>RAxML-Light is a modification of RAxML for inferring very large trees on XSEDE machines</description>
		<authors>Alexandros Stamatakis, Christian Goll, Wayne Pfeiffer</authors>
		<reference>Stamatakis A. RAxML-VI-HPC: maximum likelihood-based phylogenetic analyses with thousands of taxa and mixed models.Bioinformatics. 2006 Nov 1;22(21):2688-90</reference>
		<category>Phylogeny / Alignment</category>
		<doclink>http://icwww.epfl.ch/~stamatak/index-Dateien/countManual7.0.0.php  </doclink>
	</head>
	
	<command>raxml_light2</command>
	
<!-- 
###########################################################################################################################
	Created around 12/15/2011 by mamiller, based on information and a script developed by Wayne Pfeiffer and Christian Goll
###########################################################################################################################
	
This bash script performs a comprehensive analysis by submitting many separate jobs involving RAxML, RAxML-Light, and Parsimonator 
instead of a single job using only RAxML. The command to execute is

    /home/pfeiffer//RAxML-Light.sh <input options>

The following is an example:

1.  /home/pfeiffer/RAxML-Light.sh 
2. -s SALAMIN_404.phy 
3. 2-bsearches 100 
4. 2-rsearches 20 
99. 2-submit

The input options are described in the usage subroutine.
	
Default values are as follows:
	
RAXMLSERIAL=/home/diag/opt/raxml/7.2.8/bin/raxmlHPC-SERIAL
PARSIMONATOR=/home/pfeiffer/Parsimonator-1.0.2/parsimonator-SSE3
RAXMLLIGHT=/home/pfeiffer/RAxML-Light-1.0.5g/raxmlLight-PTHREADS
3. bsearches=100 (4 searches per per job, so the number of cores used is 25) 
4. rsearches=20  (4 searches per per job, so the number of cores used is 5)
5. BMAX=500 (we dont let the user set this)
6. RMAX=100 (we dont let the user set this)
7. usebest=""
serialqueue=shared
parsqueue=normal
searchqueue=normal
parscores=1
parscoresperjob=32
searchcores=8
searchcoresperjob=32 (this dictates that each job will receive 4 cores)
=============================================
	The number of jobs per search depends upon the "searchcores" and "searchcoresperjob" parameters.  
	The default values are 8 and 32, respectively, which means that there are four searches per job.  
	Thus the 100 bootstrap searches require 25 search jobs, and the 20 regular searches require another 5 search jobs.
=============================================
8. parshours=1
9. searchhours=1
10. account=use320
99. submit=""
11. substitution_model=GTRCAT
12. bseed=12345
13. pseed=12345
14. auto=autoMRE
save_memory=""

******************************************************************************
Options that users should be able to specify are:

	2-bsearches   number of bootstrap searches on replica alignments
	2-rsearches   number of regular searches on original alignment
    2-parshours   (max wall time to generate parsimony tree)
    2-searchhours (max wall time for searching)
	
	
	Additional options are:

2-usebest           use best trees found in bootstrap searches for regular searches on original alignment
	
**********************************************************************************************************
We will not allow users to set these parameters
**********************************************************************************************************
2-serialqueue       queue for serial jobs
2-parallelqueue	    queue for parallel search jobs
2-parscores	        number of cores to generate a parsimony tree
2-searchcores       number of cores for a search
**********************************************************************************************************
2-account	        account number
2-submit            submit jobs after writing run files

	
RAxML options

	-s  sequence file name
	-m  substitution model
	-b  seed for generating bootstrap replicas

Parsimonator options are:
	-p  seed for generating first parsimony tree in a sequence of searches

RAxML Light option
	-S  save memory
>The other input options can be left at their default values except for

    2-account
    2-submit

You need to specify your own account and always specify 2-submit .

-->
	
	<parameters>
<!-- Hidden parameters -->	
			
<!-- Set the basic command line -->	
					<parameter ishidden="1" type="String">
						<name>raxmllight_invocation</name>
						<attributes>
							<format>
								<language>perl</language>
								<code>"RAxML-Light.sh"</code>
							</format>
							<group>0</group>
						</attributes>
					</parameter>
		
<!-- Scheduler.conf just needs to set jobtype=direct, this is a new jobtype, meaning, don't generate a qsub script, just
run the command directly -->
					<parameter ishidden="1" type="String">
						<name>raxmlhpc_light_scheduler</name>
						<attributes>
							<paramfile>scheduler.conf</paramfile>
							<format>
								<language>perl</language>
								<code>
									"jobtype=direct\\n" 
								</code>
								</format>
							<group>1</group>
						</attributes>
					</parameter> 

<!--required input file -->
					<parameter ismandatory="1" issimple="1" isinput="1" type="InFile">
						<name>infile</name>
						<attributes>
							<format>
								<language>perl</language>
								<code>" -s infile.txt"</code>
							</format>
							<group>2</group>
							<filenames>infile.txt</filenames>
						</attributes>
					</parameter>
		
		
<!-- 2-submit submit jobs after writing run files-->
					<parameter ishidden="1" type="String">
						<name>submit_string</name>
						<attributes>
							<format>
								<language>perl</language>
								<code>" --submit"</code>
							</format>
							<group>99</group>
						</attributes>
					</parameter>
		
<!-- return all results -->		
					 <parameter type="Results">
						<name>all_outputfiles</name>
							<attributes>
								<filenames>*</filenames>
							</attributes>
					</parameter>	
<!-- end hidden parameters -->
		
<!-- Begin visible parameters  here -->
<!-- This is replaced by the other time controls parshours and searchhours
		<parameter type="Float" issimple="1" ismandatory="1">
			<name>runtime</name>
			<attributes>
				<group>1</group>
				<paramfile>scheduler.conf</paramfile>
				<prompt>Maximum Hours to Run (click here for help setting this correctly)</prompt>
				<vdef>
					<value>0.25</value>
				</vdef>
				<format>
					<language>perl</language>
					<code>"runhours=$value \\n"</code>
				</format>
				<ctrls>
					<ctrl>
						<message>Sorry, the maximum hours must be less than 334</message>
						<language>perl</language>
						<code>$runtime &gt; 334.0</code>
					</ctrl>
				</ctrls>
				<warns>
					<warn>
						<message>*****more information needed*****</message>
						<language>perl</language>
						<code>$runtime !== 0 </code>
					</warn>
				</warns>
				<group>0</group>
				<comment>
<value>Estimate the maximum time your job will need to run. We recommend testing initially with a &lt; 0.5hr test run because Jobs set for 0.5 h or less depedendably run immediately in the "debug" queue. 
Once you are sure the configuration is correct, you then increase the time. The reason is that jobs &gt; 0.5 h are submitted to the "normal" queue, where jobs configured for 1 or a few hours times may
run sooner than jobs configured for the full 334 hours. 
</value>
				</comment>
			</attributes>
		</parameter> -->
		
<!-- Optional mixed model file -->
<!-- If user doesn't enter a value the partition parameter won't be in the map that the web app sends the command renderer 
	(which evaluates the perl for parameters that are present), so we don't need to worry about making the format code conditional
	 since this parameter just won't be evaluated. Command renderer evaluates 3 types of parameters: 
	1) those that appear in the map coming from the gui, those that are	hidden, 3) those that are of type OutFile or Result. -->
					<parameter type="InFile" issimple="1">
						<name>partition</name>
						<attributes>
							<prompt>Select a partition file that specifies mixed/partitioned model (-q. Optional)</prompt>
							<format>
								<language>perl</language>
								<code>" -q partition.txt"</code>
							</format>
							<group>3</group>
							<filenames>partition.txt</filenames>
							<comment>
					<value>The multipleModelFileName parameter (-q) allows you to identify a file that specifies the regions of your alignment for which an individual 
						model of nucleotide or protein substitution should be estimated. This will typically be used to infer trees for long (in terms of base pairs) 
						multi-gene alignments. For example, if -m GTRGAMMA is used, individual alpha-shape parameters, GTR-rates, and empirical base frequencies
						 will be estimated and optimized for each partition. Since Raxml can now handle mixed Amino Acid and DNA alignments, you must specify the
						 data type in the partition file, before the partition name. For DNA, this means you have to add DNA to each line in the partition. For 
						 AA data you must specify the transition matrices for each partition:  The AA substitution model must be the first entry in each line and
						 must be separated by a comma from the gene name, just like the DNA token above. You can not assign different models of rate heterogeneity
						 to different partitions, i.e. it will be CAT or CATI. for all partitions. Finally, if you have a concatenated DNA and AA alignments, with
						 DNA data at positions 1 - 500 and AA data at 501-1000 with the WAG model the partition file should look as follows: DNA, gene1 = 1-500; WAG,
						 gene2 = 501-1000. For more help see http://phylobench.vital-it.ch/raxml-bb/index.php?help=model.
</value>
							</comment>
						</attributes>
					</parameter>
<!-- -M  Switch on estimation of individual per-partition branch lengths. Only has effect when used in combination with "-q" Branch lengths for individual
	partitions will be printed to   separate files . A weighted average of the branch lengths is computed by using the  respective partition lengths -->
					<parameter type="Switch" issimple="1">
						<name>estimate_branch</name>
						<attributes>
							<prompt>Estimate individual per-partition branch lengths (-M)</prompt>
							<precond>
								<language>perl</language>
								<code>defined $partition</code>
							</precond>
							<format>
								<language>perl</language>
								<code>($value) ? "-M":""</code>
							</format>
							<group>4</group>
							<comment>
<value>The -M option switches on estimation of individual per-partition branch lengths. It is used in combination with partitions, (-q). Branch lengths
for individual partitions will be printed to separate files. A weighted average of the branch lengths is computed using the respective partition lengths.
</value>
							</comment>
						</attributes>
					</parameter>

<!-- outgroup (-o) -->
					<parameter type="String" issimple="1">
						<name>outgroup</name>
						<attributes>
							<prompt>Outgroup (one or more comma-separated outgroups, click link for syntax description)</prompt>
							<format>
								<language>perl</language>
								<code>(defined $value)? " -o $value " : "" </code>
							</format>
							<group>10</group>
							<comment>
<value>The correct syntax for the box is outgroup1,outgroup2,outgroupn (no spaces between the taxa). In cases where multiple outgroups are not monophyletic, the first name in the list
will be selected as outgroup. The job will fail if white space is introduced between outgroups (e.g. outgroup1, outgroup2, outgroupn).
"Error, you must specify a model of substitution with the '-m' option." 
</value>					
							</comment>
						</attributes>
					</parameter>

<!--   -R      Read in a binary checkpoint file called RAxML_binaryCheckpoint.RUN_ID_number. Instead of specifying a comprehensive starting tree via -t, 
	you can use this option to restart a large-scale RAxML tree search that was interrupted, e.g., because you have used up your queue time. During the
	course of execution, RAxML will be writing files called   RaxML_binaryCheckpoint.RUN_ID_number, where RUN_ID is the run name you specified viy ?-n RUN_ID?
	and ?number? is simply the number of the checkpoint. Evidently, you would like to re-start RAxML-Light from the most recent checkpoint that was written. 
-->
<!-- we dont currently support -R
					<parameter issimple="1" type="InFile">
						<name>binary_chkpt</name>
						<attributes>
							<prompt>Read in a binary checkpoint file (-R)</prompt>
							<precond>
								<language>perl</language>
								<code>!defined $treetop</code>
							</precond>
							<format>
								<language>perl</language>
								<code>" -R RAxML_binaryCheckpoint.file"</code>
							</format>
							<group>2</group>
							<filenames>RAxML_binaryCheckpoint.file</filenames>
							<ctrls>
								<ctrl>
									<message>Sorry, you can't specify a binary checkpoint file AND supply a starting tree</message>
									<language>perl</language>
									<code>defined $value &amp;&amp; defined $treetop</code>
								</ctrl>
								<ctrl>
									<message>Please specify a binary checkpoint file or supply a starting tree</message>
									<language>perl</language>
									<code>!defined $value &amp;&amp; !defined $treetop</code>
								</ctrl>
							</ctrls> 
							<comment>
<value>Read in a binary checkpoint file called RAxML_binaryCheckpoint.RUN_ID_number. Instead of specifying a comprehensive starting tree via -t, 
	you can use this option to restart a large-scale RAxML tree search that was interrupted, e.g., because you have used up your queue time. During the
	course of execution, RAxML will be writing files called RaxML_binaryCheckpoint.RUN_ID_number, where RUN_ID is the run name you specified viy ?-n RUN_ID?
	and ?number? is simply the number of the checkpoint. Evidently, you would like to re-start RAxML-Light from the most recent checkpoint that was written.</value>
							</comment>
						</attributes>
					</parameter> -->
		
<!--      -S      turn on memory saving option for gappy multi-gene alignments. 
 For large and gappy datasets specify -S  to save memory. This will produce slightly different likelihood values,
 may be a bit slower but can reduce memory consumption from 70GB to 19GB on very large and gappy datasets .
-->
<!-- this slows things down so we took it out.
						<parameter issimple="1" type="Switch">
						<name>memory_save</name>
						<attributes>
							<prompt>Use memory saving (-S)</prompt>
							<format>
								<language>perl</language>
								<code>($value) ? " -S ":""</code>
							</format>
							<group>11</group>
							<comment>
<value>Use the -S option to for gappy multi-gene alignments to save memory. This will produce slightly different likelihood values,
 may be a bit slower but can reduce memory consumption from 70GB to 19GB on very large and gappy datasets.</value>
							</comment>
						</attributes>
					</parameter> -->
		
<!-- Choose the model for the run  -->
<parameter type="Paragraph">
	<paragraph>
		<name>configure_model</name>
		<prompt>Model Configuration Parameters</prompt>
		<parameters>
<!-- first, is it protein or dna input ? protein not supported by parsimonator-->
			<parameter type="Excl" issimple="0" ismandatory="1">
						<name>datatype</name>
						<attributes>
							<prompt>Sequence Type</prompt>
							<vlist>
								<value>dna</value>
								<label>Nucleotide</label>
					<!--	added this back in, because it apparently works. -->	
								<value>protein</value>
								<label>Protein</label> 
							</vlist>
							<vdef>
								<value>dna</value>
							</vdef>
						</attributes>
					</parameter>
			
<!-- Estimate proportion of invariable sites, mlsearch is a precondition  -->
<!-- The control should be of type switch, but I need the value of the parameter to be either "I" or "", 
	 so I made it type Excl instead. -->
			
		<!-- enabled 1/20/2010 based on its inclusion in the black box -->
				 
<!-- Set the model for Nucleotide sequences  -->
					<parameter type="Excl" issimple="0" ismandatory="1">
						<name>dna_model</name>
						<attributes>
							<prompt>Model for Tree Inference with DNA data (-m)</prompt>
							<format>
								<language>perl</language>
								<code>"-m $value"</code>
							</format>
							<vlist>
								<value>GTRCAT</value>
								<label>GTRCAT</label>
								<value>GTRGAMMA</value>
								<label>GTRGAMMA</label>
							</vlist>
							<vdef>
								<value>GTRCAT</value>
							</vdef>
							<group>12</group>
							<precond>
								<language>perl</language>
								<code>$datatype eq "dna"</code>
							</precond>
							<ctrls>
								<ctrl>
									<message>Please choose either GTRCAT or GTRGAMMA as the model</message>
									<language>perl</language>
									<code> $datatype eq "dna" &amp;&amp; $dna_model ne "GTRCAT" &amp;&amp; $dna_model ne "GTRGAMMA"</code>
								</ctrl>
							</ctrls>
							<comment>
<value>The GTRCAT option specifies: GTR + Optimization of substitution rates + Optimization of site-specific evolutionary rates
which are categorized into numberOfCategories distinct rate categories for greater computational
efficiency. The GTRGAMMA option specifies: GTR + GAMMA model of rate heterogeneity. This uses 
4 hard-coded discrete rates to discretize the GAMMA distribution.</value>
							</comment>
						</attributes>
					</parameter>
					
<!--   AMINO ACIDS:

"-m PROTCATmatrixName[F]": specified AA matrix + Optimization of substitution rates + Optimization of site-specific
	evolutionary rates which are categorized into numberOfCategories distinct rate categories for greater computational efficiency.

"-m PROTGAMMAmatrixName[F]": specified AA matrix + GAMMA model of rate heterogeneity. This uses 4 hard-coded discrete
	rates to discretize the GAMMA distribution.

With the optional "F" appendix you can specify if you want to use empirical base frequencies 
Please note that for partitioned models you can specify the per-gene/per-partition AA model in the mixed model file 
	(see standard RAxML manual for details). 
Also note that, if you estimate AA GTR parameters on a partitioned dataset, they will be linked (estimated jointly) 
across all partitions to avoid over-parametrization.
 -->
               		
					<parameter type="Excl" ismandatory="1">
						<name>prot_sub_model</name>
						<attributes>
							<prompt>Model for Tree Inference with Protein data (-m)</prompt>
							<precond>
								<language>perl</language>
								<code>$datatype eq "protein"</code>
							</precond>
							<format>
								<language>perl</language>
								<code>"-m $value$prot_matrix_spec$empirical"</code>
							</format>
							<vlist>
								<value>PROTCAT</value>
								<label>PROTCAT</label>
								<value>PROTGAMMA</value>
								<label>PROTGAMMA</label>
							</vlist>
							<vdef>
								<value>PROTCAT</value>
							</vdef>
							<ctrls>
								<ctrl>
									<message>Please choose either PROTCAT or PROTGAMMA as the model</message>
									<language>perl</language>
									<code> $datatype eq "protein" &amp;&amp; $prot_sub_model ne "PROTCAT" &amp;&amp; $prot_sub_model ne "PROTGAMMA"</code>
								</ctrl>
							</ctrls>
							<group>12</group>
						</attributes>
					</parameter>
		
<!--Available AA substitution models: DAYHOFF, DCMUT, JTT, MTREV, WAG, RTREV, CPREV, VT, BLOSUM62, MTMAM, LG, MTART, 
	MTZOA, PMB, HIVB, HIVW, JTTDCMUT, FLU, AUTO, GTR 
-->		
						<parameter type="Excl" ismandatory="1" issimple="0">
						<name>prot_matrix_spec</name>
						<attributes>
							<prompt>Protein Substitution Matrix</prompt>
							<precond>
								<language>perl</language>
								<code>$datatype eq "protein"</code>
							</precond>
							<vlist>
								<value>DAYHOFF</value>
								<label>DAYHOFF</label>
								<value>DCMUT</value>
								<label>DCMUT</label>
								<value>JTT</value>
								<label>JTT</label>
								<value>MTREV</value>
								<label>MTREV</label>
								<value>WAG</value>
								<label>WAG</label>
								<value>RTREV</value>
								<label>RTREV</label>
								<value>CPREV</value>
								<label>CPREV</label>
								<value>VT</value>
								<label>VT</label>
								<value>BLOSUM62</value>
								<label>BLOSUM62</label>
								<value>MTMAM</value>
								<label>MTMAM</label>
								<value>LG</value>
								<label>LG</label>
								<value>MTART</value>
								<label>MTART</label>
								<value>MTZOA</value>
								<label>MTZOA</label>
								<value>PMB</value>
								<label>PMB</label>
								<value>HIVB</value>
								<label>HIVB</label>
								<value>HIVW</value>
								<label>HIVW</label>
								<value>JTTDCMUT</value>
								<label>JTTDCMUT</label>
								<value>FLU</value>
								<label>FLU</label>
								<value>AUTO</value>
								<label>AUTO</label>
								<value>GTR</value>
								<label>GTR</label>
							</vlist>
							<vdef>
								<value>DAYHOFF</value>
							</vdef>
							<ctrls>
								<ctrl>
									<message>Sorry, you cannot use the "AUTO" option with a partitioned dataset</message>
									<language>perl</language>
									<code>$prot_matrix_spec eq "AUTO" &amp;&amp; defined $partition</code>
								</ctrl>		
							</ctrls>
<!--The AUTO ?model? is a new option (as of RAxML-Light v1.0.2) that will automatically determine the best (with respect to the 
	likelihood) protein substitution matrix. Essentially, every time RAxML re-estimates the model parameters during the tree search,
	it will loop over all protein substitution models (DAYHOFF, DCMUT, ..., FLU) except GTR and just use the model that yields the
	best likelihood. WARNING: AUTO should currently not be used for partitioned datasets, we have not figured out yet what the best
	way to determine this is, especially when branch lengths are jointly estimated across partirtions. AUTO also can be called in two
	flavors AUTO and AUTOF (using empirical base frequencies instead of the pre-defined ones). Typically you would want to use
	AUTOF since the likelihood scores will be better.-->
							
							<comment>
<value>Note: FLOAT and invariable sites (I) options are not exposed here. If you require this option, please contact mmiller@sdsc.edu.</value>
<value>-m PROTCATmatrixName[F] uses the specified AA matrix + Optimization of substitution rates + Optimization of site-specific 
	evolutionary rates which are categorized into numberOfCategories distinct rate categories for greater computational efficiency.
</value>
<value>-m PROTGAMMAmatrixName[F] uses the specified AA matrix + GAMMA model of rate heterogeneity. This uses 4 hard-coded discrete rates to discretize the GAMMA distribution.
</value>
<value>Available AA substitution models: DAYHOFF, DCMUT, JTT, MTREV, WAG, RTREV, CPREV, VT, BLOSUM62, MTMAM, LG, MTART, MTZOA, PMB,
	HIVB, HIVW, JTTDCMUT, FLU, AUTO, GTR. With the optional "F" appendix you can specify if you want to use empirical base
	frequencies.</value>
<value> AUTO should currently not be used for partitioned datasets, we have not figured out yet what the best
way to determine this is, especially when branch lengths are jointly estimated across partitions. AUTO also can be called in two
flavors AUTO and AUTOF (using empirical base frequencies instead of the pre-defined ones). Typically you would want to use
AUTOF since the likelihood scores will be better.</value>
							</comment>
						</attributes>
					</parameter>

<!-- Empirical Base Frequencies -->
<!-- datatype=protein is a precondition, adds -F to end of -m model string; switch isnt used because it adds a 0! -->		
		<parameter issimple="0" type="Excl" ismandatory="1">
			<name>empirical</name>
			<attributes>
				<prompt>Use empirical base frequencies?</prompt>
				<precond>
					<language>perl</language>
					<code>$datatype eq "protein"</code>
				</precond>
				<vlist>
					<value>F</value>
					<label>yes</label>
					<value></value>
					<label>no</label>
				</vlist>
				<vdef>
					<value></value>
				</vdef>
				<group>2</group>
				<comment>
<value>The empirical base frequency command is relevant for the protein datatype, and is used as a suffix to the -m model string PROTGAMMA_____
</value>
				</comment>
			</attributes>
		</parameter>
		
<!-- category (-c) -->
					<parameter type="Integer" issimple="0" ismandatory="1">
						<name>number_cats</name>
						<attributes>
							<prompt>Specify the number of distinct rate categories (-c, default = 25)</prompt>
							<format>
								<language>perl</language>
								<code>(defined $value)? " -c $value" : "" </code>
							</format>
							<vdef>
								<value>25</value>
							</vdef>
							<group>13</group>
<!-- valid only for CAT models -->
							<precond>
								<language>perl</language>
								<code>($datatype eq "dna" &amp;&amp; $dna_model eq "GTRCAT") || ($datatype eq "protein" &amp;&amp; $prot_sub_model eq "PROTCAT")</code>
							</precond>
							<comment>
					<value>This option allows you to specify the number of distinct rate categories, into which the individually optimized rates for each individual site are thrown under -m GTRCAT. The default of -c 25 works fine in most practical cases.
</value>
							</comment>
						</attributes>
					</parameter>
			
			</parameters>
			</paragraph>
		</parameter>

<!-- Configure the searches  -->
<parameter type="Paragraph">
	<paragraph>
		<name>configure_search</name>
		<prompt>Search Configuration Parameters</prompt>
		<parameters>

	<!--      2-parshours   (max wall time to generate parsimony tree)  -->	
					<parameter type="Integer" ismandatory="1" issimple="0">
						<name>pars_hours</name>
						<attributes>
							<prompt>Maximum time in hours to generate a starting parsimony tree (default = 1 h; --parshours)</prompt>
							<format>
								<language>perl</language>
								<code>(defined $value) ? " --parshours $value ":""</code>
							</format>
							<vdef>
								<value>1</value>
							</vdef>
							<ctrls>
								<ctrl>
									<message>Please enter the maximum time in hours for a starting parsimony tree search (default = 1 h)</message>
									<language>perl</language>
									<code>!defined $rsearch_seed</code>
								</ctrl>
							</ctrls>
							<group>16</group>
							<comment>
<value>The parsimony starting tree is created by parsimonator or by RAxML light for each input file and each replica data set if you are running bootstraps.
This paramter should help control the total run time of the program.</value>
							</comment>
						</attributes>
					</parameter>

<!-- this sets -b, which is user-determined, and by default - 12345 -->
					<parameter type="Integer" ismandatory="1" issimple="0">
						<name>rsearch_seed</name>
						<attributes>
							<prompt>Set seed for generating first parsimony tree (-p, default = 12345)</prompt>
							<format>
								<language>perl</language>
								<code>(defined $value) ? " -p $value ":""</code>
							</format>
							<vdef>
								<value>12345</value>
							</vdef>
							<group>17</group>
							<comment>
<value>Keeping the same seed value makes the starting trees comparable between runs.</value>
							</comment>
						</attributes>
					</parameter>
			
<!-- Regular searches iterations are set by the user; default=20; 
The search jobs account for most of the usage.  For the default parameters, there will be 30 search jobs. 
Each of these will run on all 32 cores of a node and so will consume 32 core-hours per wall-clock hour.
  -->
					<parameter type="String" ismandatory="1">
						<name>num_rsearches</name>
						<attributes>
							<prompt>Number of regular searches to perform (-rsearches)</prompt>
							<format>
								<language>perl</language>
								<code>(defined $value) ? " --rsearches $value " : ""</code>
							</format>
							<vdef>
								<value>20</value>	
							</vdef>
							<ctrls>
								<ctrl>
									<message>Sorry, the maximum number of regular searches is 100</message>
									<language>perl</language>
									<code>$num_rsearches &gt; 100 </code>
								</ctrl>
							</ctrls>
							<group>14</group>
							<comment>
<value>This parameter sets the number of regular likelihood searches on the input data set. Regular searches are the likelihood searches on the input data. They are slow
and accurate. The maximum number of regular searches is 100</value>
							</comment>
						</attributes>
					</parameter>
		
<!--      2-searchhours   (max wall time to do boot searches)  -->
					<parameter type="Integer" ismandatory="1" issimple="0">
						<name>search_hours</name>
						<attributes>
							<prompt>Maximum time for a Search (default = 1 h)</prompt>
							<format>
								<language>perl</language>
								<code>(defined $value) ? " --searchhours $value ":""</code>
							</format>
							<vdef>
								<value>1</value>
							</vdef>
							<ctrls>
								<ctrl>
									<message>Please enter a value for the maximum time for a search (default = 1 h)</message>
									<language>perl</language>
									<code>!defined $search_hours</code>
								</ctrl>
							</ctrls> 
							<group>15</group>
							<ctrls>
								<ctrl>
									<message>Sorry, the number of total hours for regular searches must not exceed 1000</message>
									<language>perl</language>
									<code>$num_rsearches * $search_hours &gt; 1000 </code>
								</ctrl>
							</ctrls>
							<warns>
							<!--<warn>
									<message>ALERT: RaxML-Light Code is CPU intensive. We recommend that you set the number of search hours to a small value (0.5 or 1) and do a test run to estimate overall consumption</message>
									<language>perl</language>
									<code>$search_hours &gt; 1</code>
							</warn> -->
<!-- if -->
								<!-- cond 1 max bsearchs/rsearches, search hours = 1 -->
								<warn>
									<message>ALERT: You have configured a run that could require more than 5,000 cpu hrs. CPU use can be calculated from the following formula: [(number of bsearches + number of rsearches)*(maximum parsimony search hours) + 8 * maximum search hours)]+ 4. For the default configuration, the maximum consumption is 1084 cpu hrs.</message>
									<language>perl</language>
									<code>$num_bsearches == 500 &amp;&amp;  $num_rsearches == 100 &amp;&amp; $search_hours == 1 </code>
								</warn>
								<!-- cond 2 bsearches gt=250 and r searches gt=50 search hrs between 2 and 4 -->	
								<warn>
									<message>ALERT: You have configured a run that could require between 5,000  and 10,000 cpu hrs. CPU use can be calculated from the following formula: [(number of bsearches + number of rsearches)*(maximum parsimony search hours) + 8 * maximum search hours)]+ 4. </message>
									<language>perl</language>
									<code>$num_bsearches &gt; 249 &amp;&amp;  $num_rsearches &gt; 49 &amp;&amp; $search_hours &gt; 1 &amp;&amp; $search_hours &lt; 5 </code>
								</warn>
								<!-- cond 3 bsearches 100-250 rsearches 20-50, AND search hours 5 -->
								<warn>
									<message>ALERT: You have configured a run that could require between 6,000  and 13,000 cpu hrs. CPU use can be calculated from the following formula: [(number of bsearches + number of rsearches)*(maximum parsimony search hours) + 8 * maximum search hours)]+ 4. </message>
									<language>perl</language>
									<code>$num_bsearches &gt; 99 &amp;&amp;  $num_bsearches &lt; 251 &amp;&amp; $num_rsearches &gt; 19 &amp;&amp; $num_rsearches &lt; 51 &amp;&amp; $search_hours == 5 </code>
								</warn>	
								<!-- cond 4 besearches more than 250, rsearches more than 50 search hours 5 -->
								<warn>
									<message>ALERT: You have configured a run that could require between 12,000  and 24,000 cpu hrs. CPU use can be calculated from the following formula: [(number of bsearches + number of rsearches)*(maximum parsimony search hours) + 8 * maximum search hours)]+ 4. </message>
									<language>perl</language>
									<code>$num_bsearches &gt; 249 &amp;&amp; $num_rsearches &gt; 50 &amp;&amp; $search_hours == 5 </code>
								</warn>
								<!-- cond 4b besearches more than 250, rsearches more than 50 search hours 6 -->
								<warn>
									<message>ALERT: You have configured a run that could require between 15,000  and 30,000 cpu hrs. CPU use can be calculated from the following formula: [(number of bsearches + number of rsearches)*(maximum parsimony search hours) + 8 * maximum search hours)]+ 4. </message>
									<language>perl</language>
									<code>$num_bsearches &gt; 249 &amp;&amp; $num_rsearches &gt; 50 &amp;&amp; $search_hours == 6</code>
								</warn>
								<!-- cond 5 besearches more than 250, rsearches more than 50 search hours 7 -->
								<warn>
									<message>ALERT: You have configured a run that could require between 17,000  and 34,000 cpu hrs. CPU use can be calculated from the following formula: [(number of bsearches + number of rsearches)*(maximum parsimony search hours) + 8 * maximum search hours)]+ 4. </message>
									<language>perl</language>
									<code>$num_bsearches &gt; 249 &amp;&amp; $num_rsearches &gt; 50 &amp;&amp; $search_hours == 7 </code>
								</warn>
								<!-- cond 6 besearches more than 250, rsearches more than 50 search hours 8 -->
								<warn>
									<message>ALERT: You have configured a run that could require between 20,000  and 40,000 cpu hrs. CPU use can be calculated from the following formula: [(number of bsearches + number of rsearches)*(maximum parsimony search hours) + 8 * maximum search hours)]+ 4. </message>
									<language>perl</language>
									<code>$num_bsearches &gt; 249 &amp;&amp; $num_rsearches &gt; 50 &amp;&amp; $search_hours == 8 </code>
								</warn>
								<!-- cond 7 besearches more than 250, rsearches more than 50 search hours 9/10 -->
								<warn>
									<message>ALERT: You have configured a run that could require between 20,000  and 50,000 cpu hrs. CPU use can be calculated from the following formula: [(number of bsearches + number of rsearches)*(maximum parsimony search hours) + 8 * maximum search hours)]+ 4. </message>
									<language>perl</language>
									<code>$num_bsearches &gt; 249 &amp;&amp; $num_rsearches &gt; 50 &amp;&amp; $search_hours &gt; 8 </code>
								</warn>
								<!-- cond 8 bsearches 100-250 rsearches 20-50, AND search hours 6 -->
								<warn>
									<message>ALERT: You have configured a run that could require between 6,000  and 14,000 cpu hrs. CPU use can be calculated from the following formula: [(number of bsearches + number of rsearches)*(maximum parsimony search hours) + 8 * maximum search hours)]+ 4. </message>
									<language>perl</language>
									<code>$num_bsearches &gt; 99 &amp;&amp;  $num_bsearches &lt; 250 &amp;&amp; $num_rsearches &gt; 19 &amp;&amp; $num_rsearches &lt; 51 &amp;&amp; $search_hours == 6 </code>
								</warn>	
								<!-- cond 9 bsearches 100-250 rsearches 20-50, AND search hours 7 -->
								<warn>
									<message>ALERT: You have configured a run that could require between 7,000  and 17,000 cpu hrs. CPU use can be calculated from the following formula: [(number of bsearches + number of rsearches)*(maximum parsimony search hours) + 8 * maximum search hours)]+ 4. </message>
									<language>perl</language>
									<code>$num_bsearches &gt; 99 &amp;&amp;  $num_bsearches &lt; 250 &amp;&amp; $num_rsearches &gt; 19 &amp;&amp; $num_rsearches &lt; 51 &amp;&amp; $search_hours == 7 </code>
								</warn>	
								<!-- cond 10 bsearches 100-250 rsearches 20-50, AND search hours 8 -->
								<warn>
									<message>ALERT: You have configured a run that could require between 8,000  and 20,000 cpu hrs. CPU use can be calculated from the following formula: [(number of bsearches + number of rsearches)*(maximum parsimony search hours) + 8 * maximum search hours)]+ 4. </message>
									<language>perl</language>
									<code>$num_bsearches &gt; 99 &amp;&amp;  $num_bsearches &lt; 250 &amp;&amp; $num_rsearches &gt; 19 &amp;&amp; $num_rsearches &lt; 51 &amp;&amp; $search_hours == 8 </code>
								</warn>	
								<!-- cond 11 bsearches 100-250 rsearches 20-50, AND search hours 9 -->
								<warn>
									<message>ALERT: You have configured a run that could require between 9,000  and 22,000 cpu hrs. CPU use can be calculated from the following formula: [(number of bsearches + number of rsearches)*(maximum parsimony search hours) + 8 * maximum search hours)]+ 4. </message>
									<language>perl</language>
									<code>$num_bsearches &gt; 99 &amp;&amp;  $num_bsearches &lt; 250 &amp;&amp; $num_rsearches &gt; 19 &amp;&amp; $num_rsearches &lt; 51 &amp;&amp; $search_hours == 9 </code>
								</warn>	
								<!-- cond 12 bsearches 100-250 rsearches 20-50, AND search hours 10 -->
								<warn>
									<message>ALERT: You have configured a run that could require between 10,000  and 24,000 cpu hrs. CPU use can be calculated from the following formula: [(number of bsearches + number of rsearches)*(maximum parsimony search hours) + 8 * maximum search hours)]+ 4. </message>
									<language>perl</language>
									<code>$num_bsearches &gt; 99 &amp;&amp;  $num_bsearches &lt; 250 &amp;&amp; $num_rsearches &gt; 19 &amp;&amp; $num_rsearches &lt; 51 &amp;&amp; $search_hours == 10 </code>
								</warn>	

							</warns>
							<comment>
<value>The value entered here sets the maximum wall-clock time in hours for a regular (slow) search. Default is 1 h; the total hours in a regular search set must not exceed 
1000. </value>
							</comment>
						</attributes>
					</parameter>	
			
<!--   -D     ML search convergence criterion. This will break off ML searches if the relative Robinson- 
              Foulds topological distance between the pair of trees trees obtained from two consecutive 
              lazy SPR cycles for improving the likelihood of the tree is smaller or equal to 1%. 
              Usage is highly recommended for very large datasets in terms of taxa. This option will 
              avoid the program spending a large amount of processor time to obtain only slight   
              improvements in the likelihood score.-->
					<parameter type="Switch" ismandatory="1">
						<name>use_mlsearchcc</name>
						<attributes>
							<prompt>Apply ML search convergence criterion to regular searches (-D)</prompt>
							<format>
								<language>perl</language>
								<code>($value) ? " --mlsearchcc " : ""</code>
							</format>
							<vdef>
								<value>0</value>	
							</vdef>
							<group>14</group>
							<comment>
<value>The ML search convergence criterion breaks off ML searches if the relative Robinson-Foulds topological
distance between the pair of trees trees obtained from two consecutive lazy SPR cycles for improving the likelihood
of the tree is smaller or equal to 1%. Usage is highly recommended for very large datasets in terms of taxa. This
option will prevent spending a large amount of processor time to obtain only slight improvements in the
likelihood score</value>
							</comment>
						</attributes>
					</parameter>
		
<!-- Bootstrap iterations are set by the user; default=100  -->
					<parameter type="String" ismandatory="0">
						<name>num_bsearches</name>
						<attributes>
							<prompt>Number of bootstrap searches to perform (-bsearches)</prompt>
							<format>
								<language>perl</language>
								<code>(defined $value) ? " --bsearches $value " :""</code>
							</format>
							<vdef>
								<value>100</value>	
							</vdef>
							<group>18</group>
							<ctrls>
								<ctrl>
									<message>Sorry, the maximum number of bootstrap searches is 500</message>
									<language>perl</language>
									<code>$num_bsearches &gt; 500 </code>
								</ctrl>
							</ctrls>
							<comment>
<value>This parameter sets the number of bootstrap searches. Each Bootstrap run generates a modified replica alignment, infers a parsimony tree, and runs a
	rapid bootstrap likelihood tree inference algorithm. The maximum number of bootstrap searches permitted is 500. The results are used for convergence appraisal, support values
and possibly as a starting tree for regular searches.</value>
							</comment>
						</attributes>
					</parameter>
					
<!-- this sets -b, which is user-determined, and by default - 12345 -->
					<parameter type="String" ismandatory="1" issimple="0">
						<name>bootstrap_seed</name>
						<attributes>
							<prompt>Provide a bootstrap seed (-b, default = 12345 )</prompt>
							<format>
								<language>perl</language>
								<code>(defined $value) ? " -b $value ":""</code>
							</format>
							<vdef>
								<value>12345</value>
							</vdef>
							<group>19</group>
							<comment>
<value>Keeping the same seed value allows a comparison between runs.</value>
							</comment>
						</attributes>
					</parameter>
		
<!-- 2-usebest: use best trees found in bootstrap searches for regular searches on original alignment -->
<!-- removed from interface: 
	
Wayne said: 
I thought turning on "usebest" would give better solutions, but I haven't seen that in my limited testing.  
The overall elapsed time could be somewhat longer when "usebest" is on.

					<parameter type="Switch">
						<name>usebest</name>
						<attributes>
						<prompt>Use best trees found in bootstrap searches for regular searches on the original sequence alignment (-usebest)</prompt>
						<format>
							<language>perl</language>
							<code> ($value) ? " **usebest ":""</code>
						</format>
						<vdef>
							<value>0</value>
						</vdef>
						<group>7</group>
						<ctrls>
							<ctrl>
								<message>Sorry, to use the -usebest option the number of bootstrap searches must be greater than or equal to the number of regular searches</message>
								<language>perl</language>
								<code>$bsearches &lt; $rsearches</code>
							</ctrl>
						</ctrls>
						<comment>
<value>The -usebest option selects the best tree from a set of bootstrap searches to begin regular searches. If this
	 option is not selected (add text here)</value>
						</comment>
						</attributes>
					</parameter> -->

<!-- -I  test for bootstopping convergence -->
<!-- This option is used when a bootstrap analysis is already completed.
	
		[-I autoFC|autoMR|autoMRE|autoMRE_IGN] a posteriori bootstopping analysis. Use:
             "-I autoFC" for the frequency-based criterion
             "-I autoMR" for the majority-rule consensus tree criterion
             "-I autoMRE" for the extended majority-rule consensus tree criterion
             "-I autoMRE_IGN" for metrics similar to MRE, but include bipartitions under the threshold whether they are compatible
             or not. This emulates MRE but is faster to compute. For any of these options, you also need to pass a tree file containing several bootstrap replicates via "-z" -->
<!--                   <parameter type="Switch">
						<name>use_apobootstopping</name>
						<attributes>
							<prompt>Use a posteriori bootstopping</prompt>
							<vdef>
								<value>0</value>
							</vdef>							
							<comment>
<value>This option is used when a bootstrap analysis is already completed. Upload an input file, a tree, and bootstrapped trees. You must upload a set of bootstrapped trees uploaded as a single file using the -z option.  Once this selection is made, the user must select whether the bootstopping threshold is determined using frequency criteria or majority rule criteria</value>
							</comment>						
						</attributes>
					</parameter> -->
					
<!-- a priori bootstopping (-I) the bootstrap values are provided from the script, rather than upload -->	
					<parameter type="Excl" ismandatory="1">
						<name>aposterior_bootstopping</name>
						<attributes>
							<prompt>Select the criterion for a posteriori bootstopping analysis (-I)</prompt>
<!--	always used for 	<precond>
								<language>perl</language>
								<code>$use_apobootstopping</code>
							</precond>	-->							
							<format>
								<language>perl</language>
								<code>"-I $value"</code>
							</format>
							<vlist>
								<value>autoFC</value>
								<label>autoFC</label>
								<value>autoMR</value>
								<label>autoMR</label>
								<value>autoMRE</value>
								<label>autoMRE</label>
								<value>autoMRE_IGN</value>
								<label>autoMRE_IGN</label>
							</vlist>
							<vdef>
								<value>autoMRE</value>
							</vdef>
							<group>20</group>
								<comment>
<value>Once searches are completed, a convergence evaluation is run on the set of bootstrapped trees produced.
This option allows the user to select the criterion used in this a posteriori bootstopping analysis. 
Use: autoFC for the frequency-based criterion, autoMR for the majority-rule consensus tree criterion, 
autoMRE for the extended majority-rule consensus tree criterion and autoMRE_IGN for metrics similar to MRE, 
but includes bipartitions under the threshold whether they are compatible or not. This emulates MRE but is faster to compute.</value>
								</comment>
						</attributes>
					</parameter>
				
			</parameters>
		</paragraph>
	</parameter>
		
<!-- -n argument to specify output file suffix is required; here we let the user specify -->
<!-- commented out for now, the names are determined internally and cant be set this way
					<parameter type="String" ishidden="0">
						<name>outsuffix</name>
						<attributes>
						<format>
							<language>perl</language>
							<code>" -n $value"</code>
						</format>
						<group>1</group>
						</attributes>
					</parameter> -->
			
	</parameters>
</pise>
