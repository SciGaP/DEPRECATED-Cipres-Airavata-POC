<?xml version="1.0" encoding="ISO-8859-1"?>
<!DOCTYPE pise SYSTEM "http://www.phylo.org/dev/rami/PARSER/pise.dtd" [
<!ENTITY runtime SYSTEM "http://www.phylo.org/dev/rami/XMLDIR/triton_run_time.xml">
]>
<!--
	This is for running a paup tree improvement using the CIPRES framework
	as we do on the original cipres portal
-->

<pise>	
	<head>
		<title>PAUPRat exp</title>
		<version>Not specified</version>
		<description>Parsimony ratchet searches using PAUP*</description>
		<authors>Derek Sikes and Paul O. Lewis; David Swofford is the author of PAUP; Kevin Nixon is author of the Ratchet</authors>
		<reference>
Sikes, D., and Lewis, P.O., "PAUPRat: A tool to implement Parsimony and Likelihood Ratchet searches using PAUP*" http://users.iab.uaf.edu/~derek_sikes/software2.htm
		</reference>
		<reference>
			Swofford, D. L. 2003. PAUP*. Phylogenetic Analysis Using Parsimony (*and Other Methods). 
			Version 4. Sinauer Associates, Sunderland, Massachusetts.
		</reference>
		<category>Phylogeny / Alignment</category>
		<doclink>http://paup.csit.fsu.edu</doclink>
	</head>
	
	<command>pauprat_exp</command>
<!--********************************************************************************************************************************
	This interface was created by mamiller on or around 5/1/2010
	*********************************************************************************************************************************
From Terri's notes: 

First of all, here's how it works from the command line, assuming your input file is 12Tx432C.nex:

1. Run "pauprat".  This creates "setup.nex".

2. Edit "setup.nex".  You need to at least set "nchar" to correspond to your nexus file.
I also added
  stopcmd "filter best=yes permdel=yes";
  stopcmd "savetrees file=mydata.best.tre"; before stopcmd quit, as suggested in http://www.brianomeara.info/tutorials/phylogenetics#ratchet
I don't know how to do it but it would be nice to add a paup command to create a consensus tree from the results.

3. Run "pauprat setup.nex" to create ratchet.nex

4. Run "paup".  At the prompt, enter
    - execute 12Tx432C.nex
    - execute ratchet.nex
    - quit

5. A couple things I don't know yet:
    - what happens when you supply a starting tree.  Is it used or ignored?
    - how to produce a consensus tree.  Should be a paup command to do so.

********************************************************************************************************************************
Suggested Protocol (from the manual): 

1. Read through this NEXUS file, if the PAUP* commands are alien to you, it might be best to familiarize yourself with PAUP* 
	command line terminology by reading through the pertinent sections of the PAUP* manual (obtainable from: http://www.lms.si.edu/PAUP/ ).
	Also read Nixon's (1999b) paper describing the Parsimony Ratchet, which describes his method in greater detail. 

2. Create a folder/directory in which your PAUPRat files will reside. Place the application/executable PAUPRat in this folder. 

3. Create a setup file for PAUPRat to read, with instructions on how the Ratchet batch file for PAUP* should be made. 
	A non-annotated version of this file can be generated by launching PAUPRat, leaving the argument line blank, and hitting OK
	(if using the Windows version, run PAUPRat from an MS-DOS command line). The file created will be named setup.nex and 
	should need only minor modification. NOTE: the names of all files made should have no spaces in them. 

4. Execute/launch PAUPRat, which is command-line-driven, and type the name of the setup file you created in step 3 
	(which must be in the same folder/directory). 

5. Hit return and PAUPRat should generate a batch file named ratchet.nex in the same folder/directory. 

6. Your data file and PAUP* do not have to be in the same directory. Launch PAUP* and execute your datafile. Then tell PAUP* to execute your 
	batch file (named ratchet.nex in step 5 above) using the 'File/Open' menu commands. PAUP* should implement a Parsimony Ratchet search 
	of your description. Note: on a Macintosh keep PAUP* as the frontmost application to give it top CPU priority (=maximum speed); and, use the
	 'windowshade' feature to collapse the display buffer when you are not reading it while the ratchet is running -this tends to save some time in 
	redrawing the screen -more noticable with smaller datasets. 

7. Upon completion of the search, PAUP* will indicate that all trees  are saved and it is safe to quit the program. Tree lengths for each iteration are displayed
	(see below) and all shortest trees are saved in the file mydata.tre. Note: without a search monitor box, a PAUP* search can be aborted on a Macintosh by
	 pressing the command and period (.) keys simultaneously. ] 

PAUPRat is driven by a Nexus file.
	
[ PAUPRat example setup file. Sikes, D. S. and P. O. Lewis. 2001. beta software, version 1. PAUPRat: PAUP* implementation of the parsimony ratchet.
Distributed by the authors. Department of Ecology and Evolutionary Biology, University of Connecticut, Storrs, USA. April 2001. Based on Kevin Nixon's 
Parsimony Ratchet as described in: Nixon, K. C. 1999. The Parsimony Ratchet, a new method for rapid parsimony analysis. Cladistics 15: 407-414. ] 

#Nexus
begin pauprat;  [invocation]

dimensions nchar=<integer>; [specify  the total number of characters, e.g. nchar=1428;] 

set terse seed=0 nreps=200 pct=15 wtmode=uniform; [set <arguments> <e.g.>]

[ pct=15 <integer>

Notes about nmod and pct: 
		* use nmod to specify absolute number of characters to perturb each iteration 
		* use pct to specify a percentage of characters to perturb each iteration 
		* do not use both nmod and pct simultaneously (if you do, the last one used wins) 
		* Nixon (1999b) states that perturbing between 5% and 25% of the total number of informative characters usually works well. 

seed=0 <integer>

Notes about random number seeds: 
		* set seed=0 tells PAUPRat to generate a random number seed using the system clock 
		* set seed=1 or other number to specify your personal favorite random number seed 
		* the random number seed determines the sequence of 'random' numbers used in choosing characters to perturb for each iteration 
		* running PAUPRat twice with the same random number seed (other than 0) will result in exactly the same characters being perturbed each iteration 
		* the safest thing to do is let PAUPRat choose a new seed each time you run it (by setting seed=0) 

nreps=200   <integer>

Notes about nreps: 
		* nreps specifies the number of Ratchet iterations to have PAUP* perform 
		* each iteration consists of a search under perturbed character weights followed by a second search under the original weights

wtmode=uniform; <string>

Notes about wtmode: 
		* use 'wtmode=uniform' to ensure that original weights are always 1 for all characters 
		* use 'wtmode=additive' to handle the case of unequal original weights in an additive way. 'additive' means a character originally weighted 10 will act just like 10 separate characters each weighted 1: it will be 10 times more likely to be chosen for perturbation than a character whose original weight was 1, but each time it is chosen, its weight will be incremented by just 1 
		* use 'wtmode=multiplicative' to handle the case of unequal original weights in a multiplicative way. If 'multiplicative' mode is chosen, a character originally 
			weighted 10 will increase its weight by 10 each time it is selected for perturbation, but it will not be any more likely to be chosen than a character whose
			original weight was 1 

terse or verbose <switch>

Notes about verbose and terse: 
		specify 'verbose' if you want comments in the output indicating which characters were perturbed and how much their weights changed for each iteration 
		normally, you want to specify 'terse' because these comments add a lot of bytes to the file and don't change the analysis at all 
		do not specify both 'terse' and 'verbose' -if you do, the last one specified wins ] 

[WTSET * UNTITLED =  <string> or <file> Specifies unequal original weights, for example: 

0: 1 55 78 81 85 90 94 101 104 106 111-112 120-121 126 132 138 140, 
10: 2-15 17-19 21-45 48-54 56-59 66 69 71 79 86 102-103 108-109 117-118 130 134-137 141-142, 1: 16 20 46 60-65 67-68 70 72-77 80 82-84 87-89 91-93 95-100 105 107 110 113-116 119 122-125 127-129 131 133 139, 5: 47; 

This works just like the equivalent command in PAUP* (allowing the wtset command to simply be copied directly from the original nexus data file), 
except that the asterisk is ignored in PAUPRat (if you put in a wtset command, it will be used by PAUPRat whether or not there is an asterisk). 

If you leave out the wtset command or specify wtmode=uniform in the set command, PAUPRat will behave just like you used this wtset command: 

wtset * allequalone = 1: 1-1428; 

Several commands may be used at this point: 

PAUPRat command :						When PAUP* will execute command :
*********************************************************************************************************************************************************
startcmd 										before ratchet has begun 
normcmd 										only when characters have their original weights 
rewtdcmd 										only when characters have their perturbed weights 
paupcmd 										both when characters have their perturbed weights AND when characters have their original weights
stopcmd 										only after the ratchet has finished 

Note: we have not found any use for rewtdcmd, but it has nevertheless been implemented just in case someone else finds a use for it. ] 

[Lines below create the starting tree:

If status=yes, PAUP* will show the search status for the starting tree but will also require a human to click 'close' after the starting tree is found
if status=no, the ratchet begins automatically after finding the starting tree and does not display the search status for that tree. ] 
 
startcmd 		"[!*************************************]"; 
startcmd 		"[!*********PAUP* Ratchet *********]"; 
startcmd 		"[!* Derek S. Sikes & Paul O. Lewis *]"; 
startcmd 		"[!* University of Connecticut *]"; 
startcmd 		"[!* March, 2000 *]"; 
startcmd 		"[!* Based on Kevin Nixon's Parsimony *]"; 
startcmd		"[!* Ratchet as described in: Nixon, *]"; 
startcmd 		"[!* K. C. 1999. The Parsimony Ratchet *]";
startcmd 		"[!* a new method for rapid parsimony *]";
startcmd 		"[!* analysis. Cladistics 15: 407-414. *]"; 
startcmd 		"[!*************************************]"; 
startcmd 		"[exe rbcl.nex]"; 
startcmd 		"log file=paupratchet.log";
startcmd 		"set increase=auto; 
startcmd 		"hs status=no nrep=1 swap=tbr start=stepwise addseq=random nchuck=1 chuckscore=1"; 

[ Line below creates master tree file in same folder as batch file ¬will have, upon completion, the same number of trees as iterations plus the starting tree ] 

startcmd "savetrees file=mydata.tre replace"; 

[ Line below creates temp tree file in same folder as batch file -will only hold the best original weight tree found of the most recent unpermuted search ] 

startcmd "savetrees file=mydata.tmp replace"; 

[ Line below sets multistate taxa to be treated as uncertainty rather than polymorphism -allows tree lengths to be comparable with those found by NONA ] 

paupcmd "pset mstaxa=uncertain"; 

[ The commands below implement the ratchet proper. After searches using the normal weights, the single tree held in memory is saved to the mydata.tmp file, replacing the existing file. Then all the trees from k previous iterations (in the mydata.tre file) are added (mode=7 means add rather than replace) to the tree in memory, and then these k+1 trees are saved to mydata.tre, replacing the existing file. Finally, the best tree from the most recent iteration (which was saved in mydata.tmp) is brought back into memory for use as the starting tree for the next iteration. ] 

paupcmd "hsearch status=no start=1 swap=tbr multrees=no"; normcmd "savetrees file=mydata.tmp replace"; normcmd "gettrees file=mydata.tre mode=7"; 
normcmd "savetrees file=mydata.tre replace"; normcmd "gettrees file=mydata.tmp mode=3 warntree=no"; normcmd "time"; 

[ Lines below pull all the trees found (1 per iteration plus the starting tree) from the master tree file, mydata.tre, into memory and tell PAUP* to display their scores 
note that the last iteration is tree #1 and the starting tree is the last tree listed ] 
stopcmd "gettrees file=mydata.tre mode=3"; 
stopcmd "pscores all"; 
stopcmd "time"; 
stopcmd "log stop"; 
stopcmd "[!**********************************]"; 
stopcmd "[!***THIS SEARCH IS COMPLETE ***]"; 
stopcmd "[!* A LOG FILE HAS BEEN WRITTEN *]"; 
stopcmd "[!* AND ALL TREES HAVE BEEN SAVED. *]"; 
stopcmd "[!* IT IS OK TO QUIT PAUP* *]"; 
stopcmd "[!**********************************]"; 
stopcmd "[quit]"; 

[ The line below tells PAUPRat to take the information above and go ahead and generate the PAUP* batch file, naming it ratchet.nex.
The replace keyword tells PAUPRat to replace the file ratchet.nex if it already exists. If you leave out the replace keyword, and the file exists, 
PAUPRat will terminate with an error message. Don't forget this line, without it PAUPRat will not create a batch file! ] 

write file=ratchet.nex replace; 
end; 

Notes 
Output of results: PAUPRat will have PAUP* list all the shortest tree lengths of each unperturbed iteration, but in reverse order
(such that tree #1 is the last iteration and tree #200 is the first of a 200 iteration run, tree #201 is the starting tree) like this: 

Tree# 12345678910 11 12 13 Length 16531 16531 16531 16531 16531 16531 16531 16531 16532 16531 16531 16531 16531 
Tree# 14 15 16 17 18 19 20 21 22 23 24 25 26 Length 16531 16531 16532 16532 16532 16532 16532 16532 16532 16532 16532 16532 16532 
Tree# 27 28 2930 31 32 33 34 35 36 37 38 39 Length 16532 16532 16532 16532 16532 16532 16532 16534 16534 16532 16532 16532 16532 
Tree# 40 41 42 43 44 45 46 47 48 49 50 51 52 Length 16532 16532 16532 16532 16532 16532 16532 16531 16531 16531 16531 16531 16531 
Tree# 53 54 55 56 57 58 59 60 61 62 63 64 65 Length 16531 16531 16531 16531 16531 16531 16531 16531 16531 16531 16531 16531 16531 
Tree# 66 67 68 69 70 71 72 73 74 75 76 77 78 
Length 16531 16531 16531 16531 16531 16531 16531 16531 16531 16531 16531 16531 16531 
Tree# 79 80 81 82 83 84 85 86 87 88 89 90 91 Length 16531 16531 16531 16531 16531 16531 16531 16531 16531 16531 16531 16531 16531 
Tree# 92 93 94 95 96 97 98 99 100 101 102 103 104 Length 16531 16531 16531 16531 16531 16531 16531 16531 16531 16531 16531 16531 16531 
Tree # 105 106 107 108 109 110 111 112 113 114 115 116 117 Length 16531 16531 16531 16531 16531 16531 16531 16531 16531 16531 16531 16531 16531 
Tree # 118 119 120 121 122 123 124 125 126 127 128 129 130 Length 16531 16531 16531 16531 16531 16531 16531 16531 16531 16531 16531 16531 16531 
Tree # 131 132 133 134 135 136 137 138 139 140 141 142 143 Length 16531 16531 16531 16531 16531 16531 16531 16531 16531 16531 16531 16531 16531 
Tree # 144 145 146 147 148 149 150 151 152 153 154 155 156 Length 16531 16531 16531 16531 16531 16531 16531 16531 16531 16531 16531 16531 16531 
Tree # 157 158 159 160 161 162 163 164 165 166 167 168 169 Length 16531 16531 16531 16531 16531 16531 16532 16532 16532 16533 16532 16532 16532 
Tree # 170 171 172 173 174 175 176 177 178 179 180 181 182 Length 16532 16532 16532 16532 16532 16532 16532 16532 16532 16532 16532 16532 16532 
Tree # 183 184 185 186 187 188 189 190 191 192 193 194 195 Length 16532 16532 16532 16532 16532 16532 16532 16532 16534 16535 16535 16535 16536 
Tree # 196 197 198 199 200 201 Length 16536 16536 16536 16536 16551 16554 

Once a Ratchet search has completed, all the shortest, unperturbed trees of each iteration are stored in the file namedmydata.tre. 
The trees in this file can be brought into PAUP* (using the TREES menu and the GET TREES FROM FILEoption) and filtered to keep only those of the 
shortest length which can then be made into a consensus tree. Nixon (1999b) and Goloboff (1999) argue that because the Ratchet does such a good job
of covering tree space that the consensus tree of a sufficient number of Ratchet searches will, in theory, be identical to the consensus of all shortest trees
for any given dataset. 

Thus a recommended strategy would be to first determine what percent of characters to perturb using some preliminary ratchet searches, 
then run 10 or 20 independent Ratchet searches and create a consensus tree from the combined results of all these searches. 

Once the consensus tree has stabilized, i.e. new searches don't change the topology, it should be accurate (Goloboff 1999). 

###################  Performing multiple Ratchet searches automatically: ################################
We have found, as did Nixon (1999b), that performing several,shorter Parsimony Ratchet searches is preferable to performing a single, longer search. To this
end one can create multiple folders each with a separate batch file and into which PAUP* will create output files. This allows one to start a search with one
command that proceeds uninterrupted through numerous (e.g. 10-20) independent Parsimony Ratchet searches of, say 200 iterations each. Most modern
computers should be able to complete 15 unattended runs of the rbcL dataset over a weekend using this strategy. To accomplish this on a Macintosh you
would first create your 10 to 20 folders and generate adifferent batch file for each using PAUPRat in each folder. Then write a single controlling batch file that
directs PAUP* to execute all the batch files you_ve created. The master batch file for 5 searches might look like this: 

#nexus 
begin paup; execute 'Mac harddrive:Folderinroot:batchfolder1:ratchet.nex'; execute 'Mac harddrive:Folderinroot:batchfolder2:ratchet.nex'; execute 'Mac harddrive:Folderinroot:batchfolder3:ratchet.nex'; execute 'Mac harddrive:Folderinroot:batchfolder4:ratchet.nex'; execute 'Mac harddrive:Folderinroot:batchfolder5:ratchet.nex'; end; 
Where, in this example, Mac harddrive is the name of your harddrive, Folderinroot, is the name of the folder in the root of your harddrive that contains the separate batch file folders, batchfolder1_ batchfolder2 etc. are the names of all the folders which contain the batch files, and ratchet.nex is the name of the batch file to be executed within each folder. 
The same strategy works for the Windows version of PAUP*: 
#nexus 
begin paup; execute 'C:\FolderInRoot\BatchFolder1\ratchet.nex'; execute 'C:\FolderInRoot\BatchFolder2\ratchet.nex'; execute 'C:\FolderInRoot\BatchFolder3\ratchet.nex'; execute 'C:\FolderInRoot\BatchFolder4\ratchet.nex'; execute 'C:\FolderInRoot\BatchFolder5\ratchet.nex'; end; 
A similar strategy could be implemented using a shell script in Unix. In this case, there is no need for multiple foldersbecause: 1) the Unix versions of PAUP* will automatically execute a file whose name is specified on the command line whenPAUP* is invoked; and 2) Unix commands can be inserted in the script between invocations of PAUP* to rename the log filefrom the previous run. Below is an example shell script. Two important modifications are needed to the setup.nex file to make this shell script work as expected. First, insert startcmd="exe rbcl.nex" as the first startcmd in your setup.nex file, replacing rbcl.nex of course with the name of your own data file. Second, insert stopcmd="quit" as the last stopcmd in your setup.nex file. These two modifications are present in the automatically-generated setup.nex file, but are commented out.Finally, it is assumed that the PAUP* executable is in a directory listed in the current PATH environmental variable, and theshell script should be run from the directory containing the ratchet.nex file. 
#!/bin/sh 
paup ratchet.nex mv -f paupratchet.log paupratchet1.log paup ratchet.nex mv -f paupratchet.log paupratchet2.log paup ratchet.nex mv -f paupratchet.log paupratchet3.log paup ratchet.nex mv -f paupratchet.log paupratchet4.log paup ratchet.nex mv -f paupratchet.log paupratchet5.log rm -f mydata.tre rm -f mydata.tmp 
Unequal original weights: One feature that Nixon_s implementation of the Ratchet did not cover was how to handle unequal starting weights. PAUPRat allows users to implement the Ratchet with data sets that have unequal starting weights (see commands in example setup file above). However, our testing of this feature indicates that the Ratchet searches do notbehave as they do with equal starting weights. As can be seen in Fig. 3 below, the searches do not plateau on the shortest tree lengths. This result is similar to what occurs with equal starting weights if one perturbs too many characters for each iteration. Nixon (1999b) states that he has found good results with between 5 and 25 % of the characters perturbed for each iteration. If too many characters are perturbed, say 50-70%, the results are much like in Fig. 3. So, if users wish to explorethe behavior of the Ratchet with unequal starting weights, we would be very interested in hearing your results. 
#################################################################################################

******************************************************************************************************************************** -->
<!-- command we intend to expose through PAUPRat are as follows:
PAUP Commands from portal 1:

default only 1 optimal tree: 		default hsearch swap=tbr multrees=no  timelimit=None reconlimit=Infinity [paup.Wrap.n.ratchet.reps=200] [paup.Wrap.ratchet.prop=0.2] [paup.Wrap.ratchet.seed=0];
change branch swapping algorithm:	default hsearch swap=spr multrees=no  timelimit=None reconlimit=Infinity [paup.Wrap.n.ratchet.reps=200] [paup.Wrap.ratchet.prop=0.2] [paup.Wrap.ratchet.seed=0];
    					default hsearch swap=nni multrees=no  timelimit=None reconlimit=Infinity [paup.Wrap.n.ratchet.reps=200] [paup.Wrap.ratchet.prop=0.2] [paup.Wrap.ratchet.seed=0];

reconlimit=Infinity or positive integer
rearrlimit=none or positive integer
timelimit=none or positive integer
[paup.Wrap.n.ratchet.reps=integer or null]
if paup.Wrap.n.ratchet.reps=null, then 
[paup.Wrap.ratchet.prop=0.2] and  [paup.Wrap.ratchet.seed=0] are invalid


if save all OPTIMAL trees=no;   set Increase =  is invalid, and maxtrees is invalid; also AutoInc= is invalid


if save all OPTIMAL trees=yes: 
and set increase=no			set Increase = no;  default hsearch swap=nni multrees=yes  timelimit=None reconlimit=Infinity [paup.Wrap.n.ratchet.reps=200] [paup.Wrap.ratchet.prop=0.2] [paup.Wrap.ratchet.seed=0];
maxtrees=<integer> is optional; autoincrease is invalid

if save all OPTIMAL trees=yes: 
and set Increase = auto;  		 set maxtrees=100; set Increase = auto; set AutoInc=100; default hsearch swap=nni multrees=yes  timelimit=None reconlimit=Infinity [paup.Wrap.n.ratchet.reps=200] [paup.Wrap.ratchet.prop=0.2] 	
set AutoInc=<integer> is optional	[paup.Wrap.ratchet.seed=0];
					

					default hsearch swap=tbr multrees=yes  timelimit=None reconlimit=Infinity [paup.Wrap.n.ratchet.reps=200] [paup.Wrap.ratchet.prop=0.2] [paup.Wrap.ratchet.seed=0];
set Increase =  <integer> is optional, and maxtrees=<integer> is optional; -->

<!-- the pauprat setup.nex file should look like this:
#nexus
[
  PAUPRat example setup file. Sikes, D. S. and P. O. Lewis. 2001. beta
  software, version 1. PAUPRat: PAUP* implementation of the parsimony
  ratchet. Distributed by the authors. Department of Ecology and
  Evolutionary Biology, University of Connecticut, Storrs, USA. April
  2001. Based on Kevin Nixon's Parsimony Ratchet as described in:
  Nixon, K. C.  1999.  The Parsimony Ratchet, a new method for rapid
  parsimony analysis.  Cladistics 15: 407-414.
]
begin pauprat;
  dimensions nchar=432;
  set seed=0 nreps=200 pct=15; [nmod=50]
  set wtmode=uniform; [choices for wtmode: mult, uniform, add]
  set terse [use either verbose or terse but not both];

  startcmd "[!*************************************]";
  startcmd "[!* ******** PAUP* Ratchet ****** *]";
  startcmd "[!*   Derek S. Sikes & Paul O. Lewis  *]";
  startcmd "[!*     University of Connecticut     *]";
  startcmd "[!*            March, 2000            *]";
  startcmd "[!* Based on Kevin Nixon's Parsimony  *]";
  startcmd "[!* Ratchet as described in: Nixon,   *]";
  startcmd "[!* K. C. 1999. The Parsimony Ratchet *]";
  startcmd "[!* a new method for rapid parsimony  *]";
  startcmd "[!* analysis. Cladistics 15: 407-414. *]";
  startcmd "[!*************************************]";
  startcmd "[exe 12Tx432C.nex]";
  startcmd "log file=paupratchet.log";
  startcmd "set increase=auto";
  startcmd "hs status=no nrep=1 swap=tbr start=stepwise addseq=random nchuck=1 chuckscore=1";
  startcmd "savetrees file=mydata.tre replace";
  startcmd "savetrees file=mydata.tmp replace";
  paupcmd "pset mstaxa=uncertain";
  paupcmd "hsearch status=no start=1 swap=tbr multrees=no";
  normcmd "savetrees file=mydata.tmp replace";
  normcmd "gettrees file=mydata.tre mode=7";
  normcmd "savetrees file=mydata.tre replace";
  normcmd "gettrees file=mydata.tmp mode=3 warntree=no";
  normcmd "time";
  stopcmd "gettrees file=mydata.tre mode=3";
  stopcmd "pscores all";
  stopcmd "time";
  stopcmd "log stop";
  stopcmd "[!**********************************]";
  stopcmd "[!*  THIS SEARCH IS COMPLETE   *]";
  stopcmd "[!*  A LOG FILE HAS BEEN WRITTEN   *]";
  stopcmd "[!* AND ALL TREES HAVE BEEN SAVED. *]";
  stopcmd "[!*     IT IS OK TO QUIT PAUP*     *]";
  stopcmd "[!**********************************]";

  stopcmd "filter best=yes permdel=yes";
  stopcmd "savetrees file=mydata.best.tre";

  stopcmd "[quit]";
write file=ratchet.nex;
end -->
<!-- ############## terri's suggested workflow #######################-->
<!-- So here's how to do it from a pise xml file:

1. Create parameters to let user enter nchar, and any other parameters you see in setup.nex that you want to let the user change.
2. pise xml needs to generate the setup.nex file instead of having pauprat create it.  Just use perl format statements to output all the lines of setup.nex to a parameter file.  
    You can use a hidden parameter to generate the boilerplate stuff that the user doesn't control.
3. pise xml needs to create a 2nd parameter file (let's say, "paup_commands.txt") with the commands for paup, i.e.:
    execute infile.nex;
    execute ratchet.nex;
    quit;
4.pise xml runs the command line:
    pauprat setup.nex &&  paup < paup_commands.txt
-->
	<parameters>
	&runtime;
<!--  PAUPRat is command-line-driven, so here we invoke, and supply the name of the setup (input in Nexus format) file which must be in the same folder/directory). -->
	<!-- this parameter just sets the invocation line pauprat setup.nex &&  paup < paup_commands.txt -->
    <parameter ismandatory="1" issimple="1" ishidden="1" type="String"> 
	<name>intiation_string</name>
		<attributes>
			<format>
				<language>perl</language>
				<!-- problem -->
				<code>"pauprat setup.nex &amp;&amp; paup &lt; paup_commands.txt"</code>
			</format>
			<group>0</group>
		</attributes>
	</parameter>
    

<!-- this element specifies that  the input file is named input.nex  -->	
	<parameter ismandatory="1" issimple="1" isinput="1" type="InFile"> 
	<name>matrix_file</name>
		<attributes>
			<filenames>infile.nex</filenames>	
			<group>0</group>
		</attributes>
	</parameter>
	
<!-- this element creates the file required by PAUP -->
<!-- pise xml needs to create a 2nd parameter file (let's say, "paup_commands.txt") with the commands for paup, i.e.:
    execute infile.nex;
    execute ratchet.nex;
    quit; -->
  <parameter type="String" ishidden="1">
	<name>paup_file</name>
		<attributes>
			<paramfile>paup_commands.txt</paramfile>	
			<group>0</group>
			<format>
					<language>perl</language>
					<code><![CDATA[ << "EOT"
execute infile.nex;
execute ratchet.nex;
quit;
EOT
					  ]]></code> 
				</format>
		</attributes>
	</parameter>
	
<!-- The section below creates the hardcoded parameter file setup.nex  -->
		<parameter type="String" ishidden="1">
			<name>parameter_file1</name>
			<attributes>
				<paramfile>setup.nex</paramfile>
				<group>1</group>
				<format>
					<language>perl</language>
					<code><![CDATA[ << "EOT"
#nexus\\n
 [PAUPRat example setup file. Sikes, D. S. and P. O. Lewis. 2001. beta software, version 1. PAUPRat: PAUP* implementation of the parsimony\\n
 ratchet. Distributed by the authors. Department of Ecology and Evolutionary Biology, University of Connecticut, Storrs, USA. April 2001. Based on\\n
 Kevin Nixon's Parsimony Ratchet as described in Nixon, K. C.  1999.  The Parsimony Ratchet, a new method for rapid parsimony analysis.  Cladistics 15: 407-414.]\\n
 \\n
begin pauprat;\\n 
EOT
					  ]]></code> 
				</format>
			</attributes>
		</parameter>
<!-- Step 1: Create the first part of the hardcoded parameter file setup.nex  -->
		<parameter type="String" ishidden="1">
			<name>parameter_file1</name>
			<attributes>
				<paramfile>setup.nex</paramfile>
				<group>2</group>
				<format>
					<language>perl</language>
					<code><![CDATA[ << "EOT"
#nexus\\n
 [PAUPRat example setup file. Sikes, D. S. and P. O. Lewis. 2001. beta software, version 1. PAUPRat: PAUP* implementation of the parsimony\\n
 ratchet. Distributed by the authors. Department of Ecology and Evolutionary Biology, University of Connecticut, Storrs, USA. April 2001. Based on\\n
 Kevin Nixon's Parsimony Ratchet as described in Nixon, K. C.  1999.  The Parsimony Ratchet, a new method for rapid parsimony analysis.  Cladistics 15: 407-414.]\\n
 \\n
begin pauprat;\\n 
EOT
					  ]]></code> 
				</format>
			</attributes>
		</parameter>
		
<!-- Step 2: Continue creating the hardcoded parameter file setup.nex 
  dimensions nchar=432;
  set seed=0 nreps=200 pct=15; [nmod=50]
  set wtmode=uniform; [choices for wtmode: mult, uniform, add]
  set terse [use either verbose or terse but not both];

Maximum number of trees saved (maxtrees).  
Automatically increase the number of trees in memory. + no yes 
Auto-increase amount (AutoInc).  

Heuristic Search Parameters
Branch Swapping Algorithm (swap) * TBR SPR NNI 
Save all optimal trees? (multrees) * yes no 
Maximum number of rearrangements (rearrlimit). Blank means unlimited.  
Maximum number of seconds to search (timelimit). Blank means unlimited.  
Reconnection limit (reconlimit). Blank means unlimited.  
Number of ratchet iterations (or blank if not ratcheting)  
Proportion of characters to reweight in ratchet +  
Pseudo-random number generator seed for ratchet. +  
 -->
  
<!-- specify chars in matrix -->
		<parameter type="Integer" issimple="1">
			<name>specify_nchar</name>
			<attributes>
				<prompt>How many characters in your matrix?</prompt>
				<paramfile>setup.nex</paramfile>
				<group>3</group>
				<format>
					<language>perl</language>
					<code><![CDATA[ <<"EOT"
dimensions nchar=$value;\\n
EOT
				]]></code>
				</format>
				<ctrls>
					<ctrl>
						<message>Please enter the number of characters in your matrix</message>
						<language>perl</language>
						<code>!defined $specify_nchar</code>
					</ctrl>
				</ctrls>
			</attributes>
		</parameter> 
		
<!-- START RATCHET COMMANDS -->

<parameter type="Paragraph">
	<paragraph>
		<name>ratchet_params</name>
		<prompt>Ratchet Parameters</prompt>
		<parameters>
		
		<parameter type="Integer">
			<name>specify_nreps</name>
			<attributes>
				<prompt>How many ratchet reps should be run?</prompt>
				<paramfile>setup.nex</paramfile>
				<group>4</group>
				<format>
					<language>perl</language>
					<code><![CDATA[ <<"EOT"
set nreps=$value;\\n 
EOT
					]]></code>
				</format>
				<vdef>
					<value>200</value>
				</vdef>
				<ctrls>
					<ctrl>
						<message>Please enter the number of ratchet reps</message>
						<language>perl</language>
						<code>!defined $specify_nreps</code>
					</ctrl>
				</ctrls>
			</attributes>
		</parameter> 
	
			<parameter type="Integer">
			<name>specify_seed</name>
			<attributes>
				<prompt>Set seed value</prompt>
				<paramfile>setup.nex</paramfile>
				<group>5</group>
				<format>
					<language>perl</language>
					<code><![CDATA[ <<"EOT" 
set seed=$value; \\n 
EOT
					]]></code>
				</format>
				<vdef>
					<value>0</value>
				</vdef>
				<ctrls>
					<ctrl>
						<message>Please enter a seed value</message>
						<language>perl</language>
						<code>!defined $specify_seed</code>
					</ctrl>
				</ctrls>
				<comment>
<value>If the seed value is set to 0, it tells PAUPRat to generate a random number seed for you. Otherwise, you may set to your preferred random number seed. 
The seed you choose determines the sequence of random numbers used in choosing characters to perturb for each iteration running PAUPRat twice with the same random number seed (other than 0) will result in exactly the same
 characters being perturbed each iteration the safest thing to do is let PAUPRat choose a new seed each time you run it.</value>
				</comment>
			</attributes>
		</parameter> 
		
		<parameter type="Integer">
			<name>specify_pct</name>
			<attributes>
				<paramfile>setup.nex</paramfile>
				<prompt>Specify the percentage of characters to perturb (-pct)</prompt>
				<group>6</group>
				<precond>
					<language>perl</language>
					<code>!defined $specify_mod</code>
				</precond>
				<format>
					<language>perl</language>
					<code><![CDATA[ <<"EOT"
set pct=$value; \\n 
EOT
					]]></code>
				</format>
				<vdef>
					<value>20</value>
				</vdef>
				<ctrls>
					<ctrl>
						<message>Sorry, you cannot specify both a fixed number (-nmod) and a percentage (-pct) of characters to modify</message>
						<language>perl</language>
						<code>defined $specify_pct &amp;&amp; defined $specify_mod</code>
					</ctrl>
					<ctrl>
						<message>Please specify either a fixed number (-nmod) or a percentage (-pct) of characters to modify</message>
						<language>perl</language>
						<code>!defined $specify_pct &amp;&amp; !defined $specify_mod</code>
					</ctrl>
				</ctrls>
				<comment>
<value>PAUPrat can perturb either a percentage of the informative characters, or a specified number of the paramters. These are mutually exclusive parameters.  Use -pct to specify a percentage of characters to perturb each
iteration; use nmod to specify absolute number of characters to perturb each iteration; you cannot use both nmod and pct simultaneously. Nixon (1999b) states that perturbing between 5% and 25% of the total number of informative characters usually works well. </value>
				</comment>
			</attributes>
		</parameter> 
		
		<parameter type="Integer">
			<name>specify_mod</name>
			<attributes>
				<prompt>Specify the absolute number of characters to perturb (-nmod)</prompt>
				<paramfile>setup.nex</paramfile>
				<precond>
					<language>perl</language>
					<code>!defined $specify_pct</code>
				</precond>
				<group>7</group>
				<format>
					<language>perl</language>
					<code><![CDATA[ <<"EOT"
set nmod=$value;\\n 
EOT
					]]></code>
				</format>
				<ctrls>
					<ctrl>
						<message>Sorry, you cannot specify both a fixed number (-nmod) and a percentage (-pct) of characters to modify</message>
						<language>perl</language>
						<code>defined $specify_pct &amp;&amp; defined $specify_mod</code>
					</ctrl>
				</ctrls>
				<comment>
<value>PAUPrat can perturb either a percentage of the informative characters, or a specified number of the paramters. These are mutually exclusive parameters.  Use -pct to specify a percentage of characters to perturb each
iteration; use nmod to specify absolute number of characters to perturb each iteration; you cannot use both nmod and pct simultaneously. Nixon (1999b) states that perturbing between 5% and 25% of the total number of informative characters usually works well. </value>
				</comment>
			</attributes>
		</parameter>
		
<!-- Create the hardcoded parameter file setup.nex  -->
		<parameter type="Excl" ismandatory="1">
			<name>specify_wtmode</name>
			<attributes>
				<prompt>Set the weighting mode (-wtmode)</prompt>
				<paramfile>setup.nex</paramfile>
				<group>8</group>
				<format>
					<language>perl</language>
					<code><![CDATA[ <<"EOT"
set wtmode=$value; \\n
EOT
					]]></code>
				</format>
				<vlist>				
					<value>uniform</value>
					<label>uniform</label>
					<value>add</value>
					<label>additive</label>
					<value>mult</value>
					<label>multiplicative</label>	
				</vlist>
				<vdef>
					<value>uniform</value>
				</vdef>
				<comment>
<value>Set weigthing mode to uniform to ensure that original weights are always 1 for all characters. Set weighting mode to additive to handle the case of unequal original weights in an additive way. Additive means a character
originally weighted 10 will act just like 10 separate characters each weighted 1: it will be 10 times more likely to be chosen for perturbation than a character whose original weight was 1, but each time it is chosen,
its weight will be incremented by just 1. Set weighting mode to multiplicative to handle the case of unequal original weights in a multiplicative way. If multiplicative mode is chosen, a character originally weighted 10 will
increase its weight by 10 each time it is selected for perturbation, but it will not be any more likely to be chosen than a character whose original weight was 1.</value>
				</comment>
			</attributes>
		</parameter> 
		
<!-- Create the hardcoded parameter file setup.nex  -->
		<parameter type="Excl" ismandatory="1">
			<name>specify_verbose</name>
			<attributes>
			<prompt>Verbose or Terse output?</prompt>
				<paramfile>setup.nex</paramfile>
				<group>9</group>
				<vlist>
					<value>verbose</value>
					<label>Verbose</label>
					<value>terse</value>
					<label>Terse</label>
				</vlist>
				<format>
					<language>perl</language>
					<code><![CDATA[<< "EOT"
set $value; \\n
EOT
				]]></code>
				</format>
				<vdef>
					<value>terse</value>
				</vdef>
				<comment>
<value>Specify verbose if you want comments in the output indicating which characters were perturbed and how much their weights changed for each iteration.
Normally, you want to specify terse because these comments add a lot of bytes to the file and don't change the analysis at all </value>
				</comment>
			</attributes>
		</parameter> 

<!-- Create the hardcoded parameter file setup.nex  -->
		<parameter type="String" ishidden="1">
			<name>setup_hidden</name>
			<attributes>
				<paramfile>setup.nex</paramfile>
				<group>10</group>
				<format>
					<language>perl</language>
					<code><![CDATA[ << "EOT"
startcmd "[!*************************************]";\\n
startcmd "[!* ******** PAUP* Ratchet ****** *]";\\n 
startcmd "[!*   Derek S. Sikes & Paul O. Lewis  *]";\\n 
startcmd "[!*     University of Connecticut     *]";\\n 
startcmd "[!*            March, 2000            *]";\\n 
startcmd "[!* Based on Kevin Nixon's Parsimony  *]";\\n 
startcmd "[!* Ratchet as described in: Nixon,   *]";\\n 
startcmd "[!* K. C. 1999. The Parsimony Ratchet *]";\\n 
startcmd "[!* a new method for rapid parsimony  *]";\\n 
startcmd "[!* analysis. Cladistics 15: 407-414. *]";\\n 
startcmd "[!*************************************]";\\n 
startcmd "[exe infile.nex]";\\n
startcmd "log file=paupratchet.log";\\n
EOT
			 ]]></code>
				</format>
			</attributes>
		</parameter>

 <!--  autoincrease  -->
		<parameter type="Excl" ismandatory="1">
			<name>setup_increase</name>
			<attributes>
				<prompt>Increase</prompt>
				<paramfile>setup.nex</paramfile>
				<group>11</group>
				<format>
					<language>perl</language>
					<code><![CDATA[ <<"EOT"
startcmd "set increase=$value";\\n 
EOT
					]]></code>
				</format>
				<vlist>
					<value>auto</value>
					<label>auto</label>
					<value>no</value>
					<label>no</label>
				</vlist>
				<vdef>
					<value>auto</value>
				</vdef>
			</attributes>
		</parameter>
		
<!--   hs status -->
		<parameter type="String" ishidden="1">
			<name>setup_hidden1</name>
			<attributes>
				<paramfile>setup.nex</paramfile>
				<group>12</group>
				<format>
					<language>perl</language>
					<code><![CDATA[ <<"EOT"
startcmd "hs status=no nrep=$setup_nrep swap=tbr start=stepwise addseq=random nchuck=1 chuckscore=1";\\n
EOT
					 ]]></code> 
				</format>
			</attributes>
		</parameter>
		
<!--   Notes about nreps: 
* nreps specifies the number of Ratchet iterations to have PAUP* perform 
* each iteration consists of a search under perturbed character weights followed by a second search under the original weights 
   startcmd " nrep=1 swap=tbr start=stepwise addseq=random nchuck=1 chuckscore=1";\\n -->
		<parameter type="Integer">
			<name>setup_nrep</name>
			<attributes>
				<prompt>How Many Reps (nrep=)</prompt>
				<paramfile>setup.nex</paramfile>
				<group>13</group>
				<vdef>
					<value>1</value>
				</vdef>
				<comment>
<value>nreps specifies the number of Ratchet iterations to have PAUP* perform. Each iteration consists of a search under perturbed character weights followed by a second search under the original weights.</value>
				</comment>
			</attributes>
		</parameter> 

 <!-- Create the hardcoded parameter file setup.nex  -->
		<parameter type="String" ishidden="1">
			<name>setup_hidden2</name>
			<attributes>
				<paramfile>setup.nex</paramfile>
				<group>14</group>
				<format>
					<language>perl</language>
					<code><![CDATA[ <<"EOT"
startcmd "savetrees file=mydata.tre replace";\\n
EOT
					]]></code>
				</format>
			</attributes>
		</parameter> 


 <!-- Create the hardcoded parameter file setup.nex  -->
		<parameter type="String" ishidden="1">
			<name>setup_hidden3</name>
			<attributes>
				<paramfile>setup.nex</paramfile>
				<group>15</group>
				<format>
					<language>perl</language>
					<code><![CDATA[ <<"EOT"
startcmd "savetrees file=mydata.tmp replace";\\n
EOT
					]]></code>
				</format>
			</attributes>
		</parameter>

		</parameters>
	</paragraph>
</parameter>

<!-- END RATCHET COMMANDS -->

<!-- BEGIN PAUP COMMANDS -->

<parameter type="Paragraph" >
	<paragraph>
		<name>paup_params</name>
		<prompt>Paup Parameters</prompt>
		<parameters>
		
<!--  paupcmd "pset mstaxa=uncertain";\\n -->
		<parameter type="Switch">
			<name>setup_hidden4</name>
			<attributes>
				<prompt>Treat multistate taxa as uncertain</prompt>
				<paramfile>setup.nex</paramfile>
				<group>16</group>
					<vdef>
						<value>1</value>
					</vdef>
			</attributes>
		</parameter>
		
		<parameter type="String" ishidden="1">
			<name>setup_hidden4b</name>
			<attributes>
				<paramfile>setup.nex</paramfile>
				<group>16</group>
				<precond>
					<language>perl</language>
					<code>$setup_hidden4</code>
				</precond>
				<format>
					<language>perl</language>
					<code><![CDATA[ <<"EOT"
paupcmd "pset mstaxa=uncertain";\\n
EOT
					]]></code>
				</format>
			</attributes>
		</parameter>
		
<!--  paupcmd "hsearch status=no";\\n -->
		<parameter type="String" ishidden="1">
			<name>setup_hidden5</name>
			<attributes>
				<paramfile>setup.nex</paramfile>
				<group>17</group>
				<format>
					<language>perl</language>
					<code><![CDATA[ <<"EOT"
paupcmd "hsearch status=no start=1 swap=$paup_branchalg multrees=$set_multrees  \\n
EOT
					]]></code>
				</format>
			</attributes>
		</parameter>
  
<!--  paupcmd "swap=tbr ";\\n -->
		<parameter type="Excl" ismandatory="1">
			<name>paup_branchalg</name>
			<attributes>
				<prompt>Branch Swapping Algorithm (swap)</prompt>
				<paramfile>setup.nex</paramfile>
				<group>19</group>
				<!--Branch Swapping Algorithm (swap) * TBR SPR NNI  -->		
				<vlist>
					<value>tbr</value>
					<label>TBR</label>
					<value>spr</value>
					<label>SPR</label>
					<value>nni</value>
					<label>NNI</label>
				</vlist>
				<vdef>
					<value>tbr</value>
				</vdef>
				<comment>
<value>PAUP uses three branch-swapping algorithms. In order of increasing effectiveness, these are (1) nearest neighbor interchanges (NNI, equivalent to the "local" procedure used in Versions 1 and 2 of PAUP); 
(2) subtree pruning-regrafting (SPR, approximately, but not exactly, equivalent to the "global" procedure used in earlier versions of PAUP); and (3) tree bisection-reconnection (TBR, a new procedure). </value>
				</comment>
			</attributes>
		</parameter>
   
<!--  paupcmd "multrees=no";\\n -->
		<parameter type="Excl" ismandatory="1">
			<name>set_multrees</name>
			<attributes>
				<prompt>Save all optimal trees? (multrees)</prompt>
				<paramfile>setup.nex</paramfile>
				<group>20</group>
				<vlist>
					<value>yes</value>
					<label>yes</label>
					<value>no</value>
					<label>no</label>
				</vlist>
				<vdef>
					<value>no</value>
				</vdef>
				<comment>
<value>For PAUPRat, use multrees = no</value>
				</comment>
			</attributes>
		</parameter>
		
	<!-- Rearrangement limit .  -->
		<parameter type="Integer" >
			<name>set_rearrlimit</name>
			<attributes>
				<prompt>Specify a rearrangement limit</prompt>
				<comment>
					<value>The search will be limited to the specified number of tree rearrangements (branch swaps).</value>
				</comment>
			</attributes>
		</parameter>

		<parameter type="String" ishidden="1">
			<name>set_rearrlimitb</name>
			<attributes>
				<paramfile>setup.nex</paramfile>
				<precond>
					<language>perl</language>
					<code>defined $set_rearrlimit</code>
				</precond>
				<group>21</group>
				<format>
					<language>perl</language>
					<code><![CDATA[ <<"EOT"
 rearrlimit=$set_rearrlimit \\n
EOT
					]]></code>
				</format>
			</attributes>
		</parameter>
		
<!-- Time limit  -->
		<parameter type="Integer" >
			<name>set_timelimit</name>
			<attributes>
				<prompt>Specify a time limit (in seconds)</prompt>
				<comment>
					<value>The search will be limited to the specified number of tree rearrangements (branch swaps).</value>
				</comment>
			</attributes>
		</parameter>

		<parameter type="String" ishidden="1">
			<name>set_timelimitb</name>
			<attributes>
				<paramfile>setup.nex</paramfile>
				<precond>
					<language>perl</language>
					<code>defined $set_timelimit</code>
				</precond>
				<group>22</group>
				<format>
					<language>perl</language>
					<code><![CDATA[ <<"EOT"
 timelimit=$set_timelimit \\n
EOT
					]]></code>
				</format>
			</attributes>
		</parameter>
		
<!-- 	Reconnection Limit.  -->	
		<parameter type="Integer" >
			<name>set_reconlimit</name>
			<attributes>
				<prompt>Specify a reconnection limit for PAUP</prompt>
				<comment>
<value>The reconnection limit option limits the scope of SPR and TBR rearrangements. If an integer-value is specified, the value corresponds to the sum of the number
of nodes between each reconnected branch and the nodes incident to the branch that was cut for pruning (SPR) or bisection (TBR).  A rearrangement limit of 1 corresponds
to nearest-neighbor interchanges. No entry sets the value to infinity.</value>
				</comment>
			</attributes>
		</parameter>

		<parameter type="String" ishidden="1">
			<name>set_reconlimitb</name>
			<attributes>
				<paramfile>setup.nex</paramfile>
				<precond>
					<language>perl</language>
					<code>defined $set_reconlimit</code>
				</precond>
				<group>23</group>
				<format>
					<language>perl</language>
					<code><![CDATA[ <<"EOT"
 reconlimit=$set_reconlimit 
EOT
					]]></code>
				</format>
			</attributes>
		</parameter>

<!--  this closes the paupcmd line, abnd adds a carriage return  -->			
<parameter type="String" ishidden="1" ismandatory="1">
			<name>end_limits</name>
			<attributes>
				<paramfile>setup.nex</paramfile>
				<group>24</group>
				<format>
					<language>perl</language>
					<code><![CDATA[ <<"EOT"
"; \\n
EOT
					]]></code>
				</format>
			</attributes>
		</parameter>
		
<!--  Maximum number of trees saved (maxtrees).  -->
		<parameter type="Integer" ismandatory="1">
			<name>set_maxtrees</name>
			<attributes>
				<prompt>Maximum number of trees saved (maxtrees)</prompt>
				<paramfile>setup.nex</paramfile>
				<group>25</group>
				<precond>
					<language>perl</language>
					<code>$set_multrees eq "yes"</code>
				</precond>
				<format>
					<language>perl</language>
					<code><![CDATA[ <<"EOT"
paupcmd "set maxtrees=$value";\\n 
EOT
					]]></code>
				</format>
			</attributes>
		</parameter>   
		
<!-- Automatically increase the number of trees in memory. + no yes-->		
		<parameter type="Excl" ismandatory="1">
			<name>set_autoincrease</name>
			<attributes>
				<prompt>Automatically increase the number of trees in memory </prompt>
				<paramfile>setup.nex</paramfile>
				<group>26</group>
				<precond>
					<language>perl</language>
					<code>$set_multrees eq "yes"</code>
				</precond>
				<format>
					<language>perl</language>
					<code><![CDATA[ <<"EOT"
paupcmd "set Increase=$value";\\n 
EOT
					]]></code>
				</format>
				<vlist>
					<value>auto</value>
					<label>auto</label>
					<value>no</value>
					<label>no</label>
				</vlist>
				<vdef>
					<value>no</value>
				</vdef>
			</attributes>
		</parameter>    
		
		<!-- 	Auto-increase amount (AutoInc).  -->
		<parameter type="Integer" ismandatory="1">
			<name>set_increaseval</name>
			<attributes>
			<prompt>Auto-increase amount (AutoInc).</prompt>
				<paramfile>setup.nex</paramfile>
				<group>27</group>
				<precond>
					<language>perl</language>
					<code>$set_autoincrease eq "auto"</code>
				</precond>
				<format>
					<language>perl</language>
					<code><![CDATA[ <<"EOT"
paupcmd "set AutoInc=$value";\\n 
EOT
					]]></code>
				</format>
			</attributes>
		</parameter>
		
		</parameters>
	</paragraph>
</parameter>

<!-- END PAUP COMMANDS -->

<!--   normcmd "savetrees file=mydata.tmp replace";\\n -->
		<parameter type="String" ishidden="1">
			<name>setup_hidden6</name>
			<attributes>
				<paramfile>setup.nex</paramfile>
				<group>28</group>
				<format>
					<language>perl</language>
					<code><![CDATA[ <<"EOT"
normcmd "savetrees file=mydata.tmp replace";\\n 
EOT
					]]></code>
				</format>
			</attributes>
		</parameter>
		
<!--   normcmd "gettrees file=mydata.tre mode=7";\\n -->
		<parameter type="String" ishidden="1">
			<name>setup_hidden7</name>
			<attributes>
				<paramfile>setup.nex</paramfile>
				<group>29</group>
				<format>
					<language>perl</language>
					<code><![CDATA[ <<"EOT"
normcmd "gettrees file=mydata.tre mode=7";\\n 
EOT
					]]></code>
				</format>
			</attributes>
		</parameter> 		
		
<!--   normcmd "savetrees file=mydata.tre replace"; -->	
		<parameter type="String" ishidden="1">
			<name>setup_hidden8</name>
			<attributes>
				<paramfile>setup.nex</paramfile>
				<group>30</group>
				<format>
					<language>perl</language>
					<code><![CDATA[ <<"EOT"
normcmd "savetrees file=mydata.tre replace";\\n 
EOT
					]]></code>
				</format>
			</attributes>
		</parameter> 		
   
<!--   normcmd "gettrees file=mydata.tmp mode=3 warntree=no";\\n -->
		<parameter type="String" ishidden="1">
			<name>setup_hidden9</name>
			<attributes>
				<paramfile>setup.nex</paramfile>
				<group>31</group>
				<format>
					<language>perl</language>
					<code><![CDATA[ <<"EOT"
normcmd "gettrees file=mydata.tmp mode=3 warntree=no";\\n 
EOT
					]]></code>
				</format>
			</attributes>
		</parameter>
		
<!--   normcmd "time";\\n -->
		<parameter type="String" ishidden="1">
			<name>setup_hidden11</name>
			<attributes>
				<paramfile>setup.nex</paramfile>
				<group>32</group>
				<format>
					<language>perl</language>
					<code><![CDATA[ <<"EOT"
normcmd "time";\\n 
EOT
					]]></code>
				</format>
			</attributes>
		</parameter>
		
<!--   stopcmd "gettrees file=mydata.tre mode=3";\\n -->
		<parameter type="String" ishidden="1">
			<name>setup_hidden12</name>
			<attributes>
				<paramfile>setup.nex</paramfile>
				<group>33</group>
				<format>
					<language>perl</language>
					<code><![CDATA[ <<"EOT"
stopcmd "gettrees file=mydata.tre mode=3";\\n 
EOT
					]]></code>
				</format>
			</attributes>
		</parameter>
		
<!--   stopcmd "pscores all";\\n -->
		<parameter type="String" ishidden="1">
			<name>setup_hidden13</name>
			<attributes>
				<paramfile>setup.nex</paramfile>
				<group>34</group>
				<format>
					<language>perl</language>
					<code><![CDATA[ <<"EOT"
stopcmd "pscores all";\\n 
EOT
					]]></code>
				</format>
			</attributes>
		</parameter>
		
<!--   stopcmd "time";\\n -->
		<parameter type="String" ishidden="1">
			<name>setup_hidden14</name>
			<attributes>
				<paramfile>setup.nex</paramfile>
				<group>35</group>
				<format>
					<language>perl</language>
					<code><![CDATA[ <<"EOT"
stopcmd "time";\\n 
EOT
					]]></code> 
				</format>
			</attributes>
		</parameter>
		
<!--   stopcmd "log stop";\\n -->
		<parameter type="String" ishidden="1">
			<name>setup_hidden15</name>
			<attributes>
				<paramfile>setup.nex</paramfile>
				<group>36</group>
				<format>
					<language>perl</language>
					<code><![CDATA[ <<"EOT"
stopcmd "log stop";\\n 
EOT
					]]></code>
				</format>
			</attributes>
		</parameter>

		<parameter type="String" ishidden="1">
			<name>setup_hidden16</name>
			<attributes>
				<paramfile>setup.nex</paramfile>
				<group>37</group>
				<format>
					<language>perl</language>
					<code><![CDATA[ << "EOT"
stopcmd "[!**********************************]";\\n
stopcmd "[!*  THIS SEARCH IS COMPLETE   *]";\\n
stopcmd "[!*  A LOG FILE HAS BEEN WRITTEN   *]";\\n
stopcmd "[!* AND ALL TREES HAVE BEEN SAVED. *]";\\n
stopcmd "[!*     IT IS OK TO QUIT PAUP*     *]";\\n
stopcmd "[!**********************************]";\\n 
EOT
			]]></code>
				</format>
			</attributes>
		</parameter>	


<!--   stopcmd "filter best=yes permdel=yes";\\n -->
		<parameter type="String" ishidden="1">
			<name>setup_hidden17</name>
			<attributes>
				<paramfile>setup.nex</paramfile>
				<group>38</group>
				<format>
					<language>perl</language>
					<code><![CDATA[ <<"EOT"
stopcmd "filter best=yes permdel=yes";\\n 
EOT
					]]></code>
				</format>
			</attributes>
		</parameter>
		
<!--   stopcmd "savetrees file=mydata.best.tre";\\n -->
		<parameter type="String" ishidden="1">
			<name>setup_hidden18</name>
			<attributes>
				<paramfile>setup.nex</paramfile>
				<group>39</group>
				<format>
					<language>perl</language>
					<code><![CDATA[ <<"EOT"
stopcmd "savetrees file=pauprat.best.tre";\\n 
EOT
					]]></code> 
				</format>
			</attributes>
		</parameter>
		
<!--   stopcmd "[quit]";\\n -->
		<parameter type="String" ishidden="1">
			<name>setup_hidden19</name>
			<attributes>
				<paramfile>setup.nex</paramfile>
				<group>40</group>
				<format>
					<language>perl</language>
					<code><![CDATA[ <<"EOT" 
stopcmd "[quit]";\\n
write file=ratchet.nex replace;\\n
end; 
EOT
					]]></code>
				</format>
			</attributes>
		</parameter> 
		
<!-- write file=ratchet.nex;\\n -->	
<!--		<parameter type="String" ishidden="1">
			<name>setup_hidden20</name>
			<attributes>
				<paramfile>setup.nex</paramfile>
				<group>39</group>
				<format>
					<language>perl</language>
					<code><![CDATA[write file=ratchet.nex;\\n EOT ]]></code>
				</format>
			</attributes>
		</parameter>  -->
		
<!-- This section is also included in rid3paup. ######################################################################## -->

<!-- These depend on multrees -->
<!--		<parameter type="Integer">
			<name>maxtrees</name>
			<attributes>
				<paramfile>paup_ratchet_improve_co.xml</paramfile>
				<group>40</group>
				<prompt>Maximum number of trees saved (maxtrees).</prompt>
				<format>
					<language>perl</language>
					<code><![CDATA[ <<"EOT" 
	<commands>set maxtrees=$value;</commands>\\n
EOT
					]]></code>
				</format>
				<ctrls>
					<ctrl>
						<message>maxtrees must be a greater than 0.</message>
						<language>perl</language>
						<code>$maxtrees &lt; 0</code>
					</ctrl>
				</ctrls>
				<precond>
					<language>perl</language>
					<code> defined $multrees &amp;&amp; $multrees eq "yes"</code>
				</precond>
			</attributes>
		</parameter>  -->

<!--		<parameter type="Excl" ismandatory="1">
			<name>increase</name>
			<attributes>
				<paramfile>paup_ratchet_improve_co.xml</paramfile>
				<group>3</group>
				<prompt>Automatically increase the number of trees in memory.</prompt>
				<format>
					<language>perl</language>
					<code><![CDATA[ <<"EOT" 
	<commands>set Increase = $value;</commands>\\n
EOT
					]]></code>
				</format>
				<vdef><value>no</value></vdef>
				<vlist>
					<value>no</value>
					<label>no</label>
					<value>auto</value>
					<label>yes</label>
				</vlist>
				<precond>
					<language>perl</language>
					<code> defined $multrees &amp;&amp; $multrees eq "yes"</code>
				</precond>
			</attributes>
		</parameter>  -->
		
<!--		<parameter type="Integer">
			<name>autoincrease</name>
			<attributes>
				<paramfile>paup_ratchet_improve_co.xml</paramfile>
				<group>4</group>
				<prompt>Auto-increase amount (AutoInc).</prompt>
				<format>
					<language>perl</language>
					<code><![CDATA[ <<"EOT" 
	<commands>set AutoInc=$value;</commands>\\n
EOT
					]]></code>
				</format>
				<ctrls>
					<ctrl>
						<message>Auto-increase amount must be than 0.</message>
						<language>perl</language>
						<code>$autoincrease &lt;= 0</code>
					</ctrl>
				</ctrls>
				<precond>
					<language>perl</language>
					<code> defined $multrees &amp;&amp; $multrees eq "yes" &amp;&amp; defined $increase
						&amp;&amp; $increase eq "auto"
					</code>
				</precond>
			</attributes>
		</parameter> -->
		<!-- END These depend on multrees -->


<!--		<parameter type="String" ishidden="1">
			<name>start_hsearch</name>
			<attributes>
				<paramfile>paup_ratchet_improve_co.xml</paramfile>
				<group>10</group>
					<format>
						<language>perl</language>
						<code><![CDATA[ <<"EOT" 
<commands>
default hsearch\\n
EOT
						]]></code>
					</format>
			</attributes>
		</parameter> -->


<!--	<parameter type="Paragraph" >
		<paragraph>
			<name>hsearch_paragraph</name>
			<prompt>Heuristic Search Parameters</prompt>
			<parameters> -->

<!--			<parameter type="Excl" ismandatory="1">
					<name>swap</name>
					<attributes>
						<paramfile>paup_ratchet_improve_co.xml</paramfile>
						<group>11</group>
						<prompt>Branch Swapping Algorithm (swap)</prompt>
						<format>
							<language>perl</language>
							<code>"swap=$value\\n"</code>
						</format>
						<vlist>
							<value>tbr</value>
							<label>TBR</label>
							<value>spr</value>
							<label>SPR</label>
							<value>nni</value>
							<label>NNI</label>
						</vlist>
						<vdef><value>tbr</value></vdef>
					</attributes>
				</parameter> -->
				
<!--				<parameter type="Excl" ismandatory="1">
					<name>multrees</name>
					<attributes>
						<paramfile>paup_ratchet_improve_co.xml</paramfile>
						<group>12</group>
						<prompt>Save all optimal trees? (multrees)</prompt>
						<format>
							<language>perl</language>
							<code>"multrees=$value\\n"</code>
						</format>
						<vlist>
							<value>yes</value>
							<label>yes</label>
							<value>no</value>
							<label>no</label>
						</vlist>
						<vdef><value>no</value></vdef>
					</attributes>
				</parameter> -->
				
<!--				<parameter type="Integer">
					<name>rearrlimit</name>
					<attributes>
						<paramfile>paup_ratchet_improve_co.xml</paramfile>
						<group>13</group>
						<prompt>Maximum number of rearrangements (rearrlimit). Blank means unlimited.</prompt>
						<format>
							<language>perl</language>
							<code>($rearrlimit == 0) ? "" : "rearrlimit=$value\\n"</code>
						</format>
						<ctrls>
							<ctrl>
								<message>rearrlimit must be a positive integer (or blank if unlimited).</message>
								<language>perl</language>
								<code>$rearrlimit &lt; 0</code>
							</ctrl>
						</ctrls>
					</attributes>
				</parameter> -->
				
<!--				<parameter type="Integer">
					<name>timelimit</name>
					<attributes>
						<paramfile>paup_ratchet_improve_co.xml</paramfile>
						<group>14</group>
						<prompt>Maximum number of seconds to search (timelimit). Blank means unlimited.</prompt>
						<format>
							<language>perl</language>
							<code>($timelimit == 0) ? "" : "timelimit=$value\\n"</code>
						</format>
						<ctrls>
							<ctrl>
								<message>timelimit must be a positive integer (or blank if unlimited).</message>
								<language>perl</language>
								<code>$timelimit &lt;  0</code>
							</ctrl>
						</ctrls>
					</attributes>
				</parameter> -->

				<!-- TL: I'm assuming that not specifying reconlimit is the same as reconlimit=Infinity -->
<!--				<parameter type="Integer">
					<name>reconlimit</name>
					<attributes>
						<paramfile>paup_ratchet_improve_co.xml</paramfile>
						<group>15</group>
						<prompt>Reconnection limit (reconlimit).  Blank means unlimited.</prompt>
						<format>
							<language>perl</language>
							<code>($reconlimit == 0) ? "" : "reconlimit=$value\\n"</code>
						</format>
						<ctrls>
							<ctrl>
								<message>reconlimit must be a positive integer (or blank if unlimited).</message>
								<language>perl</language>
								<code>$reconlimit &lt;  0</code>
							</ctrl>
						</ctrls>
					</attributes>
				</parameter> -->
				
<!--				<parameter type="Integer">
					<name>ratchetreps</name>
					<attributes>
						<paramfile>paup_ratchet_improve_co.xml</paramfile>
						<group>16</group>
						<prompt>Number of ratchet iterations (or blank if not ratcheting)</prompt>
						<vdef><value>200</value></vdef>
						<format>
							<language>perl</language>
							<code>($ratchetreps == 0) ? "" : "[paup.Wrap.n.ratchet.reps=$value]\\n"</code>
						</format>
						<ctrls>
							<ctrl>
								<message>Ratchet iterations must be a positive integer (or blank if no ratchet).</message>
								<language>perl</language>
								<code>$ratchetreps &lt;  0</code>
							</ctrl>
						</ctrls>
					</attributes>
				</parameter> -->
				
<!--				<parameter type="Float" ismandatory="1">
					<name>ratchetprop</name>
					<attributes>
						<paramfile>paup_ratchet_improve_co.xml</paramfile>
						<group>17</group>
						<prompt>Proportion of characters to reweight in ratchet</prompt>
						<vdef><value>0.2</value></vdef>
						<format>
							<language>perl</language>
							<code>"[paup.Wrap.ratchet.prop=$value]\\n"</code>
						</format>
						<ctrls>
							<ctrl>
								<message>Proportion to reweight must be greater than or equal to  0.</message>
								<language>perl</language>
								<code>$ratchetprop &lt;  0</code>
							</ctrl>
						</ctrls>
						<precond>
							<language>perl</language>
							<code> defined $ratchetreps &amp;&amp; $ratchetreps &gt; 0</code>
						</precond>
					</attributes>
				</parameter> -->
				
<!--				<parameter type="Integer" ismandatory="1">
					<name>ratchetseed</name>
					<attributes>
						<paramfile>paup_ratchet_improve_co.xml</paramfile>
						<group>18</group>
						<prompt>Pseudo-random number generator seed for ratchet.</prompt>
						<vdef><value>0</value></vdef>
						<format>
							<language>perl</language>
							<code>"[paup.Wrap.ratchet.seed=$value]\\n"</code>
						</format>
						<ctrls>
							<ctrl>
								<message>Proportion to reweight must be greater than or equal to  0.</message>
								<language>perl</language>
								<code>$ratchetseed &lt;  0</code>
							</ctrl>
						</ctrls>
						<precond>
							<language>perl</language>
							<code> defined $ratchetreps &amp;&amp; $ratchetreps &gt; 0</code>
						</precond>
					</attributes>
				</parameter>

			</parameters>
		</paragraph>
	</parameter> -->

<!--	<parameter type="String" ishidden="1">
			<name>end_hsearch</name>
			<attributes>
				<paramfile>paup_ratchet_improve_co.xml</paramfile>
				<group>30</group>
				<format>
					<language>perl</language>
					<code><![CDATA[ <<"EOT" 
						;
</commands>\\n
EOT
					]]></code>
				</format>
			</attributes>
		</parameter> -->
		<!-- ######################################################################### -->

		<!-- Finish  the parameter file that's used for specifying the paup improve parameters -->
<!--		<parameter type="String" ishidden="1">
			<name>end_improve_parameter_file</name>
			<attributes>
				<paramfile>paup_ratchet_improve_co.xml</paramfile>
				<group>31</group>
				<format>
					<language>perl</language>
					<code><![CDATA[ <<"EOT" 
</command-object>\\n
EOT
					]]></code>
				</format>
			</attributes>
		</parameter> -->

<!--		<parameter type="Results">
			<name>final_result</name>
			<attributes>
				<filenames>paup_ratchet_data.nex</filenames>
			</attributes>
		</parameter>

		<parameter type="Results">
			<name>intermediate_results</name>
			<attributes>
				<filenames>tmp_paup_ratchet_data.nex</filenames>
			</attributes>
		</parameter>

		<parameter type="Results">
			<name>original_input</name>
			<attributes>
				<filenames>data.nex</filenames>
			</attributes>
		</parameter> -->
	
		
		<parameter type="Results">
			<name>result_file</name>
			<attributes>
				<filenames>paupratchet.log </filenames>
			</attributes>
		</parameter>
		
		<parameter type="Results">
			<name>best_tree_file</name>
			<attributes>
				<filenames>pauprat.best.tre</filenames>
			</attributes>
		</parameter>
		
		<parameter type="Results">
			<name>run_data</name>
			<attributes>
				<filenames>*.txt</filenames>
			</attributes>
		</parameter>
		
		<parameter type="Results">
			<name>run_logs</name>
			<attributes>
				<filenames>*.nex</filenames>
			</attributes>
		</parameter>
		
		<parameter type="Results">
			<name>all_commandline</name>
			<attributes>
				<filenames>COMMANDLINE</filenames>
			</attributes>
		</parameter>
		<!--
			rm -rf trees subdirectory because it takes way too long to delete it using
			sftpfilehandler.  Unfortunately this means we'll always return an exit
			status of 0, since rm -rf always returns 0.
		-->
<!--		<parameter type="String" ishidden="1">
			<name>commandline</name>
			<attributes>
				<group>0</group>
				<format>
					<language>perl</language>
					<code>	"run_cipres_svc.sh \\
								-DnexusFile=data.nex \\
								-DtoolFile=paup_ratchet_improve_co.xml \\
								-DresultsDir=. \\
								-DtoolName=paup_ratchet \\
								-DtreeInferTool=stepwise_addition_paup_infer_co.xml \\
								-DoriginalNexusName=data.nex 
					"</code>
				</format>
			</attributes>
		</parameter> -->

	</parameters>
</pise>

