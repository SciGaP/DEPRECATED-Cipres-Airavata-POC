<?xml version="1.0" encoding="ISO-8859-1"?>
<!DOCTYPE pise SYSTEM "http://www.phylo.org/dev/rami/PARSER/pise2.dtd">
<!--
Final updates for 0.96 suggested by Derrick Zwickl, 11/14/2008.

One general point is that the defaults for datatype = codon-aminoacid should be exactly the same as aminoacid.  

The analyses are exactly the same, the translation from codons to amino acids is just handled internally by GARLI in the case of codon-aminoacid.  The only difference in settings is that the genetic code must be specified for codon-aminoacid.  In particular, this means that a number of extra settings need to be added to the codon-aminoacid set:
invariantsites this is done
numratecats this is done
ratehetmodel this is done


Cant implement yet:
The only other normal entry that you are missing is outputcurrentbesttree.  There is probably no reason for you to use this (unless you would want access to the current best tree during a run), and the default is 0 anyway.

Added this in group 2; 
One undocumented (and semi-experimental) feature that you might want to add would be the "collapsebranches" boolean entry in the general section.  This tells the program to collapse minimum length branches (effectively zero length) branch upon output of the final trees.  

Otherwise the final trees are always fully bifurcating, even when returning a polytomy makes more sense.  For some datasets this can make a big difference because final trees may in fact be identical with those branches collapsed, but they will appear different if they are compared on the basis of the topology alone (for example, when calculating tree to tree distances).  If simply visualized with the branches proportional to their lengths the trees will look identical because the tiny branches will be indistinguishable from a polytomy.  This feature can be particularly important in the case of bootstrapping, where you don't really want branches that effectively don't exist (and are an arbitrary resolution of a polytomy) to be counted in the support values.  The only downside of this setting is that GARLI's test at the end of a run for whether the trees from each replicates are identical may be wrong if branches are collapsed.  I don't know if you use or return that information anyway (the .screen.log file), so it may not be a big deal.

Specific changes:
-Change all genthreshfortopoterm from 10K to 20K DONE

-For both aminoacid and codon-aminoacid, numratecats should be 4 DONE

-I would have the ratematrix for aminoacid and codon-aminoacid default to WAG.  The user should really be making a conscious choice about which to use, but (knowing users) they often just go with the defaults.  I don't think I've ever seen a dataset that actually statistically prefers dayhoff, and 95% of them seem to prefer either WAG or jones (JTT). DONE

-statefrequencies should be empirical for both aminoacid and codon-aminoacid DONE

-In terms of starting tree options, would go with streefname = stepwise instead of random.  This will give it a much better starting point, and especially on large datasets this can both reduce runtimes and improve results.  If you do that you'll also need to add attachmentspertaxon to the general section of the config.  I'd suggest a default value of 50.   DONE

Previously the portal was providing a parsimony starting tree to GARLI generated by PAUP (I think), in which case streefname would be the name of that file.  Providing the PAUP tree was probably a good idea with version 0.951, but it may not be necessary because GARLI can now create its own likelihood stepwise addition trees.  Providing the user the option to go either way might be good.

-->
<!--
*********************************************************************************************************************************************************************************************
Updates for Garli 0.96 on Oct 21, 2008 by mamiller

New in version 0.96

1. Rigorous reading of Nexus datasets using Paul Lewis and Mark Holder's Nexus Class Library (NCL)

2. Ability to read Nexus starting trees using NCL

3. Ability to perform inference under amino acid and codon-based models of sequence evolution (datatype = aminoacid, datatype = codon)

4. Ability to specify multiple search replicates in a single config file (searchreps = #)

5. Ability to specify outgroups for orientation of inferred trees (outgroup = # # #)

6. Ability to use backbone as well as normal topological constraints

7. Ability to create fast likelihood stepwise addition starting trees (streefname = stepwise)

8. MPI version that spreads a specified number of serial runs across processors using a single config file, writing output to different output files (for example, to do 25 bootstrap replicates simultaneously on each of 8 processors)

9. Ability to perform nucleotide inference using any sub-model of the General Time-Reversible model (GTR), in addition to all of the common "named" models (K2P, HKY, etc)

10. Speed increases for non-parametric bootstrapping


Substitution models available in version 0.96 include:

Nucleotide models: All models nested within the General Time Reversible (GTR) model, optionally with discrete gamma distributed rate heterogeneity and/or an inferred proportion of invariable sites. 

Amino acid models: Many of the well known fixed amino acid rate matrices (Dayhoff, Jones, WAG, mtRev, mtmam), with either fixed or observed (aka "+F") amino acid frequencies, and discrete gamma 
distributed rate heterogeneity and/or an inferred proportion of invariable sites 

Codon models: The basic Goldman and Yang (1994) model and other related models, with a number of options for codon frequencies (equal, "F1x4", "F3x4", observed) and one or more estimated non-synonymous rate categories (aka dN/dS or omega parameters)

*********************************************************************************************************************************************************************************************-->

<!--
	Update for mpi version of garli on lonestar - Terri

	To run garli in parallel you specify the number of times you want garli to execute the config file on the commandline, eg, "garli-mpi -10"
	tells garli to execute the config file 10 times.  Each run can be done in parallel, so this is also the number of processors we
	say we can use in the cpu_count parameter.

	We don't let the user specify the number of times to run the config file, instead we consider the number of bootstrapreps and searchreps
	he's requested, eg, if the user sets searchreps=10, we change that to searchreps=1 in the config file and tell garli to execute the 
	config file 10 times.  The user is required to select either multiple searchreps or multiple bootstrapreps or both on teragrid; otherwise
	it would just be a serial run.

	The slightly tricky part is that if the user selects bootstrapping, searchreps specifies the number of searches to be done on each
	bootstrapped tree.  So we can do each bootstrap and it's related searches on a separate processor.  Thus if bootstrapping is 
	specified, we set bootstrapreps to 1 in the config file and specify the number of bootstrap reps on the command line (leaving searchreps 
	at whatever value the user set in the config file).  
-->

<!--
	This is garli version 0.951 (GARLI v. 0.951) by Derek Zwickl.  I believe the only command line option is the name of the configuration file.  All other options are specified in the configuration file.   

	It seems that all of garli's parameters must be specified in the garli.conf, even if you're leaving them at their default values (I may be wrong, but creating a  garli.conf with just a few obvious parameters doesn't work ... I don't know which are mandatory).  So, I'm going to put them all in here and fix their attributes  and move them to the right paragraphs as I have time to enhance this. 
	
	6/22/08, mamiller added the pickup and presentation of phylip files (.phy) preconditioned on the switch outputphyliptree_g.
-->
<!-- This interface was updated in oct 2010 by mamiller to support submissions to Lonestar in a more efficient way  -->
<!-- This interface was adapted to use on Abe by mamiller on or around Nov 1, 2010 -->
<!-- This interface was adapted to use on Trestles only on March 18, 2011 or so -->
<pise>
	<head>
		<title>GARLI on XSEDE</title>
		<version>1.0</version>
		<description>Genetic Algorithm for Rapid Likelihood Inference - run on teragrid.</description>
		<authors>Derrick J. Zwickl (zwickl@nescent.org)</authors>
		<reference> Zwickl, D. J., 2006. Genetic algorithm approaches for the phylogenetic analysis of large biological sequence datasets under the maximum likelihood criterion. Ph.D. dissertation, The University of Texas at Austin. http://garli.nescent.org 
		</reference>
		<category>Phylogeny / Alignment</category>
	</head>
	
	<command>garli_tg</command>
	<parameters>

		<!-- command name -->
		<parameter ishidden="1" type="String">
			<name>garli</name>
			<attributes>
				<format>
					<language>perl</language>
					<code>"garli_wrap.sh"</code>
				</format>
				<group>0</group>
			</attributes>
		</parameter>


		<!-- required input file, this is selected outside the parameters gui -->
		<parameter isinput="1" type="InFile">
			<name>infile</name>
			<attributes>
				<prompt>Alignment file (non-interleaved phylip or nexus format) (s)</prompt>
				<group>0</group>
				<filenames>infile</filenames>
			</attributes>
		</parameter>

<!--

Sample input files, run scripts, and output files are at

   /home/pfeiffer/garli-1.0_trestles

As for the rules to run GARLI, I think we no longer need to place limits on the number of searches allowed.
Instead, we can just limit runs to a single 32-core node.  Here are the rules that I suggest.

- Check searchreps and bootstrapreps.

- If bootstrapreps = 0, set nruns=searchreps and searchreps=1

- If bootstrapreps != 0, set nruns=bootstrapreps and bootstrapreps=1.

- If nruns < 32, run MPI version of GARLI on nruns cores in the shared queue.

- If nruns >= 32, run MPI version of GARLI on all 32 cores of a single node in the normal queue.

-->

		
<!-- This section was added by mamiller, in a very inelegant method for binning bootstrap requests. If one or more bootstraps is requested, the number of mpi processes= the number of bootstraps.
	 Any search reps for each bootstrap is run in the same eprocess. Here we use preconds to select the number of processes. We do this because Lonestar has 4 cores per node, and so the job
	 should be designed to request a number of processes that is divisible by 4, and that will accomodate all bootstrap processes. 
	 The number of mpi processes requests is therefore rounded upward, so that each process is mapped to a core, and no one waits while the 
	 a remaining process awaits its core.  -->
		
<!-- Each element specifying mpi procs is accompanied by a command line that specifies the number of searchreps (if bootstrapreps=0) 
	 or the number of bootstrapreps.
	 
	 This goes on the command line, eg. "garli-mpi 10", for 10 searchreps.  It specifies
	 the number of times the garli parameter file will be executed.  Each execution can
	 be done in parallel so we request the same number of processors via the mpi_processes 
	 parameter above.  -->

<!-- first we deal with making the command line correct; this value is appended to garliwrap.sh -->
<!-- If bootstrapreps = 0, set nruns=searchreps -->		
	  	<parameter type="Integer" ishidden="1" >
			<name>number_of_runssearchrep1</name>
			<attributes>
				<group>1</group>
				<precond>
					<language>perl</language>
					<code>$bootstrapreps &lt; 1 &amp;&amp; $searchreps_value &gt; 0</code>
				</precond>
				<format>
					<language>perl</language>
					<code>"$searchreps_value"</code>
				</format>
			</attributes>
		</parameter>
		
<!-- If bootstrapreps != 0, set nruns=bootstrapreps -->	
	    <parameter type="Integer" ishidden="1" >
			<name>number_of_runsbootrep</name>
			<attributes>
				<group>1</group>
				<precond>
					<language>perl</language>
					<code>$bootstrapreps &gt; 0 </code>
				</precond>
				<format>
					<language>perl</language>
					<code>"$bootstrapreps"</code>
				</format>
			</attributes>
		</parameter>
		
<!-- now we create scheduler.conf -->
<!-- wall time can be 0.1 - 168 hrs -->
		<parameter type="Float" issimple="1" ismandatory="1">
			<name>runtime</name> 
			<attributes>
				<group>1</group>
				<paramfile>scheduler.conf</paramfile>
				<prompt>Maximum Hours to Run (click here for help setting this correctly)</prompt>
				<vdef><value>0.5</value></vdef>
				<comment>
					<value>
						Estimate the maximum time your job will need to run (up to 168 hrs).  Your job will be killed if it doesn't finish within the time you specify, however jobs with shorter maximum run times, especially those under .5 hrs,  are often scheduled sooner than longer jobs. 
					</value>
				</comment>
				<ctrls>
					<ctrl>
						<message>Maximum Hours to Run must be between 0.1 - 168.0.</message>
						<language>perl</language>
						<code>$runtime &lt; 0.1 || $runtime &gt; 168.0</code>
					</ctrl>
				</ctrls>
<!-- this advises a user of the number of SUs that will be consumed for this type of run -->
<!-- As for the rules to run GARLI, I think we no longer need to place limits on the number of searches allowed.
Instead, we can just limit runs to a single 32-core node.  Here are the rules that I suggest.

- Check searchreps and bootstrapreps.

- If bootstrapreps = 0, set nruns=searchreps and searchreps=1

- If bootstrapreps != 0, set nruns=bootstrapreps and bootstrapreps=1.

- If nruns < 32, run MPI version of GARLI on nruns cores in the shared queue.

- If nruns >= 32, run MPI version of GARLI on all 32 cores of a single node in the normal queue.

-->
<!-- added by mamiller to provide feedback on number of cpu hrs to be consumed -->
				<warns>
					<warn>
						<message>The job will run on $searchreps_value processors as configured. If it runs for the entire configured time, it will consume $searchreps_value x $runtime cpu hours</message>
						<language>perl</language>
						<code>$bootstrapreps == 0</code>
					</warn>
					<warn>
						<message>The job will run on $bootstrapreps processors as configured. If it runs for the entire configured time, it will consume $bootstrapreps x $runtime cpu hours</message>
						<language>perl</language>
						<code>$bootstrapreps ne 0 &amp;&amp; $bootstrapreps &lt; 32</code>
					</warn>
					<warn>
						<message>The job will run on 32 processors as configured. If it runs for the entire configured time, it will consume 32 x $runtime cpu hours</message>
						<language>perl</language>
						<code>$bootstrapreps &amp;&amp; $bootstrapreps &gt;= 32</code>
					</warn>
				</warns>
				<format>
					<language>perl</language>
					<code>"runhours=$value\\n"</code>
				</format>	
			</attributes>
		</parameter>
		
<!-- Garli is always run mpi -->		
		<parameter type="String" ishidden="1" >
			<name>jobtype</name>
			<attributes>
				<group>1</group>
				<paramfile>scheduler.conf</paramfile>
				<format>
					<language>perl</language>
					<code>"jobtype=mpi\\n"</code>
				</format>
			</attributes>
		</parameter>

<!-- all garli runs are on a single node -->		
		<parameter type="Integer" ishidden="1" >
			<name>searchrep_mpi_processes_nodeslt32</name>
			<attributes>
				<group>1</group>
				<paramfile>scheduler.conf</paramfile>
				<format>
					<language>perl</language>
					<code>"nodes=1 \\n"</code>
				</format>
			</attributes>
		</parameter> 

<!-- now set the value of mpi_processes in scheduler.conf -->		
<!-- If bootstrapreps = 0, set mpi_processes=searchreps; this value will never be greater than 8 -->		  	
	    <parameter type="Integer" ishidden="1" >
			<name>searchrep_mpi_processes</name>
			<attributes>
				<group>1</group>
				<paramfile>scheduler.conf</paramfile>
				<precond>
					<language>perl</language>
					<code>$bootstrapreps &lt; 1 &amp;&amp; $searchreps_value &gt; 0</code>
				</precond>
				<format>
					<language>perl</language>
					<code>"mpi_processes=$searchreps_value \\n"</code>
				</format>
			</attributes>
		</parameter> 

<!-- If bootstrapreps != 0, set mpi_processes as follows: -->	

	<!-- If nruns < 32; mpi_processes = $bootstrapreps -->	
		<parameter type="Integer" ishidden="1" >
			<name>mpi_processes_1-32</name>
			<attributes>
				<group>1</group>
				<paramfile>scheduler.conf</paramfile>
				<precond>
					<language>perl</language>
					<code>$bootstrapreps &gt; 0 &amp;&amp; $bootstrapreps &lt; 32</code>
				</precond>
				<format>
					<language>perl</language>
					<code>"mpi_processes=$bootstrapreps \\n"
					</code>
				</format>
			</attributes>
		</parameter>
		
<!-- If nruns >= 32; mpi_processes = 32 -->		
		<parameter type="Integer" ishidden="1" >
			<name>mpi_processes_gt32</name>
			<attributes>
				<group>1</group>
				<paramfile>scheduler.conf</paramfile>
				<precond>
					<language>perl</language>
					<code>$bootstrapreps &gt; 31</code>
				</precond>
				<format>
					<language>perl</language>
					<code>"mpi_processes=32 \\n"
					</code>
				</format>
			</attributes>
		</parameter>
		
<!-- this section is for file return. there are three types fo files: input for garli, teragrid run files, and results files -->
<!-- to return all results just uncomment this element 
		<parameter type="Results">
			<name>all_outputfiles</name>
			<attributes>
				<filenames>*</filenames>
			</attributes>
		</parameter> -->

<!-- Input for Garli -->
		
		<parameter type="Results">
			<name>a_matrix_file</name>
			<attributes>
				<prompt>Input</prompt>
				<filenames>infile</filenames>
			</attributes>
		</parameter>
		
		<parameter type="Results">
			<name>b_command_line</name>
			<attributes>
				<prompt>commandline</prompt>
				<filenames>COMMANDLINE</filenames>
			</attributes>
		</parameter>
		
		<parameter type="Results">
			<name>c_garli_configuration</name>
			<attributes>
				<prompt>Input parameters</prompt>
				<filenames>garli.conf</filenames>
			</attributes>
		</parameter>
		
		<parameter type="Results">
			<name>d_starting_tree</name>
			<attributes>
				<prompt>Input starting tree/model</prompt>
				<filenames>starting.txt</filenames>
				<precond>
					<language>perl</language>
					<code> defined $streefname_pasted || defined $streefname_userdata </code>
				</precond>
			</attributes>
		</parameter>
		
		<parameter type="Results">
			<name>e_constraint_file</name>
			<attributes>
				<prompt>Input topology constraints</prompt>
				<filenames>constraint.txt</filenames>
				<precond>
					<language>perl</language>
					<code>defined $constraintfile_control</code>
				</precond>
			</attributes>
		</parameter>

<!-- TeraGrid run files -->
		<parameter type="Results">
			<name>f_scheduler_configuration</name>
			<attributes>
				<prompt>Scheduling parameters</prompt>
				<filenames>scheduler.conf</filenames>
			</attributes>
		</parameter>
		
<!-- scheduler_stderr.txt -->
		<parameter type="Results">
			<name>ff_scheduler_configuration</name>
			<attributes>
				<prompt>Scheduling stderr</prompt>
				<filenames>scheduler_stderr.txt</filenames>
			</attributes>
		</parameter>
		
		<parameter type="Results">
			<name>g_jobinfo_txt</name>
			<attributes>
				<prompt>jobinfo_parameters</prompt>
				<filenames>*_JOBINFO.TXT</filenames>
			</attributes>
		</parameter>
		
		<parameter type="Results">
			<name>h_start_txt</name>
			<attributes>
				<prompt>start_txt</prompt>
				<filenames>start.txt</filenames>
			</attributes>
		</parameter>
		
		<parameter type="Results">
			<name>hh_done_txt</name>
			<attributes>
				<prompt>done_txt</prompt>
				<filenames>done.txt</filenames>
			</attributes>
		</parameter>
		


	<!-- Results files -->
		<parameter type="Results">
			<name>i_garli_log00_results</name>
			<attributes>
				<filenames>*.log00.log</filenames>
			</attributes>
		</parameter>
		
		<parameter type="Results">
			<name>j_garli_screenlog_results</name>
			<attributes>
				<filenames>*.screen.log</filenames>
			</attributes>
		</parameter>
		
		<parameter type="Results">
			<name>k_garli_boottree_results</name>
			<attributes>
				<filenames>*boot.tre</filenames>
			</attributes>
		</parameter>
		
		<parameter type="Results">
			<name>l_garli_allboottree_results</name>
			<attributes>
				<filenames>allBootTrees.tre</filenames>
			</attributes>
		</parameter>
		
		<parameter type="Results">
			<name>m_garli_besttree_results</name>
			<attributes>
				<filenames>*best.tre</filenames>
			</attributes>
		</parameter>

		<parameter type="Results">
			<name>n_garli_besttree_results</name>				
			<attributes>
				<filenames>all.tre</filenames>
				<precond>
					<language>perl</language>
					<code>$bootstrapreps &lt; 1</code>
				</precond>	
			</attributes>
		</parameter>
		
		<parameter type="Results">
			<name>o_garli_bestalltree_results</name>
			<attributes>
				<filenames>*best.all.tre</filenames>
			</attributes>
		</parameter>
		
<!-- This is added to pick up the Phylip files on request -->
<!--		<parameter type="Results">
			<name>garli_phytree</name>
			<attributes>
				<filenames>*.phy</filenames>
				<precond>
					<language>perl</language>
					<code>$outputphyliptree_g</code>
				</precond>
			</attributes>
		</parameter> -->

<!-- The following parameters all build the configuration file, garli.conf --> 
		<!--	parameters are grouped into labeled sections. everything in the "general" section should specify group=2, everything in the "master" section should use group=4,  :)
		-->

		<!--	 "general" section header is group 1: terms in "general" are-->
		<parameter type="String" ishidden="1">
			<name>general_section</name>
			<attributes>
				<paramfile>garli.conf</paramfile>
				<group>1</group>
				<format>
					<language>perl</language>
					<code>"[general]\\n"</code>
				</format>
			</attributes>
		</parameter>
		
		<!--	 "master" section header is group 3 :)	-->	
		<parameter type="String" ishidden="1">
			<name>master_section</name>
			<attributes>
				<paramfile>garli.conf</paramfile>
				<group>3</group>
				<format>
					<language>perl</language>
					<code>"\n\n[master]\\n"</code>
				</format>
			</attributes>
		</parameter>

		<!-- name of input data file, hardcoded to infile -->
		<parameter type="String" ishidden="1">
			<name>datafname</name>
			<attributes>
				<paramfile>garli.conf</paramfile>
				<group>2</group>
				<format>
					<language>perl</language>
					<code>"datafname = infile\\n"</code>
				</format>
				<group>2</group>
			</attributes>
		</parameter>
		
				<!--	datafname = infile	-->
				<!-- prefix for output filenames -->

		<parameter type="String" ishidden="1">
			<name>ofprefix</name>
			<attributes>
				<paramfile>garli.conf</paramfile>
				<group>2</group>
				<format>
					<language>perl</language>
					<code>"ofprefix = garli_run\\n"</code>
				</format>
				<group>3</group>
			</attributes>
		</parameter>

<!-- availablemem.  2560 is what we use on cipres but it should be computed based on the size of the input dataset and the real available memory -->
<!--	availablememory = 2000 on trestles -->
		<parameter type="Integer" ishidden="1">
			<name>availablememory</name>
			<attributes>
				<paramfile>garli.conf</paramfile>
				<group>2</group>
				<format>
					<language>perl</language>
					<code>"availablememory = 2000\\n"</code>
				</format>
			</attributes>
		</parameter>

<!-- VISIBLE PARAMETERS -->
<!-- Model -->		
<!-- ==================================================================================================== -->
		<parameter type="Paragraph">
			<paragraph>
				<name>model</name>
				<prompt>Model Parameters</prompt>
				<parameters>

<!--datatype (nucleotide, aminoacid, codon-aminoacid, codon)  The type of data and model that is to be used during tree inference.  The codon-aminoacid datatype means that the data will be supplied as a nucleotide alignment, but will be internally translated and analyzed using an amino acid model. The codon and codon-aminoacid datatypes require nucleotide sequence that is aligned in the correct reading frame. In other words, all gaps in the alignment should be a multiple of 3 in length, and the alignment should start at the first position of a codon.  If the alignment has extra columns at the start, middle or end, they should be removed or excluded with a Nexus exset (see the FAQ for an example of exset usage).  The correct geneticcode must also be set.  
-->
<!--	 this parameter didnt exist in 0.95 -->
					<parameter ismandatory="1" type="Excl">
						<name>datatype_value</name>
						<attributes>
							<prompt>The type of data (datatype)</prompt>
<!-- this is removed to try to stage all of these paramters 
							<format>
								<language>perl</language>
								<code>"datatype = $value\\n"</code>
							</format> -->
							<vdef>
								<value>nucleotide</value>
							</vdef>
							<vlist>
								<value>nucleotide</value>
								<label>nucleotide</label>
								<value>aminoacid</value>
								<label>amino acid</label>
								<value>codon-aminoacid</value>
								<label>codon-aminoacid</label>
								<value>codon</value>
								<label>codon</label>
							</vlist>
							<flist>
								<value>nucleotide</value>
								<code>"datatype = nucleotide\\n"</code>
								<value>aminoacid</value>
								<code>"datatype = aminoacid\\n"</code>
								<value>codon-aminoacid</value>
								<code>"datatype = codon-aminoacid\\n"</code>
								<value>codon</value>
								<code>"datatype = codon\\n"</code>
							</flist>
							<paramfile>garli.conf</paramfile>
							<group>2</group>
							<comment>
<value>The codon-aminoacid datatype means that the data will be supplied as a nucleotide alignment, but will be internally translated and analyzed using an amino acid model. The codon and codon-aminoacid datatypes require nucleotide sequence that is aligned in the correct reading frame. In other words, all gaps in the alignment should be a multiple of 3 in length, and the alignment should start at the first position of a codon.  If the alignment has extra columns at the start, middle or end, they should be removed or excluded with a Nexus exset (see the FAQ for an example of exset usage).  The correct geneticcode must also be set.</value>
							</comment>
						</attributes>
					</parameter>
<!-- this is missing from 0.95  -->
<!--One general point is that the defaults for datatype = codon-aminoacid should be exactly the same as aminoacid.The analyses are exactly the same, the translation from codons to amino acids is just handled internally by GARLI in the case of codon-aminoacid.  The only difference in settings is that the genetic code must be specified for codon-aminoacid.  In particular, this means that a number of extra settings need to be added to the codon-aminoacid set:
invariantsites
numratecats
ratehetmodel -->
<!--geneticcode (standard, vertmito, invertmito)  The genetic code to be used in translating codons into amino acids. -->					
					<parameter ismandatory="1" type="Excl">
						<name>geneticcode_value</name>
						<attributes>
							<prompt>Select the Genetic Code (geneticcode)</prompt>
								<precond>
									<language>perl</language>
									<code>$datatype_value eq "codon" || $datatype_value eq "codon-aminoacid"</code>
								</precond>
							<format>
								<language>perl</language>
								<code>"geneticcode = $value\\n"</code>
							</format>
							<vlist>
								<value>standard</value>
								<label>Standard</label>
								<value>vertmito</value>
								<label>Vertebrate Mitochondria</label>
								<value>invertmito</value>
								<label>Invertebrate Mitochondria</label>
							</vlist>
							<vdef>
								<value>standard</value>
							</vdef>
							<paramfile>garli.conf</paramfile>
							<group>2</group>
							<comment>
<value>The codon-aminoacid datatype means that the data will be supplied as a nucleotide alignment, but will be internally translated and analyzed using an amino acid model. The codon and codon-aminoacid datatypes require nucleotide sequence that is aligned in the correct reading frame. In other words, all gaps in the alignment should be a multiple of 3 in length, and the alignment should start at the first position of a codon.  If the alignment has extra columns at the start, middle or end, they should be removed or excluded with a Nexus exset (see the FAQ for an example of exset usage).  The correct geneticcode must also be set. </value>
							</comment>
						</attributes>
					</parameter>

					<!-- Nucleotide Model -->
					<!-- ======================================================================================== -->

					<parameter type="Paragraph">
						<paragraph>
							
							<name>model_nucleotide</name>
							<prompt>Nucleotide Model</prompt>
							<comment>
								<value>JC (Jukes-Cantor model): Rate Matrix = 1 rate, Base Frequencies = equal</value>
								<value>K2P (Kimura 2-Parameter model): Rate Matrix = 2 rate, Base Frequencies = equal</value>
								<value>F81 (Felsenstein 1981 model): Rate Matrix = 1 rate, Base Frequencies = estimate</value>
								<value>HKY (Hasegawa, Kishino and Yano model): Rate Matrix = 2 rate, Base Frequencies = estimate</value>
								<value>GTR (General Time-Reversible model): Rate Matrix = 6 rate, Base Frequencies = estimate</value>
							</comment>

							<parameters>
<!--	 "general" section ratematrix = 6rate -->
								<parameter type="Excl" ismandatory="1">
									<name>d_ratematrix</name> 
									<attributes>
										<paramfile>garli.conf</paramfile>
										<prompt>Rate Matrix (ratematrix)</prompt>
										<precond>
											<language>perl</language>
											<code>$datatype_value eq "nucleotide"</code>
										</precond>
										<vlist>
											<value>1rate</value>
											<label>All Rates Equal (1rate)</label>
											<value>2rate</value>
											<label>HKY (2rate)</label>
											<value>6rate</value>
											<label>General time-reversible (6 rate)</label>
											<value>fixed</value>
											<label>fixed rate</label>
											<value>custom_string</value>
											<label>User Specified</label>
										</vlist>
										<flist>
											<value>1rate</value>
											<code>"ratematrix = $value\\n"</code>
											<value>2rate</value>
											<code>"ratematrix = $value\\n"</code>
											<value>6rate</value>
											<code>"ratematrix = $value\\n"</code>
											<value>fixed</value>
											<code>"ratematrix = $value\\n"</code>
											<value>custom_string</value>
											<code>"ratematrix = ($ACsubrates $AGsubrates $ATsubrates $CGsubrates $CTsubrates $GTsubrates)\\n"</code> 
										</flist>
										<vdef><value>6rate</value></vdef>
										<paramfile>garli.conf</paramfile>
										<group>2</group>
										<comment>
<value>New in version 0.96, parameters for any submodel of the GTR model may now be estimated.  The format for specifying this is very similar to that used in the rclass setting of PAUP*.  Within parentheses, six letters are specified, with spaces between them.  The six letters represent the rates of substitution between the six pairs of nucleotides, with the order being A-C, A-G, A-T, C-G, C-T and G-T. Letters within the parentheses that are the same mean that a single parameter is shared by multiple nucleotide pairs.  For example, ratematrix = (a b a a b a) would specify the HKY 2-rate model (equivalent to ratematrix = 2rate).  This entry, ratematrix = (a b c c b a) would specify 3 estimated rates of substitution, with one rate shared by A-C and G-T substitutions, another rate shared by A-G and C-T substitutions, and the final rate shared by A-T and C-G substitutions.</value>
										</comment>
									</attributes>
								</parameter>

<!-- the six individual user-specified rates-->

								<parameter type="String">
									<name>ACsubrates</name> 
									<attributes>
										<prompt>User specified AC substitution rates (custom ratematrix)</prompt>
										<precond>
											<language>perl</language>
											<code>$datatype_value eq "nucleotide" &amp; $d_ratematrix eq "custom_string"</code>
										</precond>
										<format>
											<language>perl</language>
											<code>""</code>
										</format>
									</attributes>
								</parameter>
							
								<parameter type="String">
									<name>AGsubrates</name> 
									<attributes>
										<prompt>User specified AG substitution rates (custom ratematrix)</prompt>
										<precond>
											<language>perl</language>
											<code>$datatype_value eq "nucleotide" &amp; $d_ratematrix eq "custom_string"</code>
										</precond>
										<format>
											<language>perl</language>
											<code>""</code>
										</format>
									</attributes>
								</parameter>
								
								<parameter type="String">
									<name>ATsubrates</name> 
									<attributes>
										<prompt>User specified AT substitution rates (custom ratematrix)</prompt>
										<precond>
											<language>perl</language>
											<code>$datatype_value eq "nucleotide" &amp; $d_ratematrix eq "custom_string"</code>
										</precond>
										<format>
											<language>perl</language>
											<code>""</code>
										</format>
									</attributes>
								</parameter>
								
								<parameter type="String">
									<name>CGsubrates</name> 
									<attributes>
										<prompt>User specified CG substitution rates (custom ratematrix)</prompt>
										<precond>
											<language>perl</language>
											<code>$datatype_value eq "nucleotide" &amp; $d_ratematrix eq "custom_string"</code>
										</precond>
										<format>
											<language>perl</language>
											<code>""</code>
										</format>
									</attributes>
								</parameter>
								
								<parameter type="String">
									<name>CTsubrates</name> 
									<attributes>
										<prompt>User specified CT subsitution rates (custom ratematrix)</prompt>
										<precond>
											<language>perl</language>
											<code>$datatype_value eq "nucleotide" &amp; $d_ratematrix eq "custom_string"</code>
										</precond>
										<format>
											<language>perl</language>
											<code>""</code>
										</format>
									</attributes>
								</parameter>
								
								<parameter type="String">
									<name>GTsubrates</name> 
									<attributes>
										<prompt>User specified GT substitution rates (custom ratematrix)</prompt>
										<precond>
											<language>perl</language>
											<code>$datatype_value eq "nucleotide" &amp; $d_ratematrix eq "custom_string"</code>
										</precond>
										<format>
											<language>perl</language>
											<code>""</code>
										</format>
									</attributes>
								</parameter>

<!-- end of the six individual user-specified rates-->
<!---general" section statefrequencies = estimate	-->

								<parameter type="Excl"  ismandatory="1">
									<name>d_statefrequencies</name> 
									<attributes>
										<paramfile>garli.conf</paramfile>

										<prompt>Base Frequencies (statefrequencies)</prompt>
										<precond>
											<language>perl</language>
											<code>$datatype_value eq "nucleotide"</code>
										</precond>
										<format>
											<language>perl</language>
											<code>"statefrequencies = $value\\n" </code>
										</format>
										<vlist>
											<value>equal</value>
											<label>equal</label>
											<value>empirical</value>
											<label>empirical</label>
											<value>estimate</value>
											<label>estimate</label>
											<value>fixed</value>
											<label>fixed</label>
										</vlist>
										<vdef><value>estimate</value></vdef>
										<paramfile>garli.conf</paramfile>
										<group>2</group>
									</attributes>
								</parameter>
								
<!-- general section  invariantsites = estimate -->

								<parameter type="Excl"  ismandatory="1">
									<name>d_invariantsites</name> 
									<attributes>
										<paramfile>garli.conf</paramfile>
										<prompt>Proportion of invariant sites (invariantsites)</prompt>
										<precond>
											<language>perl</language>
											<code>$datatype_value eq "nucleotide"</code>
										</precond>
										<format>
											<language>perl</language>
											<code>"invariantsites = $value\\n" </code>
										</format>
										<vlist>
											<value>none</value>
											<label>none</label>
											<value>estimate</value>
											<label>estimate</label>
										</vlist>
										<vdef><value>estimate</value></vdef>
										<group>2</group>
										<paramfile>garli.conf</paramfile>
										<comment>
<value>Specifies whether a parameter representing the proportion of sites that are unable to change (i.e. have a substitution rate of zero) will be included.  This is typically referred to as invariant sites, but would better be termed invariable sites.</value>
										</comment>
									</attributes>
								</parameter>

<!-- general section ratehetmodel = gamma  -->

								<parameter type="Excl"  ismandatory="1">
									<name>d_ratehetmodel</name> 
									<attributes>
										<paramfile>garli.conf</paramfile>
										<prompt>The model of rate heterogeneity (ratehetmodel)</prompt>
										<precond>
											<language>perl</language>
											<code>$datatype_value eq "nucleotide"</code>
										</precond>
										<format>
											<language>perl</language>
											<code>
											($d_ratehetmodel eq "none") ? "numratecats = 1\\nratehetmodel = $value\\n" : 
												"numratecats = $d_numratecats\\nratehetmodel = $value\\n"
											</code>
										</format>
										<vlist>
											<value>none</value>
											<label>Equal Rates For All Sites (none)</label>
											<value>gamma</value>
											<label>Gamma Distribution (gamma)</label>
										</vlist>
										<vdef><value>gamma</value></vdef>
										<paramfile>garli.conf</paramfile>
										<group>2</group>
										<comment>
<value>The model of rate heterogeneity assumed. gammafixed requires that the alpha shape parameter is provided, and a setting of gamma estimates it.</value>
										</comment>
									</attributes>
								</parameter>
								
<!-- general section numratecats = 4  -->

								<parameter type="Integer">
									<name>d_numratecats</name> 
									<attributes>
										<prompt>Number of rate categories (numratecats)</prompt>
										<precond>
											<language>perl</language>
											<code>$datatype_value eq "nucleotide" &amp; $d_ratehetmodel eq "gamma"</code>
										</precond>
										<format>
											<language>perl</language>
											<code>"numratecats=$value\\n"</code>
										</format>
										<vdef><value>4</value></vdef>
										<ctrls>
											<ctrl>
												<message>:Number of rate categories: must be an integer between 1 and 20</message>
												<language>perl</language>
												<code>$d_numratecats &lt; 2 || $d_numratecats &gt; 20</code>
											</ctrl>
										</ctrls>
										<paramfile>garli.conf</paramfile>
										<group>2</group>
										<comment>
<value>The number of categories of variable rates (not including the invariant site class if it is being used). Must be set to 1 if ratehetmodel is set to none.  Note that runtimes and memory usage scale linearly with this setting.</value>
										</comment>
									</attributes>
								</parameter>

							</parameters>
						</paragraph>
					</parameter>
					<!-- Nucleotide Model Paragraph -->
					
					<!-- Protein Model: applies to protein datatype or protein:codon datatype -->
					<!-- ======================================================================================== -->
					<parameter type="Paragraph">
						<paragraph>
							
							<name>model_protein</name>
							<prompt>Protein Model</prompt>
							<comment>
								<value>dayhoff 	Dayhoff, Schwartz and Orcutt. 1978 </value>
								<value>jones 	Jones, Taylor and Thornton (JTT), 1992 </value>
								<value>WAG 	Whelan and Goldman, 2001 </value>
								<value>mtREV 	Adachi and Hasegawa, 1996 </value>
								<value>mtmam 	Yang, Nielsen and Hasegawa. 1998 </value>
							</comment>
							
<!--For datatype = aminoacid or codon-aminoacid: Amino acid analyses are typically done using fixed rate matrices that have been estimated on large datasets and published. Typically the only model parameters that are estimated during tree inference relate to the rate heterogeneity distribution.  Each of the named matrices also has corresponding fixed amino acid frequencies, and a given matrix can either be used with those frequencies or with the amino acid frequencies observed in your dataset.  This second option is often denoted as +F in a model description, although in terms of the GARLI configuration settings this is referred to as empirical frequencies.  In GARLI the Dayhoff model would be specified by setting both the ratematrix and statefrequencies options to dayhoff.  The Dayhoff+F model would be specified by setting the ratematrix to dayhoff, and statefrequencies to empirical. The following named amino acid models are implemented:
ratematrix/statefrequencies.

dayhoff 	Dayhoff, Schwartz and Orcutt. 1978 
jones 	Jones, Taylor and Thornton (JTT), 1992 
WAG 	Whelan and Goldman, 2001 
mtREV 	Adachi and Hasegawa, 1996 
mtmam 	Yang, Nielsen and Hasegawa. 1998 

Note that most programs allow either the use of a named rate matrix and its corresponding state frequencies, or a named rate matrix and empirical frequencies. GARLI technically allows the mixing of different named matrices and equilibrium frequencies (for example, wag matrix with jones equilibrium frequencies), but this is not recommended. ratematrix (poisson, jones, dayhoff, wag, mtmam, mtrev)  The fixed amino acid rate matrix to use. You should use the matrix that gives the best likelihood, and could use a program like PROTTEST (very much like MODELTEST, but for amino acid models) to determine which fits best for your data. Poisson assumes a single rate of substitution between all amino acid pairs, and is a very poor model. -->

							<parameters>
								
<!--general section ratematrix -->						
								<parameter type="Excl" ismandatory="1">
									<name>p_ratematrix</name> 
									<attributes>
										<paramfile>garli.conf</paramfile>
										<group>2</group>
										<prompt>Protein Rate Matrix (ratematrix)</prompt>
										<precond>
											<language>perl</language>
											<code>$datatype_value eq "aminoacid" || $datatype_value eq "codon-aminoacid"</code>
										</precond>
										<format>
											<language>perl</language>
											<code>"ratematrix = $value\\n" </code>
										</format>
										<vdef>
											<value>wag</value>
										</vdef>
<!---I would have the ratematrix for aminoacid and codon-aminoacid default to WAG.  The user should really be making a conscious choice about which to use, but (knowing users) they often just go with the defaults.  I don't think I've ever seen a dataset that actually statistically prefers dayhoff, and 95% of them seem to prefer either WAG or jones (JTT).-->		
										<vlist>
											<value>poisson</value>
											<label>Poisson</label>
											<value>jones</value>
											<label>Jones</label>
											<value>dayhoff</value>
											<label>Dayhoff</label>
											<value>wag</value>
											<label>WAG</label>
											<value>mtmam</value>
											<label>mtMAM</label>
											<value>mtrev</value>
											<label>mtREV</label>
										</vlist>
										<paramfile>garli.conf</paramfile>
										<comment>
<value>You should use the matrix that gives the best likelihood, and could use a program like PROTTEST (very much like MODELTEST, but for amino acid models) to determine which fits best for your data.  Poisson assumes a single rate of substitution between all amino acid pairs, and is a very poor model.</value>
										</comment>
									</attributes>
								</parameter>

<!-- general section statefrequencies -->

								<parameter type="Excl"  ismandatory="1">
									<name>p_statefrequencies</name> 
									<attributes>
										<paramfile>garli.conf</paramfile>
										<group>2</group>
										<prompt>Amino Acid Frequencies (statefequencies)</prompt>
										<precond>
											<language>perl</language>
											<code>$datatype_value eq "aminoacid" || $datatype_value eq "codon-aminoacid"</code>
										</precond>
										<format>
											<language>perl</language>
											<code>"statefrequencies = $value\\n" </code>
										</format>
										<vlist>
											<value>equal</value>
											<label>equal</label>
											<value>empirical</value>
											<label>empirical (+F)</label>
											<value>estimate</value>
											<label>estimate</label>
											<value>fixed</value>
											<label>fixed</label>
											<value>jones</value>
											<label>Jones</label>
											<value>dayhoff</value>
											<label>Dayhoff</label>
											<value>wag</value>
											<label>WAG</label>
											<value>mtmam</value>
											<label>mtMAM</label>
											<value>mtrev</value>
											<label>mtREV</label>
										</vlist>
										<vdef><value>empirical</value></vdef>
										<!---statefrequencies should be empirical for both aminoacid and codon-aminoacid-->
										<paramfile>garli.conf</paramfile>
										<comment>
<value>Specifies how the equilibrium state frequencies of the 20 amino acids are treated. The empirical option fixes the frequencies at their observed proportions (when describing a model this is often termed +F).</value>
										</comment>
									</attributes>
								</parameter>
								
<!--invariantsites (none, estimate, fixed)  Specifies whether a parameter representing the proportion of sites that are unable to change (i.e. have a substitution rate of zero) will be included.  This is typically referred to as invariant sites, but would better be termed invariable sites. 
ratehetmodel (none, gamma, gammafixed)  The model of rate heterogeneity assumed. gammafixed requires that the alpha shape parameter is provided, and a setting of gamma estimates it. 
numratecats (1 to 20, 4)  The number of categories of variable rates (not including the invariant site class if it is being used).  Must be set to 1 if ratehetmodel is set to none.  Note that runtimes and memory usage scale linearly with this setting. 
-->

<!-- invariantsites = estimate general section 2  
a number of extra settings need to be added to the codon-aminoacid set:
invariantsites
numratecats
ratehetmodel
-->

									<parameter type="Excl"  ismandatory="1">
									<name>p_invariantsites</name> 
									<attributes>
										<paramfile>garli.conf</paramfile>
										<group>2</group>
										<prompt>Proportion of invariable sites (invariantsites)</prompt>
										<precond>
											<language>perl</language>
											<code>$datatype_value eq "aminoacid" || $datatype_value eq "codon-aminoacid"</code>
										</precond>
										<format>
											<language>perl</language>
											<code>"invariantsites = $value\\n" </code>
										</format>
										<vlist>
											<value>none</value>
											<label>none</label>
											<value>estimate</value>
											<label>estimate</label>
										</vlist>
										<vdef>
											<value>estimate</value>
										</vdef>
										<paramfile>garli.conf</paramfile>
										<comment>
<value>Specifies whether a parameter representing the proportion of sites that are unable to change (i.e. have a substitution rate of zero) will be included.  This is typically referred to as invariant sites, but would better be termed invariable sites.</value>
										</comment>
									</attributes>
								</parameter>
								
<!--ratehetmodel general section 2 -->
<!-- invariantsites = estimate general section 2  
a number of extra settings need to be added to the codon-aminoacid set:
invariantsites
numratecats
ratehetmodel
-->
								<parameter type="Excl"  ismandatory="1">
									<name>p_ratehetmodel</name> 
									<attributes>
										<paramfile>garli.conf</paramfile>
										<group>2</group>
										<prompt>Model of rate heterogeneity (ratehetmodel)</prompt>
										<precond>
											<language>perl</language>
											<code>$datatype_value eq "aminoacid" || $datatype_value eq "codon-aminoacid"</code>
										</precond>
										<format>
											<language>perl</language>
											<code>
											($p_ratehetmodel eq "none") ? "numratecats = 1\\nratehetmodel = $value\\n" : 
												"numratecats = $p_numratecats\\nratehetmodel = $value\\n"
											</code>
										</format>
										<vlist>
											<value>none</value>
											<label>Equal Rates For All Sites (none)</label>
											<value>gamma</value>
											<label>Gamma Distribution (gamma)</label>
										</vlist>
										<vdef>
											<value>gamma</value>
										</vdef>
										<paramfile>garli.conf</paramfile>
										<comment>
<value>The model of rate heterogeneity assumed. gammafixed requires that the alpha shape parameter is provided, and a setting of gamma estimates it.</value>
										</comment>
									</attributes>
								</parameter>
								
<!--general section numratecats =20-->
<!-- invariantsites = estimate general section 2  
a number of extra settings need to be added to the codon-aminoacid set:
invariantsites
numratecats
ratehetmodel
-->
								<parameter type="Integer">
									<name>p_numratecats</name> 
									<attributes>
										<paramfile>garli.conf</paramfile>
										<group>2</group>
										<prompt>Number of rate categories (numratecats; set at no more than 8)</prompt>
										<precond>
											<language>perl</language>
											<code>$datatype_value eq "aminoacid" | $datatype_value eq "codon-aminoacid" &amp; $p_ratehetmodel eq "gamma" </code>
										</precond>
										<format>
											<language>perl</language>
											<code>"numratecats=$value\\n"</code>
										</format>
										<vdef>
											<value>4</value>
										</vdef>
										<!-- -For both aminoacid and codon-aminoacid, vdef for numratecats should be 4 -->
										<ctrls>
											<ctrl>
												<message>Number of rate categories: must be an integer between 1 and 20</message>
												<language>perl</language>
												<code>$p_numratecats &lt; 2 || $p_numratecats &gt; 20</code>
											</ctrl>
										</ctrls>
										<comment>
<value>The number of categories of variable rates (not including the invariant site class if it is being used). Must be set to 1 if ratehetmodel is set to none.  Note that runtimes and memory usage scale linearly with this setting.</value>
										</comment>
									</attributes>
								</parameter>
								
							</parameters>
							
						</paragraph>
						
					</parameter>
					
					<!-- Protein Model Paragraph -->
					
					<!-- Codon Model: -->
					<!-- ======================================================================================== -->
										<parameter type="Paragraph">
						<paragraph>
							
							<name>model_codon</name>
							<prompt>Codon Model</prompt>
							<comment>
<value>The codon models are built with three components: (1) parameters describing
	the process of individual nucleotide substitutions, (2) equilibrium codon
	frequencies, and (3) parameters describing the relative rate of nonsynonymous to
	synonymous substitutions.  The nucleotide substitution parameters within the codon
	models are exactly the same as those possible with standard nucleotide models in
	GARLI, and are specified with the ratematrix configuration entry.  Thus, they can
	be of the 2rate variety (inferring different rates for transitions and transversions,
	K2P or HKY-like), the 6rate variety (inferring different rates for all nucleotide
	pairs, GTR-like) or any other sub-model of GTR. The options for codon frequencies are
	specified with the statefrequencies configuration entry.  The options are to use
	equal frequencies (not a good option), the frequencies observed in your dataset
	(termed empirical in GARLI), or the codon frequencies implied by the F1x4 or F3x4
	methods (using PAML's terminology). These last two options calculate the codon frequencies as the product of the frequencies of the three nucleotides that make up each codon.  In the F1x4 case the nucleotide frequencies are those observed in the dataset across all codon positions, while the F3x4 option uses the nucleotide frequencies observed in the data at each codon position separately.  The final component of the codon models is the nonsynonymous to synonymous relative rate parameters  (aka dN/dS or omega parameters).  The default is to infer a single dN/dS value.  Alternatively, a model can be specified that infers a given number of dN/dS categories, with the dN/dS values and proportions falling in each category estimated (ratehetmodel = nonsynonymous).  This is 
the discrete or M3 model in PAML's terminology.</value>
<value>From the Author: No stop codons under the chosen genetic code are allowed. 
These are: standard code (TAG, TAA and TGA); vertebrate mitochondria
	(TAG, TAA, AGA and AGG); invertebrate mitochondria (TAG and TAA).
	One might argue that stop codons should just be ignored and treated as missing,
	but this can be dangerous. Sometimes they will come from a sequencing error, but
	more often from an alignment problem, an incorrectly chosen genetic code, or a
	sequence that is not really coding (e.g. an intron). In any case, error should be examined and
	resolved consciously by the user. 
</value><value>
One thing to note is that codon models for tree inference require that you align
the protein coding sequences along a correct reading frame; (e.g., gaps of 1 or 2
bases will impair the analysis). Maintaining the reading frame makes alignment
much easier even if your analysis will be at the nucleotide level. Just running
sequences through a sequence alignment program without looking is almost guaranteed
to return an alignment that will not work for codon based inference.</value>
<value>The other important restriction to note is that GARLI expects the alignment to begin on the first base of a codon. It can't figure out where the reading frame is, so if the alignment starts with a partial codon it needs to be removed or excluded from the alignment. Version 0.96 does allow normal NEXUS exclusions through an assumptions block, so the following would work to exclude the first two bases of an alignment and tell GARLI that the reading frame starts on the third.
begin assumptions;
exset * myexset = 1 2;
end;.
</value>
							</comment>

<!--For datatype = codon: The codon models are built with three components: (1) parameters describing the process of individual nucleotide substitutions, (2) equilibrium codon frequencies, and (3) parameters describing the relative rate of nonsynonymous to synonymous substitutions.  The nucleotide substitution parameters within the codon models are exactly the same as those possible with standard nucleotide models in GARLI, and are specified with the ratematrix configuration entry.  Thus, they can be of the 2rate variety (inferring different rates for transitions and transversions, K2P or HKY-like), the 6rate variety (inferring different rates for all nucleotide pairs, GTR-like) or any other sub-model of GTR.  The options for codon frequencies are specified with the statefrequencies configuration entry.  The options are to use equal frequencies (not a good option), the frequencies observed in your dataset (termed empirical in GARLI), or the codon frequencies implied by the F1x4 or F3x4 methods (using PAML's terminology).  These last two options calculate the codon frequencies as the product of the frequencies of the three nucleotides that make up each codon.  In the F1x4 case the nucleotide frequencies are those observed in the dataset across all codon positions, while the F3x4 option uses the nucleotide frequencies observed in the data at each codon position separately.  The final component of the codon models is the nonsynonymous to synonymous relative rate parameters (aka dN/dS or omega parameters).  The default is to infer a single dN/dS value.  Alternatively, a model can be specified that infers a given number of dN/dS categories, with the dN/dS values and proportions falling in each category estimated (ratehetmodel = nonsynonymous).  This is 
the discrete or M3 model in PAML's terminology. -->

<!-- ratematrix (1rate, 2rate, 6rate, fixed, custom string)  This determines the relative rates of nucleotide substitution assumed by the codon model.  The options are exactly the same as those allowed under a normal nucleotide model.  A codon model with ratematrix = 2rate specifies the standard Goldman and Yang (1994) model, with different substitution rates for transitions and transversions. -->

							<parameters> 

<!-- general section 2 -->
								<parameter type="Excl" ismandatory="1">
									<name>c_ratematrix</name> 
									<attributes>
										<paramfile>garli.conf</paramfile>
										<group>2</group>
										<prompt>Codon Rate Matrix (ratematrix)</prompt>
										<precond>
											<language>perl</language>
											<code>$datatype_value eq "codon"</code>
										</precond>
										<format>
											<language>perl</language>
											<code>"ratematrix = $value\\n" </code>
										</format>
										<vdef>
											<value>2rate</value>
										</vdef>
										<vlist>
											<value>1rate</value>
											<label>1rate</label>
											<value>2rate</value>
											<label>2rate</label>
											<value>6rate</value>
											<label>6rate</label>
											<value>fixed</value>
											<label>fixed</label>
											<value>custom</value>
											<label>custom</label>
											<value>string</value>
											<label>string</label>
										</vlist>
										<paramfile>garli.conf</paramfile>
										<comment>
<value>This determines the relative rates of nucleotide substitution assumed by the codon model. The options are exactly the same as those allowed under a normal nucleotide model.  A codon model with ratematrix = 2rate specifies the standard Goldman and Yang (1994) model, with different substitution rates for transitions and transversions.</value>
										</comment>
									</attributes>
								</parameter>

<!-- statefrequencies (equal, empirical, f1x4, f3x4) - The options are to use equal codon frequencies (not a good option), the frequencies observed in your dataset (termed empirical in GARLI), or the codon frequencies implied by the F1x4 or F3x4 methods (using PAML's terminology).  These last two options calculate the codon frequencies as the product of the frequencies of the three nucleotides that make up each codon.  In the F1x4 case the nucleotide frequencies are those observed in the dataset across all codon positions, while the F3x4 option uses the nucleotide frequencies observed in the data at each codon position separately. -->

<!-- general section 2-->

								<parameter type="Excl"  ismandatory="1">
									<name>c_statefrequencies</name> 
									<attributes>
										<paramfile>garli.conf</paramfile>
										<group>2</group>
										<prompt>Codon Frequencies (statefequencies)</prompt>
										<precond>
											<language>perl</language>
											<code>$datatype_value eq "codon"</code>
										</precond>
										<format>
											<language>perl</language>
											<code>"statefrequencies = $value\\n" </code>
										</format>
										<vlist>
											<value>equal</value>
											<label>equal</label>
											<value>empirical</value>
											<label>empirical (+F)</label>
											<value>f1x4</value>
											<label>F1x4</label>
											<value>f3x4</value>
											<label>F3x4</label>
										</vlist>
										<vdef><value>f3x4</value></vdef>
										<comment>
<value>The options are to use equal codon frequencies (not a good option), the frequencies observed in your dataset (termed empirical in GARLI), or the codon frequencies implied by the F1x4 or F3x4 methods (using PAML's terminology).  These last two options calculate the codon frequencies as the product of the frequencies of the three nucleotides that make up each codon.  In the F1x4 case the nucleotide frequencies are those observed in the dataset across all codon positions, while the F3x4 option uses the nucleotide frequencies observed in the data at each codon position separately.</value>
										</comment>
									</attributes>
								</parameter>
								
<!-- ratehetmodel (none, nonsynonymous)  For codon models, the default is to infer a single dN/dS parameter.  Alternatively, a model can be specified that infers a given number of dN/dS categories, with the dN/dS values and proportions falling in each category estimated (ratehetmodel = nonsynonymous).  This is the discrete or M3 model of Yang et al. (2000). . -->

<!--general section 2 -->
								<parameter type="Excl"  ismandatory="1">
									<name>c_ratehetmodel</name> 
									<attributes>
										<paramfile>garli.conf</paramfile>
										<group>2</group>
										<prompt>dN/dS categories (or Omega) (ratehetmodel)</prompt>
										<precond>
											<language>perl</language>
											<code>$datatype_value eq "codon"</code>
										</precond>
<!--										<format>
											<language>perl</language>
											<code>"ratehetmodel = $value\\ninvariantsites = none\\n" </code>
										</format> -->
										<vlist>
											<value>none</value>
											<label>A single dN/dS parameter (none)</label>
											<value>nonsynonymous</value>
											<label>discrete or M3 model (nonsynonymous)</label>
										</vlist>
										<flist>
											<value>none</value>
											<code>"ratehetmodel = none\\ninvariantsites = none\\nnumratecats = 1\\n" </code>
											<value>nonsynonymous</value>
											<code>"ratehetmodel = nonsynonymous\\ninvariantsites = none\\n" </code>
										</flist>
										<vdef>
											<value>none</value>
										</vdef>
										<comment>
<value>For codon models, the default is to infer a single dN/dS parameter. Alternatively, a model can be specified that infers a given number of dN/dS categories, with the dN/dS values and proportions falling in each category estimated (ratehetmodel = nonsynonymous). This is the discrete or M3 model of Yang et al. (2000).</value>
										</comment>
									</attributes>
								</parameter>

<!-- numratecats  When ratehetmodel = nonsynonymous, this is the number of dN/dS parameter categories. 
 -->
 <!--numratecats general section 2-->
								<parameter type="Integer">
									<name>c_numratecats</name> 
									<attributes>
										<prompt>Number of dN/dS parameter categories (numratecats)</prompt>
										<precond>
											<language>perl</language>
											<code>$datatype_value eq "codon" &amp;&amp; $c_ratehetmodel eq "nonsynonymous"</code>
										</precond>
										<format>
											<language>perl</language>
											<code>"numratecats = $value\\n"</code>
										</format>
										<vdef>
											<value>3</value>
										</vdef>
										<ctrls>
											<ctrl>
												<message>Number of rate categories: must be an integer between 1 and 8</message>
												<language>perl</language>
												<code>$c_numratecats &lt; 1 || $c_numratecats &gt; 8</code>
											</ctrl>
										</ctrls>
										<group>2</group>
										<paramfile>garli.conf</paramfile>
										<comment>
<value>When ratehetmodel = nonsynonymous, this is the number of dN/dS parameter categories. </value>
										</comment>
									</attributes>
								</parameter>

							</parameters>
						</paragraph>
					</parameter>
<!-- Codon Model Paragraph -->

					<!-- Trees -->
					<!-- ======================================================================================== -->
					<parameter type="Paragraph">
						<paragraph>
							<name>model_trees</name>
							<prompt>Run Configuration</prompt>
							<parameters>
<!-- streefname (random, stepwise, <filename>)  Specifies where the starting tree topology and/or model parameters will come from.  The tree topology may be a completely random topology (constraints will be enforced), a tree provided by the user in a file, or a tree generated by the program using a fast ML stepwise-addition algorithm (see attachmentspertaxon below). Starting or fixed model parameter values may also be provided in the specified file, with or without a tree topology.   Some notes on starting trees/models: 
 	New in version 0.96: Nexus starting trees are allowed. 
 	New in version 0.96: Specified starting trees may have polytomies, which will be
arbitrarily resolved before the run begins.

 	Starting tree formats: 
 	Plain newick tree string (with taxon numbers or names, with or without branch lengths) 
 	NEXUS trees block.  The trees block can appear in the same file as a NEXUS data or characters block that contains the alignment, although the same filename should then be specified on both the datafname and streefname lines. 
 
 	If multiple trees appear in the specified file and multiple search replicates are specified (see searchreps setting), 
	then the first tree is used in the first replicate, the second in the second replicate, etc. 

In terms of starting tree options, I would go with streefname = stepwise instead of random.  This will give it a much better starting point, and especially on large datasets this can both reduce runtimes and improve results.  If you do that you'll also need to add attachmentspertaxon to the general section of the config.  I'd suggest a default value of 50.  
Previously the portal was providing a parsimony starting tree to GARLI generated by PAUP (I think), in which case streefname would be the name of that file.  Providing the PAUP tree was probably a good idea with version 0.951, but it may not be necessary because GARLI can now create its own likelihood stepwise addition trees.  Providing the user the option to go either way might be good.-->

<!-- Add line setting streefname=[starting.txt | random] in garli.conf -->
<!--		removed this because the parameter got more complex, and I couldnt manage it -->
<!--						<parameter type="String" ishidden="1">
									<name>streefname</name>
									<attributes>
										<group>2</group>
										<paramfile>garli.conf</paramfile>
										<format>
											<language>perl</language>
											<code>
												("defined $streefname_pasted" || defined $streefname_userdata) ? "streefname = starting.txt\\n" :
													"streefname = random\\n"
											</code>
										</format>
									</attributes>
								</parameter> -->
								
								<!-- tree from userdata, now in starting.txt -->
<!-- general section 2 -->
								<parameter ismandatory="1" type="Excl">
									<name>streefname_choose</name>
									<attributes>
										<prompt>Specify where the starting tree topology comes from (streefname)</prompt>
										<vdef>
											<value>stepwise</value>
										</vdef>
										<vlist>
											<value>random</value>
											<label>random</label>
											<value>stepwise</value>
											<label>stepwise</label>
											<value>upload</value>
											<label>upload</label>
										</vlist>
										<flist>
											<value>random</value>
											<code>"streefname = random\\n"</code>
											<value>stepwise</value>
											<code>"streefname = stepwise\\n"</code>
											<value>upload</value>
											<code>"streefname = starting.txt\\n"</code>
										</flist>
										<paramfile>garli.conf</paramfile>
										<group>2</group>
										<comment>
<value>streefname Specifies where the starting tree topology and/or model parameters will come from. The tree topology may be a completely random topology (constraints will be enforced), a tree provided by the user in a file, or a tree generated by the program using a fast ML stepwise-addition algorithm (see attachmentspertaxon below). The author recommends stepwise over random. This will give it a much better starting point; on large datasets this can both reduce runtimes and improve results.Starting or fixed model parameter values may also be provided in the specified file, with or without a tree topology.</value>
<value>Some notes on starting trees/models: Nexus starting trees are allowed. Specified starting trees may have polytomies, which will be arbitrarily resolved before the run begins. Allowed Starting tree formats: Plain newick tree string (with taxon numbers or names, with or without branch lengths) or NEXUS trees block. The trees block can appear in the same file as a NEXUS data or characters block that contains the alignment, but it must specfied a second time in this box. If multiple trees appear in the specified file and multiple search replicates are specified (see searchreps setting), then the first tree is used in the first replicate, the second in the second replicate, etc.</value>
										</comment>
									</attributes>
								</parameter>
								
								<parameter type="InFile">
									<name>streefname_userdata</name> 
									<attributes>
										<precond>
											<language>perl</language>
											<code>$streefname_choose eq "upload"</code>
										</precond>
										<paramfile>garli.conf</paramfile>
										<group>2</group>
										<prompt>Use this Starting Tree (streefname file)</prompt>
										<filenames>starting.txt</filenames>
										<comment>
<value>Specify the name of the file containing the population starting conditions. Starting model parameters and/or a starting topology may be specified. If both model and topology are specified, the model must come first, and both must appear on the same line of the file. Each model parameter is specified by a letter representing the parameter type, followed by the value or values assigned. Thus r 1.4 3.4 0.55 1.09 4.94 b 0.297 0.185 0.213 0.305 a 0.66 p 0.43 ((((((140:..etc specifies starting values for the rate matrix (in the order AC, AG, AT, CG, CT), base frequencies (in the order A, C, G, T), alpha shape of the gamma rate-heterogeneity distribution and the proportion of invariable sites, and is followed by the starting tree. If starting parameters are not specified, the base frequencies begin at their empirical values, the proportion of invariable sites begins at 20% of the observed proportion of invariants sites, alpha starts at 0.5 and the rate matrix starts at values equivalent to a kappa value of 5.0. If included, the tree specification should appear in Newick format (parenthetical notation), with the taxa represented by either their name or their number in the data matrix (starting at 1). Starting branch lengths on the tree are optional. The sample dataset included with the program comes with an example of a starting model/tree file. In version 0.95, various models may be specified and various parameter values fixed. Any model parameters that appear in the starting condition file must correspond to the model chosen in the config file. In addition, any parameters specified as fixed in the config file must have their values specified here. If no file is specified, a random start tree and default model parameters will be inferred.</value>
										</comment>
									</attributes>
								</parameter>
								
								<!-- tree that's pasted in, put in starting.txt -->
								<!-- I'm commenting this out because you can't enter more than 100 characters in the gui-->
								<!--
								<parameter type="String">
									<name>streefname_pasted</name> 
									<attributes>
										<precond>
											<language>perl</language>
											<code>! defined $streefname_userdata</code>
										</precond>
										<paramfile>starting.txt</paramfile>
										<group>1</group>
										<prompt>Starting Tree (paste in here)</prompt>
										<format>
											<language>perl</language>
											<code>"$value"</code>
										</format>
									</attributes>
								</parameter>
								-->
								

<!-- New Param for V 0.96. attachmentspertaxon (1 to infinity, 50)  The number of attachment branches evaluated for each taxon to be added to the tree during the creation of an ML stepwise-addition starting tree.  Briefly, stepwise addition is an algorithm used to make a tree, and involves adding taxa in a random order to a growing tree.  For each taxon to be added, a number of randomly chosen attachment branches are tried and scored, and then the best scoring one is chosen as the location of that taxon.  The attachmentspertaxon setting controls how many attachment points are evaluated for each taxon to be added.  A value of one is equivalent to a completely random tree (only one randomly chosen location is evaluated).  A value of greater than 2 times the number of taxa in the dataset means that all attachment points will be evaluated for each taxon, and will result in very good starting trees (but may take a while on large datasets).  Even fairly small values (< 10) can result in starting trees that are much, much better than random, but still fairly different from one another. -->

<!--new parmeter, guessing section 2-->
								<parameter ismandatory="1" type="Integer">
									<name>attachments_val</name>
									<attributes>
										<prompt>Specify the number of attachment branches evaluated for each taxon (attachmentspertaxon)</prompt>
										<precond>
											<language>perl</language>
											<code>$streefname_choose eq "stepwise"</code>
										</precond>
										<vdef>
											<value>50</value>
										</vdef>
										<format>
											<language>perl</language>
											<code>"attachmentspertaxon=$value\\n"</code>
										</format>
										<paramfile>garli.conf</paramfile>
										<group>2</group>
										<comment>
<value>New Param for V 0.96. The number of attachment branches evaluated for each taxon to be added to the tree during the creation of an ML stepwise-addition starting tree.  Briefly, stepwise addition is an algorithm used to make a tree, and involves adding taxa in a random order to a growing tree.  For each taxon to be added, a number of randomly chosen attachment branches are tried and scored, and then the best scoring one is chosen as the location of that taxon.  The attachmentspertaxon setting controls how many attachment points are evaluated for each taxon to be added.  A value of one is equivalent to a completely random tree (only one randomly chosen location is evaluated).  A value of greater than 2 times the number of taxa in the dataset means that all attachment points will be evaluated for each taxon, and will result in very good starting trees (but may take a while on large datasets).  Even fairly small values (less than 10) can result in starting trees that are much, much better than random, but still fairly different from one another. </value>
										</comment>
									</attributes>
								</parameter>
								
<!--searchreps (1 to infinity, 2)  The number of independent search replicates to perform during a program execution.  You should always either do multiple search replicates or multiple program executions with any dataset to get a feel for whether you are getting consistent results, which suggests that the program is doing a decent job of searching.  Note that if this is greater than 1 and you are performing a bootstrap analysis, this is the number of search replicates to be done per bootstrap replicate.  That can increase the chance of finding the best tree per bootstrap replicate, but will also increase bootstrap runtimes enormously. -->

<!--section 2 general-->	
	<!-- If bootstrapreps = 0, searchreps=1 -->
	<!-- If bootstrapreps != 0, set bootstrapreps=1. -->						
							<parameter ismandatory="1" type="Integer">
									<name>searchreps_value</name>
									<attributes>
										<prompt>Specify the number of independent search replicates to perform during a program execution.(searchreps)</prompt>
										<vdef>
											<value>2</value>
										</vdef>
										<format>
											<language>perl</language>
											<code>($bootstrapreps &gt; 1) ? "searchreps=$value\\n" : "searchreps=1\\n"</code>
										</format>
										<paramfile>garli.conf</paramfile>
										<group>2</group>
										<ctrls>
											<ctrl>
												<message>The value for ths parameter cannot be less than 1</message>
												<language>perl</language>
												<code>$searchreps_value &lt; 1</code>
											</ctrl>
											<ctrl>
												<message>You must specify multiple searchreps and/or multiple bootstrapreps to do a parallel run on teragrid.</message>
												<language>perl</language>
												<code>$searchreps_value &lt; 2 &amp;&amp; $bootstrapreps &lt; 2</code>
											</ctrl>
<!-- added by mamiller to control for the number of processes launched -->
											<ctrl>
												<message>Sorry, the number of searchreps must be no more than 8.</message>
												<language>perl</language>
												<code>$searchreps_value &gt; 8</code>
											</ctrl>
											<ctrl>
												<message>Please enter an integer value for search repetitions</message>
												<language>perl</language>
												<code>!defined $searchreps_value</code>
											</ctrl>
										</ctrls> 
										<comment>
<value>The number of independent search replicates to perform during a program execution.  You should always either do multiple search replicates or multiple program executions with any dataset to get a feel for whether you are getting consistent results, which suggests that the program is doing a decent job of searching.  Note that if this is greater than 1 and you are performing a bootstrap analysis, this is the number of search replicates to be done per bootstrap replicate.  That can increase the chance of finding the best tree per bootstrap replicate, but will also increase bootstrap runtimes enormously.  When you specify multiple searchreps or multiple bootstraps, we will automatically run garli multiple times in parallel.</value>
										</comment>
									</attributes>
								</parameter>
								
								<parameter ismandatory="1" type="Integer">
									<name>bootstrapreps</name> 
									<attributes>
										<prompt>Bootstrap Repetitions (-bootstrapreps)</prompt>
										<precond>
											<language>perl</language>
											<code>!$inferinternalstateprobs_g</code>
										</precond>
										<vdef>
											<value>0</value>
										</vdef>
										<ctrls>
											<ctrl>
												<message>Bootstrap Repititions must be 0 or an integer 2 or greater for parallel runs on teragrid.</message>
												<language>perl</language>
												<code>$value &lt; 0 || $value ==  1</code>
											</ctrl> 
											<!-- added by mamiller to control for the number of processes launched -->
											<ctrl>
												<message>Sorry, the number of bootstrapreps must be no more than 100.</message>
												<language>perl</language>
												<code>$bootstrapreps &gt; 100 </code>
											</ctrl>
											<ctrl>
												<message>Sorry, the number of bootstrap reps times the number of searchreps must be no more than 100. Please decrease the number of searchreps, and/or the number bootstrapreps to meet this criterion. You may make addtional identical runs, if you require more bootstrapreps.</message>
												<language>perl</language>
												<code>$searchreps_value * $bootstrapreps &gt; 100 </code>
											</ctrl>
											<ctrl>
												<message>Please enter an integer value for Bootstrap repetitions</message>
												<language>perl</language>
												<code>!defined $bootstrapreps</code>
											</ctrl>
										</ctrls>									
										<comment>
											<value>The number of bootstrap reps to perform. If the value entered is 0,normal searching will be performed. If a value greater than 0 is entered, 
												normal searching will not be performed. The resulting bootstrap trees (one per rep) will be output to a file named ofprefix.boot.tre. 
												To obtain the bootstrap proportions they will then need to be read into PAUP* or a similar program to obtain a majority rule consensus.  
												Note that it is probably safe to reduce the strictness of the termination conditions during bootstrapping (perhaps halve 
												genthreshfortopoterm), which will greatly speed up the bootstrapping process with negligible effects on the results.   
												When multiple bootstrapreps or multiple searchreps are specified we will automatically run garli multiple times in parallel.
</value>
										</comment>
									</attributes>
								</parameter>
<!-- outgroup (outgroup taxa numbers, separated by spaces) This option allow for orienting the tree topologies in a consistent way when they are written to file.  Note that this has NO effect whatsoever on the actual inference and the specified outgroup is NOT constrained to be present in the inferred trees.  If multiple outgroup taxa are specified and they do not form a monophyletic group, this setting will be ignored.  If you specify a single outgroup taxon it will always be present, and the tree will always be consistently oriented.  To specify an outgroup consisting of taxa 1, 3 and 5 the format is this: outgroup = 1 3 5   group 2 -->
								<parameter type="String">
									<name>outgroup_tax</name> 
									<attributes>
										<paramfile>garli.conf</paramfile>
										<group>2</group>
										<prompt>Outgroup taxa numbers, separated by spaces (outgroup)</prompt>
										<format>
											<language>perl</language>
											<code>"outgroup = $value\\n"</code>
										</format>
										<comment>
<value>The outgroup option allow for orienting tree topologies in a consistent way when they are written to file.  Note that this has NO effect whatsoever on the actual inference and the specified outgroup is NOT constrained to be present in the inferred trees.  If multiple outgroup taxa are specified and they do not form a monophyletic group, this setting will be ignored.  If you specify a single outgroup taxon it will always be present, and the tree will always be consistently oriented.  To specify an outgroup consisting of taxa 1, 3 and 5 the format is this: outgroup = 1 3 5</value>
</comment>
									</attributes>
								</parameter>
<!-- One undocumented (and semi-experimental) feature that you might want to add would be the "collapsebranches" boolean entry in the general section.  This tells the program to collapse minimum length branches (effectively zero length) branch upon output of the final trees.  

Otherwise the final trees are always fully bifurcating, even when returning a polytomy makes more sense.  For some datasets this can make a big difference because final trees may in fact be identical with those branches collapsed, but they will appear different if they are compared on the basis of the topology alone (for example, when calculating tree to tree distances).  If simply visualized with the branches proportional to their lengths the trees will look identical because the tiny branches will be indistinguishable from a polytomy.  This feature can be particularly important in the case of bootstrapping, where you don't really want branches that effectively don't exist (and are an arbitrary resolution of a polytomy) to be counted in the support values.  The only downside of this setting is that GARLI's test at the end of a run for whether the trees from each replicates are identical may be wrong if branches are collapsed.  I don't know if you use or return that information anyway (the .screen.log file), so it may not be a big deal.-->

								<parameter type="Switch">
									<name>collapsebranches_g</name> 
									<attributes>
										<prompt>Collapse minimum length branches (effectively zero length) branch upon output of the final tree</prompt>
										<vdef>
											<value>0</value>
										</vdef>
										<precond>
											<language>perl</language>
											<code>$bootstrapreps == 0</code>
										</precond>
									</attributes>
								</parameter>
								
								<parameter type="Switch" ishidden="1">
									<name>collapsebranches</name> 
									<attributes>
										<paramfile>garli.conf</paramfile>
										<group>2</group>
										<format>
											<language>perl</language>
											<code>"collapsebranches = $collapsebranches_g\\n" </code>
										</format>
										<comment>
											<value>Collapsebranches tells the program to collapse minimum length branches (effectively zero length) branch upon output of the final trees. Otherwise the final trees are always fully bifurcating, even when returning a polytomy makes more sense. For some datasets this can make a big difference, because final trees may in fact be identical with those branches collapsed, but they will appear different if they are compared on the basis of the topology alone (for example, when calculating tree to tree distances). If visualized with the branches proportional to their lengths the trees will look identical because the tiny branches will be indistinguishable from a polytomy. This feature can be particularly important in the case of bootstrapping, where you don't really want branches that effectively don't exist (and are an arbitrary resolution of a polytomy) to be counted in the support values. The only downside of this setting is that GARLI's test at the end of a run for whether the trees from each replicates are identical may be wrong if branches are collapsed.</value>
										</comment>
									</attributes>
								</parameter>
<!-- try to add the collapse branch parameter -->	
							
<!--constraint file group 2-->
								<parameter type="InFile">
									<name>constraintfile_control</name> 
									<attributes>
										<paramfile>garli.conf</paramfile>
										<group>2</group>
										<prompt>Use this Constraint File (constraintfile)</prompt>
										<filenames>constraint.txt</filenames>
										<comment>
<value>The constraint file contains any topology constraint specifications, or none if there are no constraints. With Version 0.96, backbone constraints can be uploaded.
A backbone constraint is the same as any other constraint file, but not all taxa need be represented. Format: Consider a dataset of 8 taxa, in which your constraint consists of grouping taxa 1, 3 and 5. You may specify either positive constraints (inferred tree MUST contain constrained group) or negative constraints (also called converse constraints, inferred tree CANNOT contain constrained group).
These are specified with either a + or a - at the beginning of the constraint specification, for positive and negative constraints, respectively.
For a positive constraint on a grouping of taxa 1, 3 and 5: +((1,3,5), 2, 4, 6, 7, 8); For a negative constraint on a grouping on taxa 1, 3 and 5:
-((1,3,5), 2, 4, 6, 7, 8); (Note that there are many other equivalent parenthetical representations of this constraint.)
GARLI also accepts another constraint format that may be easier to use in some cases. This involves specifying a single branch to be constrained
with a string of * (asterisk) and . (period) characters, with one character per taxon. Each taxon specified with a * falls on one side of the
constrained branch, and all those specified with a . fall on the other. This should be familiar to anyone who has looked at PAUP* bootstrap output.
With this format, a positive constraint on a grouping of taxa 1, 3 and 5 would look like this: +*.*.*... or alternatively like this: +.*.*.***
With this format each line only designates a single branch, so multiple constrained branches may be specified as multiple lines in the file.</value>
</comment>
									</attributes>
								</parameter>
	<!--these values are loaded in the param above-->
								<parameter type="String" ishidden="1">
									<name>constraintfile</name>
									<attributes>
										<group>2</group>
										<paramfile>garli.conf</paramfile>
										<format>
											<language>perl</language>
											<code>
												(defined $constraintfile_control) ? "constraintfile = constraint.txt\\n" :
													"constraintfile = none\\n"
											</code>
										</format>
									</attributes>
								</parameter>
							</parameters>

						</paragraph>
					</parameter> 

<!-- Trees Paragraph-->

					<!-- Initialization -->
					<!-- ======================================================================================== -->
					<parameter type="Paragraph">
						<paragraph>
							<name>model_initialization</name>
							<prompt>Initialization</prompt>
							<parameters>

								<parameter type="String"  ishidden="1">
									<name>model_initialization_hidden</name> 
									<attributes>
										<paramfile>garli.conf</paramfile>
										<group>2</group>
										<format>
											<language>perl</language>
											<code> 
												"refinestart = $refinestart\\n" .
												"randseed = $randseed\\n" 
											</code>
										</format>

									</attributes>
								</parameter>
<!--these values are loaded in the param above-->
								<parameter type="Switch">
									<name>refinestart</name> 
									<attributes>
										<prompt>Perform Initial Rough Optimization (refinestart)</prompt>
										<vdef>
											<value>1</value>
										</vdef>
										<comment>
<value>Specifies whether some initial rough optimization is performed on the starting branch lengths and alpha parameter. This is always recommended. 
</value>
										</comment>
									</attributes>
								</parameter>
<!--these values are loaded in the param above-->
								<parameter type="Integer">
									<name>randseed</name> 
									<attributes>
										<prompt>Random Seed ( -1 means it will be chosen for you) </prompt>
										<vdef>
											<value>-1</value>
										</vdef>
										<comment>
<value>The random number seed used by the random number generator. Specify -1 to have a seed chosen for you.
Specifying the same seed number in multiple runs will result in exactly identical runs, if all other parameters are also identical.</value>
										</comment>
									</attributes>
								</parameter>

							</parameters>

						</paragraph>
					</parameter> <!--  Initialization Paragraph-->

				</parameters>

			</paragraph>
		</parameter> <!-- Model Paragraph-->

		<!-- Genetic Algorithm  -->
		<!-- ==================================================================================================== -->
		<parameter type="Paragraph">
			<paragraph>
				<name>algorithm</name>
				<prompt>Genetic Algorithm</prompt>
				<parameters>

					<!-- ======================================================================================== -->
					<parameter type="Paragraph">
						<paragraph>
							<name>algorithm_population</name>
							<prompt>Population</prompt>
							<parameters>

								<parameter type="String"  ishidden="1">
									<name>poplulation_hidden</name> 
									<attributes>
										<paramfile>garli.conf</paramfile>
										<group>4</group>
										<format>
											<language>perl</language>
											<code> 
												"selectionintensity = $selectionintensity\\n" .
												"nindivs = $nindivs\\n" .
												"holdover = $holdover\\n" 
											</code>
										</format>
									</attributes>
								</parameter>
								
<!--these values are loaded in the param above-->
								<parameter type="Float">
									<name>selectionintensity</name> 
									<attributes>
										<prompt>Selection Intensity (0.01 to 5.0) (selectionintensity)</prompt>
										<vdef>
											<value>0.5</value>
										</vdef>
										<ctrls>
											<ctrl>
												<message>Selection Intensity must be between 0.01 - 5.0</message>
												<language>perl</language>
												<code>$selectionintensity &lt; 0.01 || $selectionintensity &gt; 5.0</code>
											</ctrl>
										</ctrls>
										<comment>
<value>Controls the strength of selection, with larger numbers denoting stronger selection. The relative probability of reproduction of two
individuals depends on the difference in their log likelihoods (delta lnL) and is formulated very similarly to the procedure of calculating Akaike
weights. The relative probability of reproduction of the less fit individual is equal to: 
In  general this setting does not seem to have much of an effect on the progress of a run. In theory higher values should cause scores to
increase more quickly, but make the search more likely to be entrapped in a local optimum. The following table gives the relative probabilities
of reproduction for different values of the selection intensity when the difference in log likelihood is 1.0 
Selection intensity 	Ratio of probabilities of reproduction 
0.05 	0.95:1.0 
0.1 	0.90:1.0 
0.25 	0.78:1.0 
0.5 	0.61:1.0 	
0.75 	0.47:1.0 	
1 	0.37:1.0 	
2 	0.14:1.0 	
</value>
										</comment>
									</attributes>
								</parameter>

								<parameter type="Integer">
									<name>nindivs</name> 
									<attributes>
										<prompt>Number of Individuals (nindivs 2 to 100)</prompt>
										<vdef><value>4</value></vdef>
										<ctrls>
											<ctrl>
												<message>Number of individuals must be between 2 - 100</message>
												<language>perl</language>
												<code>$nindivs &lt; 2 || $nindivs &gt; 100</code>
											</ctrl>
										</ctrls>
										<comment>
<value>The number of individuals in the population. This may be increased, but generally seems to slow the rate of score increase.</value></comment>
									</attributes>
								</parameter>

								<parameter ishidden="1" type="Integer">
<!-- the manual recommends this not be changed -->
									<name>holdover</name> 
									<attributes>
										<vdef>
											<value>1</value>
										</vdef>
									</attributes>
								</parameter>

							</parameters> 
						</paragraph>
					</parameter> <!-- Population paragraph -->
					
					<!-- ======================================================================================== -->
					<parameter type="Paragraph">
						<paragraph>
							<name>algorithm_brlen</name>
							<prompt>Branch-length Optimization</prompt>
							<parameters>

								<parameter type="String"  ishidden="1">
									<name>brlen_hidden</name> 
									<attributes>
										<paramfile>garli.conf</paramfile>
										<group>4</group>
										<format>
											<language>perl</language>
											<code> 
												"startoptprec = $startoptprec\\n" .
												"minoptprec = $minoptprec\\n"  .
												"numberofprecreductions = $numberofprecreductions\\n" 
											</code>
										</format>
									</attributes>
								</parameter>
<!--these values are loaded in the param above-->
								<parameter type="Float">
									<name>startoptprec</name> 
									<attributes>
										<prompt>Starting Precision (startoptprec: 0.005 - 5.0)</prompt>
										<vdef><value>0.5</value></vdef>
										<ctrls>
											<ctrl>
												<message>Starting Precision must be between 0.005 - 5.0</message>
												<language>perl</language>
												<code>$startoptprec &lt; 0.005 || $startoptprec &gt; 5.0</code>
											</ctrl>
										</ctrls>
									</attributes>
								</parameter>

								<parameter type="Float">
									<name>minoptprec</name> 
									<attributes>
										<prompt>Minimum Precision (minoptprec: 0.001 - 0.01)</prompt>
										<vdef><value>0.01</value></vdef>
										<ctrls>
											<ctrl>
												<message>Minimum Precision must be between 0.001 - 0.01</message>
												<language>perl</language>
												<code>$minoptprec &lt; 0.001 || $minoptprec &gt; 0.01</code>
											</ctrl>
										</ctrls>
									</attributes>
								</parameter>

								<parameter type="Integer">
									<name>numberofprecreductions</name> 
									<attributes>
										<prompt>Number of Precision Reductions (0 - 100)</prompt>
										<vdef><value>20</value></vdef>
										<ctrls>
											<ctrl>
												<message>Number of Precision Reductions must be between 0 - 100</message>
												<language>perl</language>
												<code>$minoptprec &lt; 0 || $minoptprec &gt; 100</code>
											</ctrl>
										</ctrls>
										<comment>
<value>Specify the number of steps that it will take for the optimization precision to decrease from startoptprec to minoptprec.
In version 0.95, the reduction from startoptprec to minoptprec is linear, rather than geometric. </value>
										</comment>
									</attributes>
								</parameter>

							</parameters>
						</paragraph>
					</parameter> <!-- Branch length optimizations -->
					
					<!-- ======================================================================================== -->
					<parameter type="Paragraph">
						<paragraph>
							<name>algorithm_mutation_prior_weighting</name>
							<prompt>Mutation Prior Weighting</prompt>
							<parameters>

								<parameter type="String"  ishidden="1">
									<name>prior_weighting_hidden</name> 
									<attributes>
										<paramfile>garli.conf</paramfile>
										<group>4</group>
										<format>
											<language>perl</language>
											<code> 
												"modweight = $modweight\\n" .
												"brlenweight = $brlenweight\\n" .
												"topoweight = $topoweight\\n" .
												"randnniweight = $randnniweight\\n" .
												"randsprweight = $randsprweight\\n" .
												"limsprweight = $limsprweight\\n" 
											</code>
										</format>
									</attributes>
								</parameter>

								<parameter type="Float">
									<name>modweight</name> 
									<attributes>
										<prompt>Model Mutations (modweight)</prompt>
										<vdef><value>0.05</value></vdef>
										<ctrls>
											<ctrl>
												<message>Model Mutations must be 0 or greater.</message>
												<language>perl</language>
												<code>$modweight &lt; 0</code>
											</ctrl>
										</ctrls>
										<comment>
<value>The prior weight assigned to the class of model mutations. Note that setting this at 0.0 fixes the model during the run. </value></comment>
									</attributes>
								</parameter>

								<parameter type="Float">
									<name>brlenweight</name> 
									<attributes>
										<prompt>Branch-length Mutations (brlenweight)</prompt>
										<vdef><value>0.2</value></vdef>
										<ctrls>
											<ctrl>
												<message>Branch-length Mutations must be 0 or greater.</message>
												<language>perl</language>
												<code>$brlenweight &lt; 0</code>
											</ctrl>
										</ctrls>
										<comment>
											<value>The prior weight assigned to branch-length mutations. </value>
										</comment>
									</attributes>
								</parameter>

								<parameter type="Float">
									<name>topoweight</name> 
									<attributes>
										<paramfile>garli.conf</paramfile>
										<group>4</group>
										<prompt>All Topology Mutations (topoweight)</prompt>
										<vdef><value>1.0</value></vdef>
										<ctrls>
											<ctrl>
												<message>:All Topology Mutations: must be 0 or greater.</message>
												<language>perl</language>
												<code>$topoweight &lt; 0</code>
											</ctrl>
										</ctrls>
										<comment>
<value>The prior weight assigned to the class of topology mutations (NNI, SPR and limSPR).</value>
										</comment>
									</attributes>
								</parameter>

								<parameter type="Float">
									<name>randnniweight</name> 
									<attributes>
										<prompt>NNI Mutations (randnniweight)</prompt>
										<vdef><value>0.1</value></vdef>
										<ctrls>
											<ctrl>
												<message>NNI Mutations must be 0 or greater.</message>
												<language>perl</language>
												<code>$randnniweight &lt; 0</code>
											</ctrl>
										</ctrls>
										<comment>
											<value>The prior weight assigned to NNI mutations.</value>
										</comment>
									</attributes>
								</parameter>

								<parameter type="Float">
									<name>randsprweight</name> 
									<attributes>
										<prompt>SPR Mutations (randsprweight)</prompt>
										<vdef><value>0.3</value></vdef>
										<ctrls>
											<ctrl>
												<message>SPR Mutations must be 0 or greater.</message>
												<language>perl</language>
												<code>$randsprweight &lt; 0</code>
											</ctrl>
										</ctrls>
										<comment>
<value>randsprweight (0 to infinity, 0.3) -The prior weight assigned to random SPR mutations.
For very large datasets it is often best to set this to 0.0, as random SPR mutations essentially never result in score increases.
</value>
										</comment>
									</attributes>
								</parameter>

								<parameter type="Float">
									<name>limsprweight</name> 
									<attributes>
										<prompt>Limited SPR Mutations (limsprweight)</prompt>
										<vdef><value>0.6</value></vdef>
										<ctrls>
											<ctrl>
												<message>Limited SPR Mutations must be 0 or greater.</message>
												<language>perl</language>
												<code>$limsprweight &lt; 0</code>
											</ctrl>
										</ctrls>
										<comment>
<value>The prior weight assigned to SPR mutations with the reconnection branch limited to being a maximum of limsprrange
branches away from where the branch was detached.</value>
										</comment>
									</attributes>
								</parameter>

							</parameters>
						</paragraph>
					</parameter>  <!-- Mutation Prior Weighting paragraph -->
					
					<!-- ======================================================================================== -->
					<parameter type="Paragraph">
						<paragraph>
							<name>algorithm_mutation_details</name>
							<prompt>Mutation Details</prompt>
							<parameters>

								<parameter type="String"  ishidden="1">
									<name>mutation_details_hidden</name> 
									<attributes>
										<paramfile>garli.conf</paramfile>
										<group>4</group>
										<format>
											<language>perl</language>
											<code> 
												"limsprrange= $limsprrange\\n" .
												"uniqueswapbias = $uniqueswapbias\\n" .
												"distanceswapbias = $distanceswapbias\\n" 
											</code>
										</format>
									</attributes>
								</parameter>
<!--these values are loaded in the param above-->
								<parameter type="Integer">
									<name>limsprrange</name> 
									<attributes>
										<prompt>Max Limited SPR Branch Movement (limsprrange)</prompt>
										<vdef><value>6</value></vdef>
										<ctrls>
											<ctrl>
												<message>Limited SPR Branch Movement must be 0 or greater.</message>
												<language>perl</language>
												<code>$limsprrange &lt; 0</code>
											</ctrl>
										</ctrls>
										<comment>
	<value>The maximum number of branches away from its original location that a branch may be reattached during a limited SPR move.
	Setting this too high (> 10) can seriously degrade performance. </value>
										</comment>
									</attributes>
								</parameter>

								<parameter type="Float">
									<name>uniqueswapbias</name> 
									<attributes>
										<prompt>Unique Swap Bias (uniqueswapbias)</prompt>
										<vdef>
											<value>0.1</value>
										</vdef>
										<ctrls>
											<ctrl>
												<message>Unique Swap Bias must be between 0.01 - 1.0</message>
												<language>perl</language>
												<code>$uniqueswapbias  &lt; 0.01 || $uniqueswapbias &gt; 1.0</code>
											</ctrl>
										</ctrls>
									</attributes>
								</parameter>

<!-- Made this hidden because Derrick says it doesn't work and should be left at 1.0 -->
								<parameter type="Float"  ishidden="1">
									<name>distanceswapbias</name> 
									<attributes>
										<prompt>Distance Swap Bias (distanceswapbias)</prompt>
										<vdef><value>1.0</value></vdef>
									</attributes>
								</parameter>

							</parameters>
						</paragraph>
					</parameter> 
					
					
				</parameters>
			</paragraph>
		</parameter> 
		<!-- Genetic Algorithm -->

		<!-- ==================================================================================================== -->
					<!-- Logs Paragraph-->
					<!-- ======================================================================================== -->
					<parameter type="Paragraph">
						<paragraph>
							<name>general_logs</name>
							<prompt>Logs</prompt>
							<parameters>

								<parameter type="Integer">
									<name>saveevery_g</name> 
									<attributes>
										<prompt>Save best tree with interval (saveevery)</prompt>
										<vdef><value>100</value></vdef>
										<ctrls>
											<ctrl>
												<message>Save best tree with interval must be greater than 1</message>
												<language>perl</language>
												<code>$value &lt; 1</code>
											</ctrl>
										</ctrls>
									</attributes>
								</parameter>
<!--these values are loaded in the param above-->
								<parameter type="Integer" ishidden="1">
									<name>saveevery</name> 
									<attributes>
										<paramfile>garli.conf</paramfile>
										<group>2</group>
										<format>
											<language>perl</language>
											<code>"saveevery = $saveevery_g\\n"</code>
										</format>
									</attributes>
								</parameter>
								
<!--Available in 0.96,m but not yet implemented -->
<!--outputcurrentbesttopology (0 or 1.0)  If true, the current best tree of the current search replicate is written to <ofprefix>.best.current.tre every saveevery generations.  In versions before 0.96 the current best topology was always written to file, but that is no longer the case. Seeing the current best tree has no real use apart from satisfying your curiosity about how a run is going. -->

<!-- not sure how to deliver this, will ask terri -->
<!--								<parameter  ismandatory="1" type="Excl">
									<name>loutputbesttop</name> 
									<attributes>
										<prompt>Save best score with interval</prompt>
										<vdef><value>10</value></vdef>
										<ctrls>
											<ctrl>
												<message>Save best score with interval must be greater than 1</message>
												<language>perl</language>
												<code>$value &lt; 1</code>
											</ctrl>
										</ctrls>
									</attributes>
								</parameter>
								<parameter type="Integer" ishidden="1">
									<name>logevery</name> 
									<attributes>
										<paramfile>garli.conf</paramfile>
										<group>2</group>
										<format>
											<language>perl</language>
											<code>"logevery = $logevery_g\\n"</code>
										</format>
									</attributes>
								</parameter> -->
								
<!-- terri built many of these simple params as match-mated pairs: they are hidden switches with integer inputs; the first param is visible and is named param_g, the second is names param; they can' t function alone so be careful -->
								
								<parameter type="Integer">
									<name>logevery_g</name> 
									<attributes>
										<prompt>Save best score with interval (logevery)</prompt>
										<vdef><value>10</value></vdef>
										<ctrls>
											<ctrl>
												<message>Save best score with interval must be greater than 1</message>
												<language>perl</language>
												<code>$value &lt; 1</code>
											</ctrl>
										</ctrls>
										<comment>
				<value>The frequency with which the best score is written to the log file. </value>
										</comment>
									</attributes>
								</parameter>
								
								<parameter type="Integer" ishidden="1">
									<name>logevery</name> 
									<attributes>
										<paramfile>garli.conf</paramfile>
										<group>2</group>
										<format>
											<language>perl</language>
											<code>"logevery = $logevery_g\\n"</code>
										</format>
									</attributes>
								</parameter>
								
<!-- terri built many of these simple params as match-mated pairs: they are hidden switches with integer inputs; the first param is visible and is named param_g, the second is names param; they can' t function alone so be careful -->
								<parameter type="Switch">
									<name>outputeachbettertopology_g</name> 
									<attributes>
										<prompt>Save each improved topology (outputeachbettertopology; can result in a very large file)</prompt>
										<vdef>
											<value>0</value>
										</vdef>
										<comment>
<value>If true, each new topology encountered with a better score than the previous best is written to file. In some cases this can result in really big files, possibly hundreds of MB, especially for random starting topologies on large datasets. Note that this file is interesting to get an idea of how the topology changed as the searches progressed, but the collection of trees should NOT be interpreted in any meaningful way. This option is not available while bootstrapping.</value>
										</comment>
									</attributes>
								</parameter>
								
								<parameter type="Switch"  ishidden="1">
									<name>outputeachbettertopology</name> 
									<attributes>
										<paramfile>garli.conf</paramfile>
										<group>2</group>
										<format>
											<language>perl</language>
											<code>"outputeachbettertopology = $outputeachbettertopology_g\\n" </code>
										</format>
									</attributes>
								</parameter>

<!-- terri built many of these simple params as match-mated pairs: they are hidden switches with integer inputs; the first param is visible and is named param_g, the second is names param; they can' t function alone so be careful -->
								<parameter type="Switch">
									<name>inferinternalstateprobs_g</name> 
									<attributes>
										<prompt>Output state probabilities of internal nodes (inferinternalstateprobs)</prompt>
										<vdef>
											<value>0</value>
										</vdef>
										<precond>
											<language>perl</language>
											<code>$bootstrapreps == 0</code>
										</precond>
									</attributes>
								</parameter>
								
								<parameter type="Switch" ishidden="1">
									<name>inferinternalstateprobs</name> 
									<attributes>
										<paramfile>garli.conf</paramfile>
										<group>4</group>
										<format>
											<language>perl</language>
											<code>"inferinternalstateprobs = $inferinternalstateprobs_g\\n" </code>
										</format>
										<comment>
											<value>Use this flag to have GARLI infer the marginal posterior probability of each character at each internal node. This is done at the very end of the run, just before termination. The results are output to a file named ofprefix.internalstates.log. </value>
										</comment>
									</attributes>
								</parameter>

<!-- terri built many of these simple params as match-mated pairs: they are hidden switches with integer inputs; the first param is visible and is named param_g, the second is names param; they can' t function alone so be careful -->
								<parameter type="Switch">
									<name>outputphyliptree_g</name> 
									<attributes>
										<prompt>Output PHYLIP-format tree (outputphyliptree)</prompt>
										<vdef><value>0</value></vdef>
									</attributes>
								</parameter>
								
								<parameter type="Switch"  ishidden="1">
									<name>outputphyliptree</name> 
									<attributes>
										<paramfile>garli.conf</paramfile>
										<group>2</group>
										<format>
											<language>perl</language>
											<code>"outputphyliptree = $outputphyliptree_g\\n" </code>
										</format>
									</attributes>
								</parameter>

<!-- terri built many of these simple params as match-mated pairs: they are hidden switches with integer inputs; the first param is visible and is named param_g, the second is names param; they can' t function alone so be careful -->

								<parameter type="Switch">
									<name>outputmostlyuselessfiles_g</name> 
									<attributes>
										<prompt>Output files of questionable utility</prompt>
										<vdef><value>0</value></vdef>
									</attributes>
								</parameter>

								<parameter type="Switch"  ishidden="1">
									<name>outputmostlyuselessfiles</name> 
									<attributes>
										<paramfile>garli.conf</paramfile>
										<group>2</group>
										<format>
											<language>perl</language>
											<code>"outputmostlyuselessfiles = $outputmostlyuselessfiles_g\\n" </code>
										</format>
										<comment><value>Whether to output three files of little general interest: the fate, problog, and swaplog files. The fate file shows the parentage, mutation types and scores of every individual in the population during the entire search. The problog shows how the proportions of the different mutation types changed over the course of the run. The swaplog shows the number of unique swaps and the number of total swaps on the current best tree over the course of the run.</value>
										</comment>
									</attributes>
								</parameter>

							</parameters> 

						</paragraph> 
					</parameter> 			
					<!-- Logs Paragraph -->
					
					<!-- Run Termination Paragraph-->
					<!-- ======================================================================================== -->
					<parameter type="Paragraph">
						<paragraph>
							<name>general_run</name>
							<prompt> Run Termination</prompt>
							<parameters>

<!-- terri built these simple params as a hidden parameter that proivide the single submission point for values collected from user input boxes; the user input box parmaters have no executive component of their own. they can' t function alone so be careful -->

								<parameter type="String" ishidden="1">
									<name>hidden_group2</name>
									<attributes>
										<paramfile>garli.conf</paramfile>
										<group>2</group>
										<format>
											<language>perl</language>
											<code>
												"enforcetermconditions = $enforcetermconditions\\n" .
												"genthreshfortopoterm = $genthreshfortopoterm\\n" .
												"significanttopochange = $significanttopochange\\n" .
												"scorethreshforterm = $scorethreshforterm\\n" 
											</code>
										</format>
									</attributes>
								</parameter>

								<!-- Stopgen and stoptime are always applied, regardless of whether enforcetermconditions has been set.  -->
								<parameter type="String" ishidden="1">
									<name>hidden_group4</name>
									<attributes>
										<paramfile>garli.conf</paramfile>
										<group>4</group>
										<format>
											<language>perl</language>
											<code>
												"stopgen = $stopgen\\n" .
												"stoptime = $stoptime\\n" .
												"resampleproportion = $resampleproportion\\n"
											</code>
										</format>
									</attributes>
								</parameter>
<!--- If bootstrapreps != 0, set nruns=bootstrapreps and bootstrapreps=1.-->
								<parameter type="String" ishidden="1">
									<name>hidden_group4_bootstrap</name>
									<attributes>
										<paramfile>garli.conf</paramfile>
										<group>4</group>
										<format>
											<language>perl</language>
											<code>
												($bootstrapreps  &gt; 1) ? "bootstrapreps=1\\n" : "bootstrapreps=$bootstrapreps\\n" 
											</code>
										</format>
									</attributes>
								</parameter>

								<parameter type="Switch">
									<name>enforcetermconditions</name> 
									<attributes>
										<prompt>Automatically terminate run (enforcetermconditions; recommended)</prompt>
										<vdef><value>1</value></vdef>
									</attributes>
								</parameter>

								<parameter type="Integer">
									<name>genthreshfortopoterm</name> 
									<attributes>
										<precond>
											<language>perl</language>
											<code>$enforcetermconditions</code>
										</precond>
										<prompt>Generations without improving topology (genthreshfortopoterm)</prompt>
										<vdef><value>20000</value></vdef>
										<!---Change all genthreshfortopoterm from 10K to 20K-->
										<ctrls>
											<ctrl>
												<message>Generations without improving topology must be a positive integer</message>
												<language>perl</language>
												<code>$value &lt; 0</code>
											</ctrl>
										</ctrls>
										<comment>
<value>This specifies the first part of the termination condition.  When no new significantly better scoring topology see significanttopochange below) has been encountered in greater than this number of generations, this condition is met. Increasing this parameter may improve the lnL scores obtained (especially on large datasets), but will also increase runtimes. </value>
										</comment>
									</attributes>
								</parameter>

								<parameter type="Float">
									<name>significanttopochange</name> 
									<attributes>
										<precond>
											<language>perl</language>
											<code>$enforcetermconditions</code>
										</precond>
										<prompt>lnL increase for significantly better topology (significanttopochange)</prompt>
										<vdef><value>0.01</value></vdef>
										<ctrls>
											<ctrl>
												<message>lnL increase for significantly better topology must be a positive number</message>
												<language>perl</language>
												<code>$value &lt; 0</code>
											</ctrl>
										</ctrls>
										<comment>
<value>The lnL increase required for a new topology to be considered significant as far as the termination condition is concerned. It probably doesn't need to be played with, but you might try increasing it slightly if your runs reach a stable score and then take a very long time to terminate due to very minor changes in topology.</value>
										</comment>
									</attributes>
								</parameter>

								<parameter type="Float">
									<name>scorethreshforterm</name> 
									<attributes>
										<precond>
											<language>perl</language>
											<code>$enforcetermconditions</code>
										</precond>
										<prompt>Score improvement threshold (scorethreshforterm)</prompt>
										<vdef><value>0.05</value></vdef>
										<ctrls>
											<ctrl>
												<message>:Score improvement threshold: must be a positive number.</message>
												<language>perl</language>
												<code>$value &lt; 0</code>
											</ctrl>
										</ctrls>
										<comment>
<value>The second part of the termination condition.  When the total improvement in score over the last intervallength x intervalstostore generations (default is 500 generations, see below) is less than this value, this condition is met.  This does not usually need to be changed. </value>
										</comment>
									</attributes>
								</parameter>

								<parameter type="Integer">
									<name>stopgen</name> 
									<attributes>
										<prompt>Limit generations to maximum of (stopgen)</prompt>
										<vdef><value>214783646</value></vdef>
										<ctrls>
											<ctrl>
												<message>:Limit generations to maximum of: must be a positive number</message>
												<language>perl</language>
												<code>$value &lt; 1</code>
											</ctrl>
										</ctrls>
										<comment>
<value>The maximum number of generations to run. Note that this supersedes the automated stopping criterion (see enforcetermconditions above), and should therefore be set to a very large value if automatic termination is desired.</value>
										</comment>
									</attributes>
								</parameter>

								<parameter type="Integer">
									<name>stoptime</name> 
									<attributes>
										<prompt>Limit run time to maximum of (stoptime, in seconds)</prompt>
										<vdef><value>214783646</value></vdef>
										<ctrls>
											<ctrl>
												<message>:Limit run time to maximum of: must be a positive number</message>
												<language>perl</language>
												<code>$value &lt; 1</code>
											</ctrl>
										</ctrls>
										<comment>
<value>The maximum number of seconds for the run to continue. Note that this supersedes the automated stopping criterion (see enforcetermconditions above), and should therefore be set to a very large value if automatic termination is desired. </value>
										</comment>
									</attributes>
								</parameter>

<!--When bootstrapreps are less than 0, this setting allows for bootstrap-like resampling, but with the pseudoreplicate datasets having a different number of alignment columns than the real data.  Setting values greater than 1.0 is akin to jackknifing. -->

								<parameter type="Float">
									<name>resampleproportion</name> 
									<attributes>
										<prompt>Resampling where the pseudoreplicate datasets have a different number of alignment columns than the real data (resampleproportion)</prompt>
										<precond>
											<language>perl</language>
											<code>$bootstrapreps &gt; 0</code>
										</precond>
										<vdef>
											<value>1.0</value>
										</vdef>
										<ctrls>
											<ctrl>
												<message>Resample proportion must be a positive number less than 10</message>
												<language>perl</language>
												<code>$value &lt; 0 || $value &gt; 10</code>
											</ctrl>
										</ctrls> 
										<comment>
<value>When bootstrapreps is greater than 0, this setting allows for bootstrap-like resampling, but with the pseudoreplicate datasets having a different number of alignment columns than the real data.  Setting values less than 1.0 is akin to jackknifing 
</value>
										</comment>
									</attributes>
								</parameter>
							</parameters>
								
							
						</paragraph>

					</parameter>

		<!-- Run Termination-->
<!-- ============================================================================================================= -->
<!-- All of the following are hidden, therefore the ctrls and preconds that would be required
if users could change them have not been filled in. -->
<!-- ============================================================================================================= -->

<!-- checkpoint and restart are disabled for now, not sure how we'd do it in swami -->
<parameter type="Switch"  ishidden="1">
	<name>writecheckpoints</name> 
	<attributes>
		<paramfile>garli.conf</paramfile>
		<group>2</group>
		<prompt>Write Checkpoints (writecheckpoints)</prompt>
		<format>
			<language>perl</language>
			<code>"writecheckpoints = $vdef\\n" </code>
		</format>
		<vdef><value>0</value></vdef>
	</attributes>
</parameter>

<parameter type="Switch"  ishidden="1">
	<name>restart</name> 
	<attributes>
		<paramfile>garli.conf</paramfile>
		<group>2</group>
		<prompt>Restart (restart)</prompt>
		<format>
			<language>perl</language>
			<code>"restart = $vdef\\n" </code>
		</format>
		<vdef><value>0</value></vdef>
	</attributes>
</parameter>


<!-- I don't think the OSX GUI version of garli lets users set the following parameters -->
<parameter type="Integer"  ishidden="1">
	<name>holdoverpenalty</name> 
	<attributes>
		<paramfile>garli.conf</paramfile>
		<group>4</group>
		<prompt>Holdover Penalty (holdoverpenalty)</prompt>
		<format>
			<language>perl</language>
			<code>"holdoverpenalty = $vdef\\n" </code>
		</format>
		<vdef><value>0</value></vdef>
	</attributes>
</parameter>

<parameter type="Float"  ishidden="1">
	<name>treerejectionthreshold</name> 
	<attributes>
		<paramfile>garli.conf</paramfile>
		<group>4</group>
		<prompt>treerejectionthreshold</prompt>
		<format>
			<language>perl</language>
			<code>"treerejectionthreshold = $vdef\\n" </code>
		</format>
		<vdef><value>50.0</value></vdef>
	</attributes>
</parameter>


<parameter type="Integer"  ishidden="1">
	<name>intervallength</name> 
	<attributes>
		<paramfile>garli.conf</paramfile>
		<group>4</group>
		<prompt>intervallength</prompt>
		<format>
			<language>perl</language>
			<code>"intervallength = $vdef\\n" </code>
		</format>
		<vdef><value>100</value></vdef>
	</attributes>
</parameter>

<parameter type="Integer"  ishidden="1">
	<name>intervalstostore</name> 
	<attributes>
		<paramfile>garli.conf</paramfile>
		<group>4</group>
		<prompt>intervalstostore</prompt>
		<format>
			<language>perl</language>
			<code>"intervalstostore = $vdef\\n" </code>
		</format>
		<vdef><value>5</value></vdef>
	</attributes>
</parameter>

<parameter type="Integer"  ishidden="1">
	<name>meanbrlenmuts</name> 
	<attributes>
		<paramfile>garli.conf</paramfile>
		<group>4</group>
		<prompt>Mean Branch-length mutations (1 - # taxa)</prompt>
		<format>
			<language>perl</language>
			<code>"meanbrlenmuts = $vdef\\n" </code>
		</format>
		<vdef><value>5</value></vdef>
	</attributes>
</parameter>

<parameter type="Integer"  ishidden="1">
	<name>gammashapebrlen</name> 
	<attributes>
		<paramfile>garli.conf</paramfile>
		<group>4</group>
		<prompt>gammashapebrlen</prompt>
		<format>
			<language>perl</language>
			<code>"gammashapebrlen = $vdef\\n" </code>
		</format>
		<vdef><value>1000</value></vdef>
	</attributes>
</parameter>

<parameter type="Integer"  ishidden="1">
	<name>gammashapemodel</name> 
	<attributes>
		<paramfile>garli.conf</paramfile>
		<group>4</group>
		<prompt>gammashapemodel</prompt>
		<format>
			<language>perl</language>
			<code>"gammashapemodel = $vdef\\n" </code>
		</format>
		<vdef><value>1000</value></vdef>
	</attributes>
</parameter>

</parameters>
</pise>

<!--
Rami advised using multiple ctrl elements instead of logical
operators within a ctrl.  The perl code is translated to javascript
and run in the client's browser.  In the future, Jeremy will try to
run the same logic in java validators.

Note that the code expresses the ERROR condition.  In other words
if the code evaluates to true, there is an error.
-->


