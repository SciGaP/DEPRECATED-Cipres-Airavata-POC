<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE pise SYSTEM "http://www.phylo.org/dev/rami/PARSER/pise.dtd">
<pise>
	<head>
		<title>MrBayes on Abe</title>
		<version>3.1.2</version>
		<description>Tree Inference Using Bayesian Analysis - run on teragrid</description>
		<authors>John P. Huelsenbeck and Fred Ronquist</authors>
		<reference>
			Huelsenbeck, J. P. and F. Ronquist. 2001. MRBAYES: Bayesian inference of phylogeny. Bioinformatics 17:754-755. 
		</reference>
		<reference>
			Ronquist, F. and J. P. Huelsenbeck. 2003. MRBAYES 3: Bayesian phylogenetic inference under mixed models. Bioinformatics 19:1572-1574. .
		</reference>
		<category>Phylogeny / Alignment</category>
	</head>
	<command>mrbayeshybrid_abe</command>
<!--
*****************************************************************************************************************************************
Created by Mark Miller for CIPRES2, 9_15_2008 or thereabouts, then passed to Terri Liebowitz, modified to run the hybrid version around 2/2/2010
*****************************************************************************************************************************************
Basic setup: invoke with mb command, then deliver the commands in groups.


This interface allows you to configure MrBayes from the command line, or from a MrBayes block in your data file. However, you must choose one or the other.
So, if you have a MrBayes Block in your data, you should configure the entire run in that block (see the MrBayes manual for help on how to do this).

MrBayes allows many parameters to be set on an unknown number of partitions in a data set.
MrBayes is loose about blank space in command line strings; parameter=<value> and parameter = <value> are the same.
MrBayes is loose about case as well, Parameter=<Value> is the same as parameter=<value>
Partitions, Taxa, and Charsets can generally be identified as parameters by name or number.

Accordingly, I have generally chosen to allow strings to be delivered with the minimal number of ctrls, because MrBayes is very loose in how the command line input is structured.
This poses a risk, but the risk is necessary to capture the flexibility of the program. In the end, I would advise anyone who is serious about this program to use the MrBayes block in their Nexus file..

There are 3 major command sets. These are lset (likelihood model), prset (probabilities), and mcmc (a command bloc that deploys the analysis). 
I have implemented all of the basic commands I intend to support, and created a command document based on the original MrBayes 3.1.2 document.
However, these must be packaged into a file for delivery to the tool. This is not accomplished yet.

The program fails with weak error messages at times because some of the preconds for use of a parameter have not been met.
When this happens, one receives the cryptic, and unhelpful message that the input parameter string is incorrect.
Possible messages are "expecting a number but found )", or "expecting a number but found ,"
in other words, the common denominator to this issue is an apparent malformation of the number input string. This is never actually the problem. 

Specific things that I have not yet implemented are:

1) how the commands are assembled into a single file

2) how to prepend the lset, prset, and mcmc string to a set of commands.
(for example, the preset is a super command; you can enter preset param1 = <input1> param2 = <input2>

3) how to manage the applyto option for lset and prset blocks. applyto allows you to set all of the parameters offered to a specific data partitioning schema.
the applyto command is the first in an lset string. usage is lset applyto(partition1, partition3)  <followed by lset commands>, then lset applyto(partition2)  <followed by more lset commands>.
If this command is implemented the way I imagine it, one must repeat all the input parameters, with a precond that applyto is used. 
according to user feedback, mrbayes is not very useful without this capability. Applyto is also relevant for the "report" command, and can be implemented precond on how many partitions are specified by the user. 
 
I created this interface initially with up to 8 character sets, and 4 partitions allowed, and then planned to adapt from there. The idea is that the user declares how many partitions, and we 
make the entry forms appear conditionally up to a final tally of 4. If we have to make more than this, I will need to adjust accordingly.

Here is the basic group structure today, based on what I thought might be useful.:
Group0 delivers the iniitating string; command line by definition
Grouping beyond that is a little arbitrary, but sump and sumt commands must come after mcmc
Group 2 will be the input data.
Groups 3, 4 set simple commands.
Group 5 will be the Lset Likelihood Model Params
Group 10 will be the Prset Priors modifiers 
Group 20 will be data modifications
Group 30 will be Charset commands
Group 40  will be Tree options
Group 45 will be output/report options
Group 50 will  be mcmc Parameters
Group 60 will be sump options
Group 70 will be sumt options
Group 99 is the quit command recommended by MrBayes developers.

We do not support the following options, because they (and any complex MrBayes runs) are much better handled in the MrBayes block of your data file, are more useful for interactive running, or are not appropriate for batch runs: Ctype, Link, Unlink, Delete, Include, Restore, Props, Plot, and Comparetree; the lset Ploidy option does not seem to be working in MrBayes 3.1.2; the prset option Aarevmatpropts is not supported. also any parameters requiring printing to the screen are not supported for obvious reaosns. Importantly, unlike the command line version, it is not possible to upload a MrBayes block file that calls a separate data file with your matrix. If this is a problem for you, please do contact me and tell me your needs (http://www.ngbw.org/ngbug.

Moreover, each of the major command sets

*****************************************************************************************************************************************
-->

<!--**************************************************************************************************
The UNIX version of MrBayes can be run in batch mode using input redirection. 
For that you need a text file containing the commands exactly as you would have typed them from the command line. 
For instance, assume that your data set is in primates.nex.
Then type mb < batch.txt > log.txt & with the batch.txt file containing this text: 

set autoclose=yes nowarn=yes
execute primates.nex
lset nst=6 rates=gamma
mcmc ngen=10000 savebrlens=yes file=primates.nex1
mcmc file=primates.nex2
mcmc file=primates.nex3
quit

The quit command forces MrBayes to terminate. With previous versions of MrBayes we have had problems with infinite loops when the quit command is not included at the end of the file. This problem has been solved in version 3.1, however we advise you to still use the quit command. 
-->
<!--This interface is a modification of mrbayes.xml, and was created by Terri around 10/2009 to permit submission to TG 
	The main changes are the addition of input for nruns and nchains, which the user provides so the job can be scheduled intelligently,
	and the aggregation of data for submission to the MrBayes wrapper terri created.
	
	Because of the constraints and limitations of Globus, we can no longer have the redirect to log.txt, so this file is no longer returned. 
	Instaed we capture STDOUT, the file is the same, it is just messier.  -->
<!--
	mrbayes expects that cmd lines delivered on stdin don't end with a semicolon, but those delivered in a parameter file (specified
	on the command line) do end with semicolons.  For consistency with the parent mrbayes.xml interface, our lines don't end with semicolons so 
	the file must be delivered on stdin.  Although the command line we generate below looks like "mbwrapper paramfile.txt",
	the wrapper actually runs something like "mb-mpi < paramfile.txt".
-->
<parameters>
		
<!-- the next two deliver the command line, based on Wayne Pfeiffer's recommendations regarding the number of MPI processes, 
OpenMP threads, and nodes when running the hybrid version of MrBayes 3.1.2 on Abe.

In all cases, the number of MPI processes is nruns * nchains.

The number of OpenMP threads is
   4 if the data set is partitioned ("is_partitioned") or nchar < 2,000 when running on Abe or QB,
   8 if the data set is not partitioned (!$is_partitioned) & nchar >= 2,000 when running on Abe or QB.

The number of nodes is then MPI processes * OpenMP threads / cores-per-node, where cores-per-node is 8 for Abe.

All runs will use the hybrid MPI/OpenMP executable.-->

<!--   2 pthreads if the data set is partitioned ("is_partitioned") or nchar < 2,000 when running on Abe or QB; nchar_specified -->
<!--   but if the partition has something other than protein or dna as a datatype, we go to the non-hybrid mrbayes  -->
					<parameter ismandatory="1" ishidden="1" type="String">
						<name>mbh_pthreads</name>
						<attributes>
							<format>
								<language>perl</language>
<!-- this should call 2 pthreads. "-T2" must be at end of commandline. $ 
	***modified according to wp suggestions to -T2, 2/23/2010 *** -->	
								<code>"<![CDATA[mbhwrapper paramfile.txt -T 2]]>"</code>
							</format>
							<precond>
								<language>perl</language>
								<code>!$is_partitioned_notproteindna &amp;&amp; ($is_partitioned || $nchar_specified &lt; 2000)</code>
							</precond>
							<group>0</group>
						</attributes>
					</parameter>
					
					<parameter ismandatory="1" ishidden="1" type="String">
						<name>mb_mpi</name>
						<attributes>
							<format>
								<language>perl</language>
								<code>"<![CDATA[mbwrapper paramfile.txt ]]>"</code>
							</format>
							<precond>
								<language>perl</language>
								<code>$is_partitioned_notproteindna</code>
							</precond>
							<group>0</group>
						</attributes>
					</parameter>
		
<!-- 4 pthreads if the data set is not partitioned (!$is_partitioned) & nchar >= 2,000 when running on Abe or QB. -->
					<parameter ismandatory="1" ishidden="1" type="String">
						<name>mbh_pthreads2</name>
						<attributes>
							<format>
								<language>perl</language>
<!-- this should call 4 pthreads *** modified according to wp suggestions to -T4, 2/23/2010 ***-->	
								<code>"<![CDATA[mbhwrapper paramfile.txt -T 4]]>"</code>
							</format>
							<precond>
								<language>perl</language>
								<code>!$is_partitioned &amp;&amp; $nchar_specified &gt;= 2000</code>
							</precond>
							<group>0</group>
						</attributes>
					</parameter>
					
<!-- this section defines a file scheduler.conf that accompanies the command line to the TG resource. It instructs the machine how to run the job. 
Unlike the raxml interface, the individual lines of the file are broken up. This is ncessary because of the $mrbayesblockquery element,
which affects individual lines in this file --> 		

<!-- this one sets the mpi process value if there is a mrbayes block -->
		<parameter type="Integer" ishidden="1" >
					<name>mpi_processes</name>
					<attributes>
						<group>3</group>
						<precond>
							<language>perl</language>
							<code>$mrbayesblockquery</code>
						</precond>
						<paramfile>scheduler.conf</paramfile>
						<format>
							<language>perl</language>
							<code>"mpi_processes=" .  $nchains_specified * $nruns_specified  . "\\n"</code>
						</format>
					</attributes>
				</parameter>

<!-- this one sets the mpi process value if the interface is used  -->
				<parameter type="Integer" ishidden="1" >
					<name>mpi_processes2</name>
					<attributes>
						<precond>
							<language>perl</language>
							<code>!$mrbayesblockquery</code>
						</precond>
						<paramfile>scheduler.conf</paramfile>
						<format>
							<language>perl</language>
							<code>"mpi_processes=" .  $nchainsval * $nrunsval  . "\\n"</code>
						</format>
						<group>3</group>
					</attributes>
				</parameter>

<!-- 2 pthreads if the data set is partitioned ("is_partitioned") or nchar < 2,000 when running on Abe or QB; nchar_specified -->
					<parameter ishidden="1" type="String">
						<name>mbh_pthreads_conf</name>
						<attributes>
							<precond>
								<language>perl</language>
<!--added the condition that the partitioned data set has only protein and dna -->
								<code>!$is_partitioned_notproteindna &amp;&amp; ($is_partitioned || $nchar_specified &lt; 2000)</code>
							</precond>
							<paramfile>scheduler.conf</paramfile>
							<format>
								<language>perl</language>	
								<code>	"jobtype=mpi\\n" .
										"threads_per_process=2\\n"
								</code>
							</format>
							<group>4</group>
						</attributes>
					</parameter>
					
<!-- if the partition has non dna/nonprotein data, this will specify jobtype=mpi  -->
					<parameter ishidden="1" type="String">
						<name>mb_mpi_conf</name>
						<attributes>
							<precond>
								<language>perl</language>
<!--added the condition that the partitioned data set has only protein and dna -->
								<code>$is_partitioned_notproteindna</code>
							</precond>
							<paramfile>scheduler.conf</paramfile>
							<format>
								<language>perl</language>	
								<code>	"jobtype=mpi\\n"
								</code>
							</format>
							<group>4</group>
						</attributes>
					</parameter>

<!--  4 if the data set is not partitioned (!$is_partitioned) & nchar >= 2,000 when running on Abe or QB. -->
					<parameter ishidden="1" type="String">
						<name>mbh_pthreads2_conf</name>
						<attributes>
							<precond>
								<language>perl</language>
								<code>!$is_partitioned &amp;&amp; $nchar_specified &gt;= 2000</code>
							</precond>
							<paramfile>scheduler.conf</paramfile>
							<format>
								<language>perl</language>
								<code>	"jobtype=mpi\\n" .
										"threads_per_process=4\\n"
								</code>
							</format>
							<group>4</group>
						</attributes>
					</parameter>

<!--  There are two conditions, with and without mrbayes block (affects the nruns and nchains variable name), 
and two options for each, partititioned or less than 2000 char, or not partitioned and more than 2000 char. 
Accordingly there are 4 separate elements-->

<!-- start with mrbayes block -->												
				<parameter type="String" ishidden="1" >
					<name>number_nodes</name>
					<attributes>
						<group>2</group>
						<paramfile>scheduler.conf</paramfile>
						<format>
							<language>perl</language>
<!--here there are 4 pthreads, and 8 cores per node (abe), so the multiplier is 0.5 -->
<!--note the variable for nchains and nruns depends on whether mrbaysblockquery is 0 or 1 -->
<!-- this section was revised 3/2/2010 such that nodes = MPI processes * OpenMP threads / 8
        = nruns * nchains * OpenMP threads /8 In this case pthreads=2, so the multiplier is 0.25.-->
							<code>"nodes=" .  ($nchains_specified * $nruns_specified)*0.25  . "\\n"</code>
						</format>
						<precond>
							<language>perl</language>
<!-- added the condition that the parttioned data is only protein or dna -->
							<code>!$is_partitioned_notproteindna &amp;&amp; ($is_partitioned || $nchar_specified &lt; 2000) &amp;&amp; $mrbayesblockquery</code>
						</precond>
					</attributes>
				</parameter>

<!--this sets the nodes= value for partitioned data that is not dna or protein -->				
				<parameter type="String" ishidden="1" >
					<name>number_nodes1b</name>
					<attributes>
						<group>2</group>
						<paramfile>scheduler.conf</paramfile>
						<format>
							<language>perl</language>
<!--note the variable for nchains and nruns depends on whether mrbaysblockquery is 0 or 1 -->
<!-- this section was revised 3/2/2010 such that nodes = MPI processes * OpenMP threads / 8
        = nruns * nchains  /8 -->
							<code>"nodes=" .  ($nchains_specified * $nruns_specified)*0.125  . "\\n"</code>
						</format>
						<precond>
							<language>perl</language>
<!-- added the condition that the parttioned data is only protein or dna -->
							<code>$is_partitioned_notproteindna &amp;&amp; $mrbayesblockquery</code>
						</precond>
					</attributes>
				</parameter>
	
<!-- this section was revised 3/2/2010 such that nodes = MPI processes * OpenMP threads / 8
        = nruns * nchains * OpenMP threads /8 In this case pthreads=4, so the multiplier is 0.5-->				
				<parameter type="String" ishidden="1" >
					<name>number_nodes2</name>
					<attributes>
						<group>2</group>
						<paramfile>scheduler.conf</paramfile>
						<format>
							<language>perl</language>
							<!--note the variable for nchains and nruns depends on whether mrbaysblockquery is 0 or 1 -->
							<!--here there are 4 pthreads, and 8 cores per node (abe), so the multiplier is 0.5 -->
							<code>"nodes=" .  ($nchains_specified * $nruns_specified)*0.5  . "\\n"</code>
						</format>
						<precond>
							<language>perl</language>
							<code>(!$is_partitioned &amp;&amp; $nchar_specified &gt;= 2000) &amp;&amp; $mrbayesblockquery</code>
						</precond>
					</attributes>
				</parameter>
				
<!-- start number of nodes with no mrbayes block -->	
<!-- this section was revised 3/2/2010 such that nodes = MPI processes * OpenMP threads / 8
        = nruns * nchains * OpenMP threads /8 In this case pthreads=2, so the multiplier is 0.25.-->											
				<parameter type="String" ishidden="1" >
					<name>number_nodes3</name>
					<attributes>
						<group>2</group>
						<paramfile>scheduler.conf</paramfile>
						<format>
							<language>perl</language>
							<!--here there are 2 pthreads, and 8 cores per node (abe), so the multiplier is 0.25 -->
							<code>"nodes=" .  ($nchainsval  * $nrunsval)*0.25  . "\\n"</code>
						</format>
						<precond>
							<language>perl</language>
<!-- added the condition that partitioned data does not have dna or protein -->							
							<code>!$is_partitioned_notproteindna &amp;&amp; ($is_partitioned || $nchar_specified &lt; 2000) &amp;&amp; !$mrbayesblockquery</code>
						</precond>
					</attributes>
				</parameter>
				
<!-- this section was added for the case where the dataset has a partition with non protein/non dna data
        = nruns * nchains  /8 so the multiplier is 0.125.-->											
				<parameter type="String" ishidden="1" >
					<name>number_nodes3b</name>
					<attributes>
						<group>2</group>
						<paramfile>scheduler.conf</paramfile>
						<format>
							<language>perl</language>
							<!--here there are 8 cores per node (abe), so the multiplier is 0.125 -->
							<code>"nodes=" .  ($nchainsval  * $nrunsval)*0.125  . "\\n"</code>
						</format>
						<precond>
							<language>perl</language>
<!-- added the condition that partitioned data does not have dna or protein -->							
							<code>$is_partitioned_notproteindna &amp;&amp; !$mrbayesblockquery</code>
						</precond>
					</attributes>
				</parameter>
				
				<parameter type="String" ishidden="1" >
					<name>number_nodes4</name>
					<attributes>
						<group>2</group>
						<paramfile>scheduler.conf</paramfile>
						<format>
							<language>perl</language>
							<!--here there are 4 pthreads, and 8 cores per node (abe), so the multiplier is 0.5 -->
							<code>"nodes=" .  ($nchainsval * $nrunsval)*0.5  . "\\n"</code>
						</format>
						<precond>
							<language>perl</language>
							<code>(!$is_partitioned &amp;&amp; $nchar_specified &gt;= 2000) &amp;&amp; !$mrbayesblockquery</code>
						</precond>
					</attributes>
				</parameter>
<!-- end number of nodes with no mrbayes block -->		
<!--here we define and output the big parameters file (parameters.txt) that will deliver the command line instructions-->

		<parameter type="Results">
			<name>paramfile</name>
			<attributes>
				<precond>
					<language>perl</language>
					<code>!$mrbayesblockquery</code>
				</precond>
				<prompt>Input parameters</prompt>
				<filenames>paramfile.txt</filenames>
			</attributes>
		</parameter>
		
<!-- This begins the parameter settings, all are compiled into a big file for delivery in batch mode -->	

		<parameter ismandatory="1" isinput="1" type="Sequence">
			<name>infile</name>
			<attributes>
				<prompt>Input File (must be in Nexus format) (-execute)</prompt>
				<paramfile>paramfile.txt</paramfile>
				<format>
					<language>perl</language>
					<code>"execute infile.nex\\n"</code>
<!-- Changed for Swami 
						<code>  " -infile=$value"</code> 
						<language>seqlab</language>
						<code>  " -infile=value"</code                       
						Changed for Swami -->
				</format>
				<group>2</group>
<!-- Added for Swami to specify the input name -->
				<filenames>infile.nex</filenames>
			</attributes>
		</parameter>	
		
<!-- First, set the autoclose feature:set autoclose=<yes/no>  If autoclose is set to yes, then the program will not prompt you during the course of executing a file. -->

		<parameter issimple="1" ismandatory="1" ishidden="1" type="String">
			<name>setopts</name>
			<attributes>
				<prompt></prompt>
				<paramfile>paramfile.txt</paramfile>
				<format>
					<language>perl</language>
					<code>"set autoclose=yes\\n"</code>
				</format>
				<group>1</group>
			</attributes>
		</parameter>

<!-- Next, set the nowarn option. the program will issue a prompt when overwriting an output file that is already present -->

		<parameter issimple="1" ismandatory="1" ishidden="1" type="String">
			<name>setwarnopts</name>
			<attributes>
				<paramfile>paramfile.txt</paramfile>
				<prompt></prompt>
				<format>
					<language>perl</language>
					<code>"set nowarnings=yes\\n"</code>
				</format>
				<group>1</group>
			</attributes>
		</parameter>
				
<!--Fourth, set the quitonerror feature to yes so the program will quit when an error is encountered, after printing an error message. If quitonerror=no (the default setting) then the program will wait for additional commands from the command line after printing the error message. -->
<!--  this parameter is broken in mrbayes 3.1.2
		<parameter issimple="1" ismandatory="1" ishidden="1" type="String">
			<name>setquitopts</name>
			<attributes>
				<paramfile>paramfile.txt</paramfile>
				<prompt></prompt>
				<format>
					<language>perl</language>
					<code>"set quitonerror=yes\\n"</code>
				</format>
				<group>1</group>
			</attributes>
		</parameter> -->
		
		<parameter type="Results">
			<name>ALL_FILES</name>
			<attributes>
				<precond>
					<language>perl</language>
					<code>$mrbayesblockquery</code>
				</precond>
				<filenames>*</filenames>
			</attributes>
		</parameter> 

<!--    This is the results section, now refined                 -->

<!--    all runs produce this file                -->
<!-- this file is not produced on globus run tools
		<parameter ishidden="1" type="Results">
			<name>log_file</name>
			<attributes>
				<precond>
					<language>perl</language>
					<code>!$mrbayesblockquery</code>
				</precond>
				<filenames>log.txt</filenames>
			</attributes>
		</parameter> -->
<!--    all runs produce this file                -->		
		<parameter ishidden="1" type="Results">
			<name>commandline</name>
			<attributes>
				<precond>
					<language>perl</language>
					<code>!$mrbayesblockquery</code>
				</precond>
				<filenames>COMMANDLINE</filenames>
			</attributes>
		</parameter>	
		
<!--    all runs produce this file                -->	
            	
		<parameter ishidden="1" type="Results">
			<name>startinfo_file</name>
			<attributes>
				<precond>
					<language>perl</language>
					<code>!$mrbayesblockquery</code>
				</precond>
				<filenames>start.txt</filenames>
			</attributes>
		</parameter>  

<!--  all runs produce this file  -->             
		<parameter ishidden="1" type="Results">
			<name>stopinfo_file</name>
			<attributes>
				<precond>
					<language>perl</language>
					<code>!$mrbayesblockquery</code>
				</precond>
				<filenames>done.txt</filenames>
			</attributes>
		</parameter>

<!--    all runs produce this file                -->	
		<parameter ishidden="1" type="Results">
			<name>schedulerinfo_file</name>
			<attributes>
				<precond>
					<language>perl</language>
					<code>!$mrbayesblockquery</code>
				</precond>
				<filenames>scheduler.conf</filenames>
			</attributes>
		</parameter>
	
<!--    all runs produce this file                -->		
		<parameter ishidden="1" type="Results">
			<name>screen_dump</name>
			<attributes>
				<precond>
					<language>perl</language>
					<code>!$mrbayesblockquery</code>
				</precond>
				<filenames>mrbayeslog.out</filenames>
			</attributes>
		</parameter>	
		
<!--    all runs produce this file                -->		
		<parameter ishidden="1" type="Results">
			<name>sump_output</name>
			<attributes>
				<precond>
					<language>perl</language>
					<code>!$mrbayesblockquery</code>
				</precond>
				<filenames>*.p</filenames>
			</attributes>
		</parameter>
		
<!--    not all runs produce this file; precond for sumpnruns > 0        -->		
		<parameter ishidden="1" type="Results">
			<name>sump_output2</name>
			<attributes>
				<precond>
					<language>perl</language>
					<code>$sumpnruns &gt; 0</code>
				</precond>
				<filenames>sumpoutput.out</filenames>
			</attributes>
		</parameter>
		
		<parameter ishidden="1" type="Results">
			<name>sumt_output</name>
			<attributes>
				<precond>
					<language>perl</language>
					<code>!$mrbayesblockquery</code>
				</precond>
				<filenames>*.t</filenames>
			</attributes>
		</parameter>
		
		<parameter ishidden="1" type="Results">
			<name>all_mcmc_trees</name>
			<attributes>
				<precond>
					<language>perl</language>
					<code>!$mrbayesblockquery</code>
				</precond>
				<filenames>*.trprobs</filenames>
			</attributes>
		</parameter>
		
		<parameter ishidden="1" type="Results">
			<name>partition_information</name>
			<attributes>
				<precond>
					<language>perl</language>
					<code>!$mrbayesblockquery</code>
				</precond>
				<filenames>*.parts</filenames>
			</attributes>
		</parameter>
		
		<parameter ishidden="1" type="Results">
			<name>consensus_tree</name>
			<attributes>
				<precond>
					<language>perl</language>
					<code>!$mrbayesblockquery</code>
				</precond>
				<filenames>*.con</filenames>
			</attributes>
		</parameter>
		
		<parameter ishidden="1" type="Results">
			<name>acceptance_ratios</name>
			<attributes>
				<precond>
					<language>perl</language>
					<code>!$mrbayesblockquery</code>
				</precond>
				<filenames>*.mcmc</filenames>
			</attributes>
		</parameter>
		
<!--    The quit command forces MrBayes to terminate. With previous versions of MrBayes there were problems with infinite loops when the quit command was not included at the end of the file. This problem has been solved in version 3.1, however we advise you to still use the quit command.  (???)  -->
		<parameter ishidden="1" type="String">
			<name>mrbayes_closeout</name>
			<attributes>
				<format>
					<language>perl</language>
					<code>"quit\\n"</code>
				</format>
				<paramfile>paramfile.txt</paramfile>
				<group>99</group>
			</attributes>
		</parameter>
		
	<!-- This section provides visible queries that help configure the interface  -->
	<!-- turn off all interfaceoptions when a MrBayes block is present -->
				<parameter issimple="1" ismandatory="1" type="Switch">
					<name>mrbayesblockquery</name>
					<attributes>
						<group>1</group>
						<prompt>My Data Contains a MrBayes Data Block (CHECK THIS OR MrBayes BLOCK ENTRIES WILL BE OVERWRITTEN!!!)</prompt>
						<format>
							<language>perl</language>
							<code>($value)? "":""</code>
						</format>	
						<vdef>
							<value>0</value>
						</vdef>
						<comment>
							<value>This interface allows you to configure MrBayes from the command line, or from a MrBayes block in your data file. 
							However, you must choose one or the other.  So, if you have a MrBayes Block in your data, you should configure the entire 
							run in that block (see the MrBayes manual for help on how to do this). It is our belief that MrBayes is sufficiently complex
							in its command structure and use that if you want to analyse multiple partitions and multiple datatypes you should do it in 
							the Nexus file structure. The current interface supports multiple data partitions ONLY in the Nexus file. If you need more 
							options than we provide, please let us know: http://www.ngbw.org/ngbugz. Other options are not included in this interface 
							because they (and any complex MrBayes runs) are much better handled in the MrBayes block of your data file, are more useful 
							for interactive running, or are not appropriate for batch runs. These include: Ctype, Link, Unlink, Delete, Include, 
							Restore, Props, Plot, and Comparetree, the prset option Aarevmatpropts is not supported; the lset Ploidy option does not 
							seem to be working in MrBayes 3.1.2. Any parameters requiring printing to the screen are not supported for obvious reasons. 
							Importantly, unlike the command line version, it is not possible to upload a MrBayes block file that calls a separate data 
							file with your matrix.
							</value>
						</comment>
					</attributes>
				</parameter>
		
				<parameter issimple="1" ismandatory="1" type="Switch">
					<name>set_autoclose_confirm</name>
					<attributes>
						<group>1</group>
						<prompt>I confirm that there is not an "autoclose = no" statement in my MrBayes block</prompt>
						<precond>
							<language>perl</language>
							<code>$mrbayesblockquery</code>
						</precond>
						<format>
							<language>perl</language>
							<code>($value)? "":""</code>
						</format>
						<ctrls>
							<ctrl>
								<message>Please acknowledge that there is not a "set autoclose = no" statement in the MrBayes block of your Nexus file</message>
								<language>perl</language>
								<code>$mrbayesblockquery &amp;&amp; !$set_autoclose_confirm</code>
							</ctrl>
						</ctrls>	
						<vdef>
							<value>0</value>
						</vdef>
						<comment>
							<value>Putting an "autoclose = no" statement in your MrBayes block will cause catastorphic failure of the job, and may impact others. Please be careful. 
							</value>
						</comment>
					</attributes>
				</parameter>

				<parameter type="Integer" issimple="1" >
					<name>nruns_specified</name>
					<attributes>
						<group>1</group>
						<prompt>My MrBayes Block specifies nruns=</prompt>
						<precond>
							<language>perl</language>
							<code>$mrbayesblockquery</code>
						</precond>
						<paramfile>scheduler.conf</paramfile>
						<vdef>
							<value>2</value>
						</vdef>
						<comment>
							<value>The values entered for nruns and nchains influence the number of cpu's that can be used in parallel.  Please enter the value you specified for 
							nruns in the MrBayes block of the Nexus file.  If you didn't specify a value for nruns, please leave this field at its default value of 2.
							</value>
						</comment>
						<ctrls>
							<ctrl>
								<message>The value for nruns must be either 2 or 4</message>
								<language>perl</language>
								<code>$nruns_specified ne 2 &amp;&amp; $nruns_specified ne 4</code>
							</ctrl>
							<ctrl>
								<message>nruns x nchains must be a multiple of 4 and must be &lt;= 16.</message>
								<language>perl</language>
								<code>((($nruns_specified * $nchains_specified) % 4) != 0) || ($nruns_specified * $nchains_specified &gt; 17) </code>
							</ctrl>
						</ctrls>
					</attributes>
				</parameter>
<!-- Obtain the number of runs (nruns), chains (nchains), and characters
(nchar) from the input data, or ask the user to input those separately. Check that nruns * nchains is a multiple of

   4 on Abe and Queen Bee.

If not, ask the user to change parameters to ensure that.  If this test makes the interface overly complicated, just check that nruns * nchains 
is a multiple of 4 regardless of computer. -->

				<parameter type="Integer" issimple="1" >
					<name>nchains_specified</name>
					<attributes>
						<group>1</group>
						<prompt>My MrBayes Block specifies nchains=</prompt>
						<precond>
							<language>perl</language>
							<code>$mrbayesblockquery</code>
						</precond>
						<paramfile>scheduler.conf</paramfile>
						<vdef>
							<value>4</value>
						</vdef>
						<comment>
							<value>The value entered for nruns and nchains influences the number of cpu's that can be used in parallel.  Enter the value you specified 
							for nchains in the MrBayes block of the nexus file.  If you didn't specify a value for nchains, please leave this field at its default value of 4.
							</value>
						</comment>
						<ctrls>
							<ctrl>
								<message>The value for nchains must be 1 or greater. The recommended value is at least 4.</message>
								<language>perl</language>
								<code>$nchains_specified &lt; 1</code>
							</ctrl>
							<ctrl>
								<message>nruns x nchains must be a multiple of 4 and must be &lt;= 16.</message>
								<language>perl</language>
								<code>((($nruns_specified * $nchains_specified) % 4) != 0) || ($nruns_specified * $nchains_specified &gt; 17) </code>
							</ctrl>
						</ctrls>
					</attributes>
				</parameter>

<!--how many chars in the matrix? -->
				<parameter type="Integer" issimple="1" >
					<name>nchar_specified</name>
					<attributes>
						<group>1</group>
						<prompt>How many characters in your matrix</prompt>
						<comment>
							<value>The size of the matrix influences how the job is run. Please enter the number of characters in a row of your uploaded matrix.
							</value>
						</comment>
						<ctrls>
							<ctrl>
								<message>The number of characters in the matrix must 1 or greater.</message>
								<language>perl</language>
								<code>$nchar_specified &lt; 1</code>
							</ctrl>
						</ctrls>
					</attributes>
				</parameter>

<!-- Determine whether the data set is partitioned, either from the input data or via separate query. -->
				<parameter issimple="1" ismandatory="1" type="Switch">
					<name>is_partitioned</name>
					<attributes>
						<group>0</group>
						<prompt>My data set has a partition</prompt>
						<precond>
							<language>perl</language>
							<code>$mrbayesblockquery</code>
						</precond>
						<format>
							<language>perl</language>
							<code>($value)? "":""</code>
						</format>
						<vdef>
							<value>0</value>
						</vdef>
						<comment>
							<value>This option will help the application determine how to run the job</value>
						</comment>
					</attributes>
				</parameter>
				
<!-- this was added by mamiller, so a user can specify they are using a mixed model that does not use only protein or dna -->
				<parameter issimple="1" ismandatory="1" type="Switch">
					<name>is_partitioned_notproteindna</name>
					<attributes>
						<group>0</group>
						<prompt>My partition uses mixed datatypes other than protein or dna</prompt>
						<precond>
							<language>perl</language>
							<code>$is_partitioned</code>
						</precond>
<!--						<format>
							<language>perl</language>
							<code>($value)? "":""</code>
						</format> -->
						<vdef>
							<value>0</value>
						</vdef>
						<comment>
							<value>This option will help the application determine how to run the job</value>
						</comment>
					</attributes>
				</parameter>
				
<!-- this sets the run time -->
				<parameter type="Float" issimple="1" ismandatory="1">
					<name>runtime</name> 
					<attributes>
						<group>1</group>
						<paramfile>scheduler.conf</paramfile>
						<prompt>Maximum Hours to Run (click here for help setting this correctly)</prompt>
						<vdef><value>0.5</value></vdef>
						<comment>
<value>Estimate the maximum time your job will need to run (between 1 - 168hrs, or &lt; 0.5hr for a test run). Your job will be killed if it doesn't finish within
the time you specify, however jobs with shorter maximum run times often run sooner than longer jobs. 
</value>
						</comment>
						<ctrls>
							<ctrl>
								<message>The maximum hours to run must be less than 168</message>
								<language>perl</language>
								<code>$runtime &gt; 168.0</code>
							</ctrl>
						</ctrls>
						<format>
							<language>perl</language>
							<code>"runhours=$value\\n"</code>
						</format>	
					</attributes>
				</parameter>

<!-- let the user specifiy data to control options; this doesn't do anything yet, because I was having trouble with preconds as it is.
	however, it should make it easier to configure the run form the interface by greying out irrelevant options -->		
<!--				<parameter issimple="1" ismandatory="1" type="Excl">
			<name>flagdatatype</name>
			<attributes>
				<prompt>My Data Type Is (only one data type through the web form, see help below)</prompt>
				<precond>
						<language>perl</language>
						<code>!$mrbayesblockquery</code>
				</precond>
				<format>
					<language>perl</language>
					<code>($value)? "" : ""</code>
				</format>
				<vdef>
					<value>dna</value>
					</vdef>	
				<vlist>
					<value>dna</value>
					<label>nucleic acid</label>
					<value>protein</value>
					<label>protein</label>
					<value>standard</value>
					<label>standard</label>
					<value>other</value>
					<label>other</label>
				</vlist>
				<comment>
<value>Setting this flag helps us eliminate uneeded options</value>
				</comment>
			</attributes>
		</parameter> -->
		
<!--format log start/stop filename=<name> append/replace specfiy the name of the output file, Start/Stop logging of output to a file. Use Append/Replace to append or replace existing file. 
Set to append here out of uncertainty, we want to capture everything at first.-->
		<parameter issimple="1" ishidden="1" type="Results">
			<name>logfileon</name>
			<attributes>
				<paramfile>paramfile.txt</paramfile>
				<format>
					<language>perl</language>
					<code> "log start filename=mrbayeslog.out append\\n" </code>
				</format>
				<group>4</group>
			</attributes>
		</parameter>
<parameter type="Paragraph">
	<paragraph>
		<name>treeopts</name>
		<prompt>Tree Options</prompt>
			<parameters>
			<parameter type="Switch">
				<name>usertreesel</name>
				<attributes>
					<prompt>Provide a User Tree? (must be binary, and in Newick format)</prompt>
					<precond>
						<language>perl</language>
						<code>!$mrbayesblockquery</code>
					</precond>
					<vdef>
						<value>0</value>
					</vdef>
					<format>
						<language>perl</language>
						<code>($value)? "":""</code>
					</format>
					<group>40</group>
					<comment>
<value>Usertree allows you to provide a user tree for use as a starting tree for a MCMC analysis. For example,                                                                   
usertree = (A,B,(C,D)) specifies an unrooted tree of four species. Note that the program requires that trees are binary (i.e., strictly bifurcating). Hence, there can be only one three-way split, as shown in the example. If the tree is not binary, the program will return an error.                               
</value>
					</comment>
				</attributes>
				</parameter>
						
			<parameter type="InFile">
				<name>Usertreeopt</name>
				<attributes>
					<precond>
						<language>perl</language>
						<code>!$mrbayesblockquery &amp;&amp; $usertreesel </code>
					</precond>
					<filenames>usertree.dnd</filenames>
					<paramfile >paramfile.txt</paramfile>					
					<format>
						<language>perl</language>
						<code>"usertree=usertee.dnd\\n"</code>
					</format>
					<group>40</group>
				</attributes>
			</parameter>  
			
			<parameter type="Switch">
				<name>deroottreeopt</name>
					<attributes>
						<prompt>Deroot the User Tree</prompt>
						<precond>
							<language>perl</language>
							<code>!$mrbayesblockquery &amp;&amp; !$roottreeopts</code>
						</precond>
						<paramfile>paramfile.txt</paramfile>
						<format>
							<language>perl</language>
							<code>($value)?"deroot\\n":""</code>
						</format>
						<group>40</group>
						<comment>
<value>Deroots the user tree. If the tree is already unrooted, no change will occur.</value>
						</comment>
					</attributes>
			</parameter>
	
			<parameter  type="Switch">
				<name>roottreeopts</name>
					<attributes>
						<prompt>Root the Tree (Outgroup must be specified)</prompt>
						<precond>
							<language>perl</language>
							<code>!$mrbayesblockquery</code>
						</precond>
						<paramfile>paramfile.txt</paramfile>
				  		<precond>
							<language>perl</language>
							<code>defined $outgroupopts &amp;&amp; defined $Usertreeopt &amp;&amp; !$deroottreeopt</code>
						</precond>
						<format>
							<language>perl</language>
							<code>($value)?"root\\n":""</code>
						</format>
						<group>40</group>
						<comment>
<value>Roots the tree. If the tree is already rooted, a warning is issued. The tree is rooted at the outgroup species.                                                             
</value>
						</comment>
					</attributes>
			</parameter>
			
			<parameter type="String">
					<name>outgroupopts</name>
					<attributes>
						<prompt>Set the Outgroup (enter the name or number of the root taxon)</prompt>
						<paramfile>paramfile.txt</paramfile>
							<precond>
								<language>perl</language>
								<code>!$mrbayesblockquery</code>
							</precond>
						<format>
							<language>perl</language>
							<code>"outgroup $value\\n"</code>
						</format>
						<group>20</group>
						<comment>
<value>Outgroup assigns a taxon to the outgroup. For example, "outgroup 3" assigns the third taxon in the matrix to be the outgroup. Similarly, "outgroup Homo_sapiens" assings the taxon "Homo_sapiens" to be the outgroup (assuming that there is a taxon named "Homo_sapiens" in the matrix). Only a single taxon can be assigned to be the outgroup.
</value>
						</comment>
					</attributes>
			</parameter>				
				
			<parameter type="Switch">
				<name>applyconstraints</name>
				<attributes>
						<prompt>Apply constraints to the inferred tree?</prompt>
						<precond>
							<language>perl</language>
							<code>!$mrbayesblockquery</code>
						</precond>
						<vdef>
							<value>0</value>
						</vdef>
						<format>
							<language>perl</language>
							<code>($value) ? "":""</code>
						</format>
						<group>40</group>
						<comment>
<value>The constraint command defines a tree constraint. The constraint includes a constraint name, and a list of taxa over which that constraint can be applied (Command Line MrBayes requires a probablility value, but ignores it at present, effectively enforcing the constraint over all trees for both prior and posterior). The list of taxa can be specified taxon names, or taxon numbers, separated by commas (the taxset command is not supported here). If you are interested in inferring ancestral states for a particular node, constrain that node first using the 'constraint' command. For more information on how to infer ancestral states, see the help for the 'report' command. It is important to note that simply defining a constraint using this command is not sufficient for the program to actually implement the constraint in an analysis. You must also specify the constraints using 'prset topologypr = constraints (name of constraint)'. For more information, see the help on the 'prset' command.                                   
</value>
						</comment>
					</attributes>
				</parameter>
				
				<parameter type="Integer">
					<name>constraintoptions</name>
					<attributes>
						<prompt>How Many Constraints? (up to 4 may be defined)</prompt>
						<precond>
							<language>perl</language>
							<code>!$mrbayesblockquery &amp;&amp; $applyconstraints</code>
						</precond>
						<format>
							<language>perl</language>
							<code>""</code>
						</format>
						<group>40</group>
					</attributes>
				</parameter>
				
				<parameter type="String">
					<name>taxonidconstraint1</name>
					<attributes>
						<prompt>Enter taxa names or numbers for Constraint1, separated by spaces</prompt>
							<paramfile>paramfile.txt</paramfile>
						<precond>
							<language>perl</language>
							<code>!$mrbayesblockquery &amp;&amp; $constraintoptions &gt;= 1</code>
						</precond>
						<format>
							<language>perl</language>
							<code>"constraint constraint1 100 = $value\\n"</code>                                   
						</format>
						<group>40</group>
					</attributes>
				</parameter>
				
				<parameter type="String">
					<name>taxonidconstraint2</name>
					<attributes>
						<prompt>Enter taxa names or numbers for Constraint2, separated by spaces</prompt>
							<paramfile>paramfile.txt</paramfile>
							<precond>
								<language>perl</language>
								<code>!$mrbayesblockquery &amp;&amp; $constraintoptions &gt;= 2</code>
							</precond>
							<format>
								<language>perl</language>
								<code>"constraint constraint2 100 = $value\\n"</code>                                   
							</format>
							<group>40</group>
					</attributes>
				</parameter>
				
				<parameter type="String">
					<name>taxonidconstraint3</name>
					<attributes>
						<prompt>Enter taxa names or numbers for Constraint3, separated by spaces</prompt>
							<paramfile>paramfile.txt</paramfile>
							<precond>
								<language>perl</language>
								<code>!$mrbayesblockquery &amp;&amp; $constraintoptions &gt;= 3</code>
							</precond>
							<format>
								<language>perl</language>
								<code>"constraint constraint3 100 = $value\\n"</code>                                   
							</format>
							<group>40</group>
					</attributes>
				</parameter>
				
				<parameter type="String">
					<name>taxonidconstraint4</name>
					<attributes>
						<prompt>Enter taxa names or numbers for Constraint1, separated by spaces</prompt>
						<paramfile>paramfile.txt</paramfile>
						<precond>
							<language>perl</language>
							<code>!$mrbayesblockquery &amp;&amp; $constraintoptions &gt;= 4</code>
						</precond>
						<format>
							<language>perl</language>
							<code>"constraint constraint4 100 = $value\\n"</code>                                   
						</format>
						<group>40</group>
					</attributes>
				</parameter>
				
			</parameters>
	</paragraph>
</parameter>

<parameter type="Paragraph">
	<paragraph>
		<name>lsetopts</name>
		<prompt>Likelihood Model Parameters</prompt>
<!--*******************************************************************************************
All of the parameters in this section must be preceded by the string lset
***********************************************************************************************-->
<!--<precond>
						<language>perl</language>
						<code>!$mrbayesblockquery</code>
		</precond> -->
			<parameters>
			<!-- this section is for adding the applyto command, not quite ready for this yet.....-->
			<!--	<parameter ismandatory="1" type="Excl">
					<name>applylsetopts1</name>
					<attributes>
						<prompt>Apply these parameters to Entire Data Set, or Partition 1</prompt>
						<format>
							<language>perl</language>
							<code>"applyto=(1)\\n"</code>
						</format> 
						<group>5</group>
					</attributes>
				</parameter>     -->

				<parameter ismandatory="1" type="Excl">
					<name>nstopts</name>
					<attributes>
						<prompt>Set the number of substitution types (Nst=)</prompt>
						<precond>
							<language>perl</language>
							<code>!$mrbayesblockquery</code>
						</precond>
							<paramfile>paramfile.txt</paramfile>
							<format>
								<language>perl</language>
								<code>"lset Nst= $value\\n"</code>
							</format>  
						<vdef>
							<value>1</value>
						</vdef>
						<vlist>
							<value>1</value>
							<label>1</label>
							<value>2</value>
							<label>2</label>
							<value>6</value>
							<label>6</label>
						</vlist>
						<group>5</group>
						<comment>
<value>Sets the number of substitution types: "1" constrains all of the rates to be the same (e.g., a JC69 or F81 model); "2" allows transitions and transversions to have potentially different rates (e.g., a K80 or HKY85 model); "6" allows all rates to be different, subject to the constraint of time-reversibility (e.g., a GTR model).                                              
</value>
						</comment>
					</attributes>
				</parameter> 
				
				<parameter ismandatory="1" type="Excl">
					<name>nucmodelopts</name>
					<attributes>
						<prompt>Set the nucleotide substitution model (Nucmodel=)</prompt>
							<paramfile>paramfile.txt</paramfile>
							<precond>
								<language>perl</language>
								<code>!$mrbayesblockquery</code>
							</precond>
						<format>
							<language>perl</language>
							<code>"lset Nucmodel= $value\\n"</code>
						</format> 
						<vdef>
							<value>4by4</value>
						</vdef>
						<vlist>
							<value>4by4</value>
							<label>4 X 4</label>
							<value>doublet</value>
							<label>doublet</label>
							<value>codon</value>
							<label>codon</label>
						</vlist>
						<group>5</group>
						<comment>
<value>This parameter specifies the general form of the nucleotide substitution model. The options are "4by4" [the standard model of DNA substitution in which there are only four states (A,C,G,T/U)],   "doublet" (a model appropriate for modelling the stem regions of ribosomal genes where the state space is the 16 doublets of nucleotides), and "codon" (the substitution model is expanded around triplets of nucleotides--a codon).</value>
						</comment>
					</attributes>
				</parameter>
				
				<parameter ismandatory="1" type="Excl">
					<name>codonopts</name>
					<attributes>
						<prompt>Set the Codon translation table (Codon=)</prompt>
							<paramfile>paramfile.txt</paramfile>
						<format>
							<language>perl</language>
							<code>"lset Code= $value\\n"</code>
						</format>
						<precond>
							<language>perl</language>
							<code>$nucmodelopts eq "codon" &amp;&amp; !$mrbayesblockquery</code>
							</precond>  
						<vdef>
							<value>Universal</value>
						</vdef>
						<vlist>
							<value>Universal</value>
							<label>Universal</label>
							<value>Vertmt</value>
							<label>Vertebrate Mitochondria</label>
							<value>Mycoplasma</value>
							<label>Mycoplasma</label>
							<value>Ciliates</value>
							<label>Ciliates</label>
							<value>Metmt</value>
							<label>Non-vertebrate Metazoan Mitochondria</label>
							<value>Yeast</value>
							<label>Yeast</label>
						</vlist>
						<group>5</group>
					</attributes>
				</parameter>
				
				<parameter ismandatory="1" type="Excl">
					<name>omegavaropts</name>
					<attributes>
						<prompt>Allow the nonsynonymous/synonymous rate ratio (omega) (Omegavar=)</prompt>
						<paramfile>paramfile.txt</paramfile>
						<precond>
								<language>perl</language>
								<code>!$mrbayesblockquery &amp;&amp; $nucmodelopts eq "codon"</code>
						</precond>  
						<format>
							<language>perl</language>
							<code>"lset omegavar= $value\\n"</code>
						</format>
						<vdef>
							<value>equal</value>
						</vdef>
						<vlist>
							<value>equal</value>
							<label>equal</label>
							<value>Ny98</value>
							<label>Ny98</label>
							<value>M3</value>
							<label>M3</label>
						</vlist>
						<group>5</group>
						<comment>
<value>Allows the nonsynonymous/synonymous rate ratio (omega) to vary across codons. Ny98 assumes that there are three classes, with potentially different omega values (omega1, omega2, omega3): omega2 = 1; omega1 is less than 1 but greater than 0; and omega3 is greater than 1. Like the Ny98 model,  the M3 model has three omega classes. However, their values are  less constrained, with omega1 less than omega2, which is less than omega3. The default (omegavar = equal) has no variation on omega across sites.</value>
						</comment>
					</attributes>
				</parameter>
				
<!-- our version of mrbayes does no know this command
				<parameter ismandatory="1" type="Excl">
					<name>ploidyopts</name>
					<attributes>
						<prompt>Set the ploidy (Ploidy=)</prompt>
						<format>
							<language>perl</language>
							<code>"Ploidy= $value\\n"</code>
						</format>

						<precond>
							<language>perl</language>
							<code>$brlenspropts eq "clock:coalescence"</code>
						</precond>
						<vdef>
							<value>Diploid</value>
						</vdef>
						<vlist>
							<value>Diploid</value>
							<label>Diploid</label>
							<value>Haploid</value>
							<label>Haploid</label>
						</vlist>
						<group>5</group>
						<comment>
<value>This option is used when a coalescence prior is used on trees.                                                 
</value>
						</comment>
					</attributes>
				</parameter>  -->
				
				<parameter ismandatory="1" type="Excl">
					<name>rateopts</name>
					<attributes>
						<prompt>Set the model for among-site rate variation (Rates=)</prompt>
						<paramfile>paramfile.txt</paramfile>
						<precond>
								<language>perl</language>
								<code>!$mrbayesblockquery</code>
						</precond>
						<format>
							<language>perl</language>
							<code>"lset Rates= $value\\n"</code>
						</format>
						<vdef>
							<value>equal</value>
						</vdef>
						<vlist>
							<value>equal</value>
							<label>equal</label>
							<value>gamma</value>
							<label>gamma</label>
							<value>adgamma</value>
							<label>adgamma</label>
							<value>propinv</value>
							<label>propinv</label>
							<value>invgamma</value>
							<label>invgamma</label>
						</vlist>
						<group>5</group>
						<comment>
<value>In general, the rate at a site is considered to be an unknown random variable. Valid options are: equal:No rate variation across sites; gamma: The rate at a site is drawn from a gamma distribution. The gamma distribution has a single parameter that describes how much rates vary; adgamma:  Autocorrelated rates across sites. The marginal rate distribution is gamma, but adjacent sites have correlated rates; propinv  -- A proportion of the sites are invariable; invgamma -- A proportion of the sites are invariable while the rate for the remaining sites are drawn from a gamma distribution.Note that MrBayes versions 2.0 and earlier supported options that allowed site specific rates (e.g., ssgamma). In versions 3.0 and later, site specific rates are allowed, but set using the 'prset ratepr' command for each partition.                    
</value>
						</comment>
					</attributes>
				</parameter>
				
				<parameter type="Integer">
					<name>Ngammacatopts</name>
					<attributes>
						<prompt>Set number of rate categories for gamma distribution (Ngammacat=)</prompt>
						<paramfile>paramfile.txt</paramfile>
						<precond>
								<language>perl</language>
								<code>!$mrbayesblockquery &amp;&amp; $rateopts eq "gamma"</code>
						</precond>
						<format>
							<language>perl</language>
							<code>"lset Ngammacat= $value\\n"</code>
						</format>
						<vdef>
							<value>4</value>
						</vdef>
						<group>5</group>
						<comment>
<value>The Ngammacat parameter sets the number of rate categories for the gamma distribution. The gamma distribution is continuous. However, it is virtually impossible to calculate likelihoods under the continuous gamma distribution. Hence, an approximation to the continuous gamma is used; the gamma distribution is broken into ncat categories of equal weight (1/ncat). The mean rate for each category represents the rate for the entire cateogry. This option allows you to specify how many rate categories to use when approximating the gamma. The approximation is better as ncat is increased. In practice, "ncat=4" does a reasonable job of approximating the continuous gamma.                               
</value>
						</comment>
					</attributes>
				</parameter>
				
				<parameter type="Integer">
					<name>Nbetacatopts</name>
					<attributes>
						<prompt>Set number of rate categories for beta distribution (Nbetacat=)</prompt>
						<paramfile>paramfile.txt</paramfile>
						<precond>
								<language>perl</language>
								<code>!$mrbayesblockquery</code>
						</precond>
						<format>
							<language>perl</language>
							<code>"lset Nbetacat= $value\\n"</code>
						</format>
						<vdef>
							<value>5</value>
						</vdef>
						<group>5</group>
						<comment>
<value>A symmetric beta distribution is used to model the stationary frequencies when morphological data are used. This option specifies how well the beta distribution will be approximated.</value>
						</comment>
					</attributes>
				</parameter>
				
				<parameter type="Switch">
					<name>Covarionopts</name>
					<attributes>
						<prompt>Force the use of covarion-like model (4X4 dna model, or protein) (Covarion=)</prompt>
						<paramfile>paramfile.txt</paramfile>
<!-- precond for 4x4 model (dna) or protein model-->
			<!--			<precond>
worried about this
							<language>perl</language>
			 			<code>$nucmodelopts eq "4by4" || $aamodelpropts !=""</code>
						</precond> -->
						<precond>
								<language>perl</language>
								<code>!$mrbayesblockquery</code>
						</precond>	
						<format>
							<language>perl</language>
							<code>($value)? "lset Covarion = Yes\\n":""</code>
						</format>
						<vdef>
							<value>0</value>
						</vdef>
						<group>5</group>
						<comment>
<value>This forces the use of a covarion-like model of substitution for nucleotide or amino acid data (it is not used for other data types).The valid options are "yes"  and "no". The covarion model allows the rate at a site to change over its evolutionary history. Specifically, the site is either on or off. When it is off, no substitutions are possible. When the process is on, substitutions occur according to a specified substitution model (specified using the other lset options).                                                    
</value>
						</comment>
					</attributes>
				</parameter>
				
				<parameter ismandatory="1" type="Excl">
					<name>codingopts</name>
					<attributes>
						<prompt>Specify how characters were sampled (Coding=)</prompt>
						<paramfile>paramfile.txt</paramfile>
						<precond>
								<language>perl</language>
								<code>!$mrbayesblockquery</code>
						</precond>
						<format>
							<language>perl</language>
							<code>"lset coding = $value\\n"</code>
						</format>
						<vdef>
							<value>all</value>
						</vdef>
						<vlist>
							<value>all</value>
							<label>All</label>
							<value>variable</value>
							<label>Variable</label>
							<value>noabsence</value>
							<label>No absence</label>
							<value>nopresence</value>
							<label>No presence</label>
						</vlist>
						<group>5</group>
						<comment>
<value>The Coding parameter specifies how characters were sampled. If all site patterns had the possibility of being sampled, then "all" should be specified (the default). Otherwise "variable" (only var   iable characters had the possibility of being sampled), "noabsence" (characters for which all taxa were coded as absent were not sampled), and "nopresence" (characters for which all taxa were coded as present were not sampled. "All" works for all data types. However, the others only work for morphological (all/variable) or restriction site (all/variable/noabsence/nopresence) data. </value>
						</comment>
					</attributes>
				</parameter>
				
				<parameter type="Switch">
					<name>Parsmodelopts</name>
					<attributes>
						<prompt>Force calculation under a Parsimony model (Parmodel=)</prompt>
						<paramfile>paramfile.txt</paramfile>
						<precond>
								<language>perl</language>
								<code>!$mrbayesblockquery</code>
						</precond>
						<vdef>
							<value>0</value>
						</vdef>
						<group>5</group>
						<comment>
<value>This forces calculation under the so-called parsimony model described by Tuffley and Steel (1998). The options are "yes" or "no". Note that the biological assumptions of this model are anything but parsimonious. In fact, this model assumes many more parameters than the next most complicated model implemented in this program. If you really believe that the parsimony model makes the biological assumptions described by Tuffley and Steel, then the parsimony method is miss-named.</value>
						</comment>
					</attributes>
				</parameter>
				
			</parameters>
			
	</paragraph>
</parameter>

<parameter type="Paragraph">
	<paragraph>
		<name>prsetparams</name>
		<prompt>Configure Priors</prompt>
			<parameters>
<!--*******************************************************************************************
All of the parameters in this section must be preceded by the string prset
***********************************************************************************************-->
<!-- this section is for adding the applyto command, not quite ready for this yet -->
<!--				<parameter ismandatory="1" type="Excl">
					<name>applyprsetopts1</name>
					<attributes>
						<prompt>Parameters for Unpartitioned Data Set, or Partition 1</prompt>
						<format>
							<language>perl</language>
							<code>"applyto=(1)\\n"</code>
						</format> 
					</attributes>
				</parameter>    -->
				
				<parameter ismandatory="1" type="Excl">
					<name>tratioopts</name>
					<attributes>
						<prompt>Transition/Transversion Ration; DNA only (Tratiopr=)</prompt>
							<paramfile>paramfile.txt</paramfile>
							<precond>
								<language>perl</language>
								<code>!$mrbayesblockquery</code>
						</precond>
<!--						<precond>DNA Only</precond> -->  
						<vdef>
							<value>beta</value>
						</vdef>
						<vlist>
							<value>beta</value>
							<label>beta</label>
							<value>fixed</value>
							<label>fixed</label>
						</vlist>
						<flist>
							<value>beta</value>
							<code>"prset Tratiopr = beta($betameanx, $betavary)\\n"</code>
							<value>fixed</value>
							<code>"preset Tratiopr = fixed($tratiofixed)\\n"</code>
						</flist>
						<group>10</group>
						<comment>
<value>Tratiopr changes the prior probability of the transition/transversion ratio. It can be fixed (fixed), or set to a beta distribution with mean x and variance y (beta(x,y)).The program assumes that the transition and transversion rates are independent gamma-distributed random variables with the same scale parameter when beta is selected. If you want a diffuse prior that puts equal emphasis on transition/transversion rate ratios above 1.0 and below 1.0, then use a flat Beta, beta(1,1), which is the default. If you wish to concentrate this distribution more in the equal-rates region, then use a prior of the type beta(x,x), where the magnitude of x determines how much the prior is concentrated in the equal rates region. For instance, a beta(20,20) puts more    probability on rate ratios close to 1.0 than a beta(1,1). If you think it is likely that the transition/transversion rate ratio is 2.0, you can use a prior of the type beta(2x,x), where x determines how strongly the prior is concentrated on tratio values near 2.0. For instance, a beta(2,1) is much more diffuse than a beta(80,40) but both have the expected tratio 2.0 in the absence of data. The parameters of the      Beta can be interpreted as counts: if you have observed x transitions and y transversions, then a beta(x+1,y+1) is a good representation of this information. The fixed option allows you to fix the tratio to a particular value.</value>
						</comment>
					</attributes>
				</parameter>
				
				<parameter type="Float">
					<name>betameanx</name>
					<attributes>
						<prompt>Beta mean x</prompt>
						<precond>
								<language>perl</language>
								<code>!$mrbayesblockquery &amp;&amp; $tratioopts eq "beta"</code>
						</precond> 
						<format>
							<language>perl</language>
							<code>""</code>
						</format> 
						<vdef>
							<value>1.0</value>
						</vdef>
						<group>10</group>
					</attributes>
				</parameter>
				
				<parameter type="Float">
					<name>betavary</name>
					<attributes>
						<prompt>Beta variance y</prompt>
						<format>
							<language>perl</language>
							<code>""</code>
						</format>
						<precond>
							<language>perl</language>
							<code>!$mrbayesblockquery &amp;&amp; $tratioopts eq "beta"</code>
						</precond>
						<vdef>
							<value>1.0</value>
						</vdef>
						<group>10</group>
					</attributes>
				</parameter>
				
				<parameter type="Float">
					<name>tratiofixed</name>
					<attributes>
						<prompt>Fixed Transition/Transversion Ratio</prompt>
						<format>
							<language>perl</language>
							<code>""</code>
						</format>
						<precond>
							<language>perl</language>
							<code>!$mrbayesblockquery &amp;&amp; $tratioopts eq "fixed"</code>
						</precond>
						<vdef>
							<value>1.0</value>
						</vdef>
						<group>10</group>
					</attributes>
				</parameter>
				
				<parameter ismandatory="1" type="Excl">
					<name>revmatpropts</name>
					<attributes>
						<prompt>Substitution Rates of the GTR Model; Nucleic Data only (Revmatpr=)</prompt>
							<paramfile>paramfile.txt</paramfile>
							<precond>
								<language>perl</language>
								<code>!$mrbayesblockquery</code>
						</precond>
<!--						<precond>DNA Only</precond> -->  
						<vdef>
							<value>dirichlet</value>
						</vdef>
						<vlist>
							<value>dirichlet</value>
							<label>dirichlet</label>
							<value>fixed</value>
							<label>fixed</label>
						</vlist>
						<flist>
							<value>dirichlet</value>
							<code>"prset revmatpr = dirichlet($atocrate,$atograte,$atotrate,$ctograte,$ctotrate,$gtotrate)\\n"</code>
							<value>fixed</value>
							<code>"prset revmatpr = fixed($fixedatocrate,$fixedatograte,$fixedatotrate,$fixedctograte,$fixedctotrate,$fixedgtotrat)\\n"</code>
						</flist>
						<group>10</group>
						<comment>
<value>
Revmatpr sets the prior for the substitution rates of the GTR model for nucleotide data. For Revmatpr=dirichlet, MrBayes assumes that the six substitution rates are independent gamma-distributed random variables with the same scale parameter. The six numbers in brackets each corresponds to a particular substitution type. Together, they determine the shape of the prior. The six rates are in the order A / C, A / G, A / T, C / G, C / T, and G / T. By default, dirichlet(1,1,1,1,1,1) is used, also referred to as a 'flat' Dirichlet. For a prior where the C / T rate is 5 times and the A / G rate 2 times higher, on average, than the transversion rates, which are all the same, then you should use a prior of the form dirichlet(x,2x,x,x,5x,x), where x determines how much the prior is focused on these particular rates. For more information, see Tratiopr. The fixed option allows you to fix the substitution rates to particular values.                            
</value>
						</comment>
					</attributes>
				</parameter>
				
	<!-- six conversion frequencies, for dirichlet ates -->
				<parameter type="Float">
					<name>atocrate</name>
					<attributes>
						<prompt>A/C rate</prompt>
						<format>
							<language>perl</language>
							<code>""</code>
						</format>
						<precond>
							<language>perl</language>
							<code>!$mrbayesblockquery &amp;&amp; $revmatpropts eq "dirichlet"</code>
						</precond>  
						<vdef>
							<value>1.0</value>
						</vdef>
						<group>10</group>
					</attributes>
				</parameter>
				
				<parameter type="Float">
					<name>atograte</name>
					<attributes>
					<prompt>A/G rate</prompt>
						<format>
							<language>perl</language>
							<code>""</code>
						</format>
						<precond>
							<language>perl</language>
							<code>!$mrbayesblockquery &amp;&amp; $revmatpropts eq "dirichlet"</code>
						</precond>  
						<vdef>
							<value>1.0</value>
						</vdef>
						<group>10</group>
					</attributes>
				</parameter>
				
				<parameter type="Float">
					<name>atotrate</name>
					<attributes>
						<prompt>A/T rate</prompt>
						<format>
							<language>perl</language>
							<code>""</code>
						</format>
						<precond>
							<language>perl</language>
							<code>!$mrbayesblockquery &amp;&amp; $revmatpropts eq "dirichlet"</code>
						</precond>  
						<vdef>
							<value>1.0</value>
						</vdef>
						<group>10</group>
					</attributes>
				</parameter>
				
				<parameter type="Float">
					<name>ctograte</name>
					<attributes>
						<prompt>C/G rate</prompt>
						<format>
							<language>perl</language>
							<code>""</code>
						</format>
						<precond>
							<language>perl</language>
							<code>!$mrbayesblockquery &amp;&amp; $revmatpropts eq "dirichlet"</code>
						</precond>  
						<vdef>
							<value>1.0</value>
						</vdef>
						<group>10</group>
					</attributes>
				</parameter>
				
				<parameter type="Float">
					<name>ctotrate</name>
					<attributes>
						<prompt>C/T rate</prompt>
						<format>
							<language>perl</language>
							<code>""</code>
						</format>
						<precond>
							<language>perl</language>
							<code>!$mrbayesblockquery &amp;&amp; $revmatpropts eq "dirichlet"</code>
						</precond>  
						<vdef>
							<value>1.0</value>
						</vdef>
						<group>10</group>
					</attributes>
				</parameter>
				
				<parameter type="Float">
					<name>gtotrate</name>
					<attributes>
						<prompt>G/T Rate</prompt>
						<format>
							<language>perl</language>
							<code>""</code>
						</format>
						<precond>
							<language>perl</language>
							<code>!$mrbayesblockquery &amp;&amp; $revmatpropts eq "dirichlet"</code>
						</precond>  
						<vdef>
							<value>1.0</value>
						</vdef>
						<group>10</group>
					</attributes>
				</parameter>
				
<!-- these are the same frequencies, for fixed rates -->
				<parameter type="Float">
					<name>fixedatocrate</name>
					<attributes>
						<prompt>A/C rate</prompt>
						<format>
							<language>perl</language>
							<code>""</code>
						</format>
						<precond>
							<language>perl</language>
							<code>!$mrbayesblockquery &amp;&amp; $revmatpropts eq "fixed"</code>
						</precond>  
						<vdef>
							<value>1.0</value>
						</vdef>
						<group>10</group>
					</attributes>
				</parameter>
				
				<parameter type="Float">
					<name>fixedatograte</name>
					<attributes>
						<prompt>A/G rate</prompt>
						<format>
							<language>perl</language>
							<code>""</code>
						</format>
						<precond>
							<language>perl</language>
							<code>!$mrbayesblockquery &amp;&amp; $revmatpropts eq "fixed"</code>
						</precond>  
						<vdef>
							<value>1.0</value>
						</vdef>
						<group>10</group>
					</attributes>
				</parameter>
				
				<parameter type="Float">
					<name>fixedatotrate</name>
					<attributes>
						<prompt>A/T rate</prompt>
						<format>
							<language>perl</language>
							<code>""</code>
						</format>
						<precond>
							<language>perl</language>
							<code>!$mrbayesblockquery &amp;&amp; $revmatpropts eq "fixed"</code>
						</precond>  
						<vdef>
							<value>1.0</value>
						</vdef>
						<group>10</group>
					</attributes>
				</parameter>
				
				<parameter type="Float">
					<name>fixedctograte</name>
					<attributes>
						<prompt>C/G rate</prompt>
						<format>
							<language>perl</language>
							<code>""</code>
						</format>
						<precond>
							<language>perl</language>
							<code>!$mrbayesblockquery &amp;&amp; $revmatpropts eq "fixed"</code>
						</precond>  
						<vdef>
							<value>1.0</value>
						</vdef>
						<group>10</group>
					</attributes>
				</parameter>
				
				<parameter type="Float">
					<name>fixedctotrate</name>
					<attributes>
						<prompt>C/T rate</prompt>
						<format>
							<language>perl</language>
							<code>""</code>
						</format>
						<precond>
							<language>perl</language>
							<code>!$mrbayesblockquery &amp;&amp; $revmatpropts eq "fixed"</code>
						</precond>  
						<vdef>
							<value>1.0</value>
						</vdef>
						<group>10</group>
					</attributes>
				</parameter>
				
				<parameter type="Float">
					<name>fixedgtotrate</name>
					<attributes>
						<prompt>G/T Rate</prompt>
						<format>
							<language>perl</language>
							<code>""</code>
						</format>
						<precond>
							<language>perl</language>
							<code>!$mrbayesblockquery &amp;&amp; $revmatpropts eq "fixed"</code>
						</precond>  
						<vdef>
							<value>1.0</value>
						</vdef>
						<group>10</group>
					</attributes>
				</parameter>
				
<!--amino acid models are established in prset,and not lset, for unknown reasons -->
				<parameter ismandatory="1" type="Excl">
					<name>aamodelpropts</name>
					<attributes>
						<prompt>Set the Rate Matrix for Amino Acids (Aamodelpr=)</prompt>
							<paramfile>paramfile.txt</paramfile>
						<precond>
								<language>perl</language>
								<code>!$mrbayesblockquery</code>
						</precond>
						<format>
							<language>perl</language>
							<code>("$value" ne "$vdef")? "prset aamodelpr=$value\\n" : ""</code>
						</format>
	<!--	Precond on protein data		 -->  
						<vdef>
							<value>fixed(poisson)</value>
						</vdef>
						<vlist>
							<value>fixed(blosum)</value>
							<label>Blosum</label>
							<value>fixed(cprev)</value>
							<label>Cprev</label>
							<value>fixed(dayhoff)</value>
							<label>Dayhoff</label>
							<value>fixed(equalin)</value>
							<label>Equalin</label>
							<value>fixed(gtr)</value>
							<label>GTR</label>
							<value>fixed(jones)</value>
							<label>Jones</label>
							<value>mixed</value>
							<label>MIxed</label>
							<value>fixed(mtmam)</value>
							<label>Mtmam</label>
							<value>fixed(mtrev)</value>
							<label>Mtrev</label>
							<value>fixed(poisson)</value>
							<label>Poisson</label>
							<value>fixed(rtrev)</value>
							<label>Rtrev</label>
							<value>fixed(vt)</value>
							<label>Vt</label>
							<value>fixed(wag)</value>
							<label>Wag</label>
						</vlist>
						<group>10</group>
						<comment>
<value>Aamodelpr sets the rate matrix for amino acid data.You choose a single fixed model, or choose mixed to average over the ten models by specifying "mixed".
In the latter case, the Markov chain will sample each model according to its probability. The sampled model is reported as an index: poisson(0), jones(1), dayhoff(2), mtrev(3), mtmam(4), wag(5), rtrev(6), cprev(7), vt(8), or blosum(9). The 'Sump' command summarizes the MCMC samples and calculates the posterior probability estimate for each of these models.  
</value>
						</comment>
					</attributes>
				</parameter>
				
<!-- We do not support this parameter at present.				

<parameter ismandatory="1" type="Excl">
					<name>Aarevmatpropts</name>
					<attributes>
						<prompt>Rate Matrix for Amino Acid Data (Aarevmatprr=)</prompt>
						<format>
							<language>perl</language>
							<code>""</code>
						</format>
<precond>Amino Acid Only</precond>  
						<vdef>
							<value>dirichlet</value>
						</vdef>
						<vlist>
							<value>dirichlet</value>
							<label>dirichlet</label>
							<value>fixed</value>
							<label>fixed</label>
						</vlist>
						<group>10</group>
						<comment>
<value>This parameter sets the prior for the substitution rates of the GTR model for amino acid data. The options are dirichlet and fixed, the same as those for 'Revmatpr' except that they are defined over the 190 rates of the time-reversible GTR model for amino acids instead of over the 6 rates of the GTR model for nucleotides. The rates are in the order A / R,  A / N, etc to Y / V. In other words, amino acids are listed in alphabetic order based on their full name. The first amino acid (Alanine) is then combined in turn with all amino acids following it in the list, starting with amino acid 2 (Arginine) and finishing with amino acid 20 (Valine). The second amino acid (Arginine) is then combined in turn with all amino acids following it, starting with amino acid 3 (Asparagine) and finishing with amino acid 20 (Valine), and so on.         
</value>
						</comment>
					</attributes>
				</parameter>  -->
				
				<parameter ismandatory="1" type="Excl">
					<name>omegapropts</name>
					<attributes>
						<prompt>Nonsynonymous/Synonymous Rate Ratio (Omegapr=)</prompt>
							<paramfile>paramfile.txt</paramfile>
						<precond>
							<language>perl</language>
							<code>!$mrbayesblockquery &amp;&amp; $omegavaropts eq "equal" &amp;&amp; $nucmodelopts eq "codon" </code>
						</precond>
						<vdef>
							<value>uniform</value>
						</vdef>
						<vlist>
							<value>uniform</value>
							<label>uniform</label>
							<value>exponential</value>
							<label>exponential</label>
							<value>fixed</value>
							<label>fixed</label>
						</vlist>
						<flist>
							<value>uniform</value>
							<code>"prset omegapr = uniform($omegaprdir1,$omegaprdir2)\\n"</code>
							<value>exponential</value>
							<code>"prset omegapr = exponential($omegaprexponential)\\n"</code>
							<value>fixed</value>
							<code>"prset omegapr = fixed($omegafixed)\\n"</code>
						</flist>
						<group>10</group>
						<comment>
<value>This parameter specifies the prior on the nonsynonymous/synonymous rate ratio. The options are:uniform, exponential, and fixed.
This parameter is used only when the nucleotide substitution model is set to codon, and there is no variation in omega across sites (i.e. omegavar=equal").                               
</value>
						</comment>
					</attributes>
				</parameter>
				
				<parameter type="Float">
					<name>omegaprdir1</name>
					<attributes>
						<prompt>Uniform Omega Rate1</prompt>
						<format>
							<language>perl</language>
							<code>""</code>
						</format>
						<precond>
							<language>perl</language>
							<code>!$mrbayesblockquery &amp;&amp; $omegapropts eq "uniform"</code>
						</precond>  
						<vdef>
							<value>1.0</value>
						</vdef>
						<group>10</group>
					</attributes>
				</parameter>
				
				<parameter type="Float">
					<name>omegaprdir2</name>
					<attributes>
						<prompt>Uniform Omega Rate2</prompt>
						<precond>
							<language>perl</language>
							<code>!$mrbayesblockquery &amp;&amp; $omegapropts eq "uniform"</code>
						</precond>
						<format>
							<language>perl</language>
							<code>""</code>
						</format>  
						<vdef>
							<value>1.0</value>
						</vdef>
						<group>10</group>
					</attributes>
				</parameter>
				
				<parameter type="Float">
					<name>omegaprexponential</name>
					<attributes>
						<prompt>Exponential Omega Rate</prompt>
						<precond>
							<language>perl</language>
							<code>!$mrbayesblockquery &amp;&amp; $omegapropts eq "exponential"</code>
						</precond>
						<format>
							<language>perl</language>
							<code>""</code>
						</format> 
						<vdef>
							<value>1.0</value>
						</vdef>
						<group>10</group>
					</attributes>
				</parameter>
				
				<parameter type="Float">
					<name>omegafixed</name>
					<attributes>
						<prompt>Fixed Omega Rate</prompt>
						<format>
							<language>perl</language>
							<code>""</code>
						</format>
						<precond>
							<language>perl</language>
							<code>!$mrbayesblockquery &amp;&amp; $omegapropts eq "fixed"</code>
						</precond>  
						<vdef>
							<value>1.0</value>
						</vdef>
						<group>10</group>
					</attributes>
				</parameter>
				
				<parameter ismandatory="1" type="Excl">
<!-- guessed at the default values for many of these omega options. There is no documentation whatever for most of them -->
					<name>ny98omega1propts</name>
					<attributes>
						<prompt>Nonsynonymous/Synonymous Rate Ratio for sites under purifying selection (Ny98omega1pr=)</prompt>
							<paramfile>paramfile.txt</paramfile>
						<precond>
							<language>perl</language>
							<code>!$mrbayesblockquery &amp;&amp; $omegavaropts eq "Ny98"</code>
						</precond>
						<vdef>
							<value>beta</value>
						</vdef>
						<vlist>
							<value>beta</value>
							<label>beta</label>
							<value>fixed</value>
							<label>fixed</label>
						</vlist>
						<flist>
							<value>beta</value>
							<code>"prset Ny98omega1pr = beta($ny98omega1prbeta1,$ny98omega1prbeta2)\\n"</code>
							<value>fixed</value>
							<code>"prset Ny98omega1pr = fixed($ny98omega1prfix1)\\n"</code>
						</flist>
						<group>10</group>
						<comment>
<value>This parameter is only in effect if the nucleotide substitution model is set to "codon" and where omega varies across sites using the model of Nielsen and Yang (1998) (i.e., Ny98). If fixing the parameter, you must specify a number between 0 and 1.                                                      
</value>
						</comment>
					</attributes>
				</parameter>
				
				<parameter type="Float">
					<name>ny98omega1prbeta1</name>
					<attributes>
						<prompt>Ny98omega1 Beta Rate 1</prompt>
						<format>
							<language>perl</language>
							<code>""</code>
						</format>
						<precond>
							<language>perl</language>
							<code>!$mrbayesblockquery &amp;&amp; $ny98omega1propts eq "beta"</code>
						</precond>  
						<vdef>
							<value>1.0</value>
						</vdef>
						<group>10</group>
					</attributes>
				</parameter>
				
				<parameter type="Float">
					<name>ny98omega1prbeta2</name>
					<attributes>
						<prompt>Ny98omega1 Beta Rate 2</prompt>
						<format>
							<language>perl</language>
							<code>""</code>
						</format>
						<precond>
							<language>perl</language>
							<code>!$mrbayesblockquery &amp;&amp; $ny98omega1propts eq "beta"</code>
						</precond>  
						<vdef>
							<value>1.0</value>
						</vdef>
						<group>10</group>
					</attributes>
				</parameter>
				
				<parameter type="Float">
					<name>ny98omega1prfix1</name>
					<attributes>
						<prompt>Fixed Ny98Omega1 Rate</prompt>
						<precond>
							<language>perl</language>
							<code>!$mrbayesblockquery &amp;&amp; $ny98omega1propts eq "fixed"</code>
						</precond>
						<format>
							<language>perl</language>
							<code>""</code>
						</format>
	<!--  					<ctrls>
							<ctrl>
								<message>The value entered must be between 0 and 1</message>
								<language>perl</language>
								<code>$ny98omega3pruni1 &gt;= 1 || $ny98omega3pruni1 &lt;= 0</code>
							</ctrl>
						</ctrls>  -->
						<vdef>
							<value>1.0</value>
						</vdef>
						<group>10</group>
					</attributes>
				</parameter>
				
				<parameter ismandatory="1" type="Excl">
<!-- guessed at the default values for many of these omega options. There is no documentation whatever for most of them -->
					<name>ny98omega3propts</name>
					<attributes>
						<prompt>Nonsynonymous/Synonymous Rate Ratio for sites under purifying selection (Ny98omega1pr=)</prompt>
							<paramfile>paramfile.txt</paramfile>
						<precond>
							<language>perl</language>
							<code>!$mrbayesblockquery &amp;&amp; $omegavaropts eq "Ny98"</code>
						</precond>
						<format>
							<language>perl</language>
							<code>""</code>
						</format>
						<vdef>
							<value>exponential</value>
						</vdef>
						<vlist>
							<value>uniform</value>
							<label>uniform</label>
							<value>exponential</value>
							<label>exponential</label>
							<value>fixed</value>
							<label>fixed</label>
						</vlist>
						<flist>
							<value>uniform</value>
							<code>"prset Ny98omega3pr = uniform($ny98omega3pruni1,$ny98omega3pruni2)\\n"</code>
							<value>exponential</value>
							<code>"prset Ny98omega3pr = exponential($ny98omega3prexp1)\\n"</code>
							<value>fixed</value>
							<code>"prset ny98omega3pr = fixed($ny98omega3prfix1)\\n"</code>
						</flist>
						<group>10</group>
						<comment>
<value>This parameter specifies the prior on the nonsynonymous/synonymous rate ratio for positively selected sites. The options are:uniform, exponential, and fixed. This parameter is only in effect if the nucleotide substitution model is set to codon and where omega varies across sites according to the NY98 model. 
</value>
						</comment>
					</attributes>
				</parameter>
				
				<parameter type="Float">
					<name>ny98omega3pruni1</name>
					<attributes>
						<prompt>Ny98 Uniform Omega Rate 1 for Positive Selection</prompt>
						<format>
							<language>perl</language>
							<code>""</code>
						</format>
					<ctrls>
						<ctrl>
								<message>The value entered must be greater than or equal to 1</message>
								<language>perl</language>
								<code>$ny98omega3pruni1 &lt; 1</code>
						</ctrl>
					</ctrls>
						<precond>
							<language>perl</language>
							<code>!$mrbayesblockquery &amp;&amp; $ny98omega3propts eq "uniform"</code>
						</precond>  
						<vdef>
							<value>1.0</value>
						</vdef>
						<group>10</group>
					</attributes>
				</parameter>
				
				<parameter type="Float">
					<name>ny98omega3pruni2</name>
					<attributes>
						<prompt>Ny98 Uniform Omega Rate 2 for Positive Selection</prompt>
						<format>
							<language>perl</language>
							<code>""</code>
						</format>
						<ctrls>
							<ctrl>
								<message>The value entered must be greater than or equal to 1</message>
								<language>perl</language>
								<code>$ny98omega3pruni2 &lt; 1</code>
							</ctrl>
			<!--				<ctrl>
								<message>The first value entered should be less than or equal to the second</message>
								<language>perl</language>
								<code>$ny98omega3pruni1 &gt;= $ny98omega3pruni2</code>
							</ctrl> -->
						</ctrls> 
						<precond>
							<language>perl</language>
							<code>!$mrbayesblockquery &amp;&amp; $ny98omega3propts eq "uniform"</code>
						</precond>  
						<vdef>
							<value>1.0</value>
						</vdef>
						<group>10</group>
					</attributes>
				</parameter>
				
				<parameter type="Float">
					<name>ny98omega3prexp1</name>
					<attributes>
						<prompt>Ny98 Exponential Omega Rate for Positive Selection</prompt>
						<group>10</group>
						<precond>
							<language>perl</language>
							<code>!$mrbayesblockquery &amp;&amp; $ny98omega3propts eq "exponential"</code>
						</precond>
						<vdef>
							<value>1.0</value>
						</vdef>
						<format>
							<language>perl</language>
							<code>""</code>
						</format>
					<ctrls>
						<ctrl>
								<message>The value entered must be greater than or equal to 1</message>
								<language>perl</language>
								<code>$ny98omega3prexp1 &lt; 1</code>
						</ctrl>
					</ctrls>
					</attributes>
				</parameter>
				
				<parameter type="Float">
					<name>ny98omega3prfix1</name>
					<attributes>
						<prompt>Ny98 Fixed Omega Rate for Positive Selection</prompt>
						<format>
							<language>perl</language>
							<code>""</code>
						</format>
						<precond>
							<language>perl</language>
							<code>!$mrbayesblockquery &amp;&amp; $ny98omega3pr eq "fixed"</code>
						</precond>  
						<vdef>
							<value>1.0</value>
						</vdef>
						<group>10</group>
					</attributes>
				</parameter>		
				
				<parameter ismandatory="1" type="Excl">
					<name>codoncatfreqsopts</name>
					<attributes>
						<prompt>Frequencies of sites under Purifying, Neutral, and Positive Selection (Codoncatfreqs=)</prompt>
							<paramfile>paramfile.txt</paramfile>
						<precond>
							<language>perl</language>
			  				<code>$omegavaropts eq "Ny98" || $omegavaropts eq "M3"</code>
						</precond> 
					<!--	<precond>
								<language>perl</language>
								<code>!$mrbayesblockquery</code>
						</precond>  -->
						<format>
							<language>perl</language>
							<code>""</code>
						</format>
						<vdef>
							<value>dirichlet</value>
						</vdef>
						<vlist>
							<value>dirichlet</value>
							<label>dirichlet</label>
							<value>fixed</value>
							<label>fixed</label>
						</vlist>
						<flist>
							<value>dirichlet</value>
							<code>"prset Codoncatfreqs = dirichlet($codoncatfreqsdir1,$codoncatfreqsdir2,$codoncatfreqsdir3)\\n"</code>
							<value>fixed</value>
							<code>"prset Codoncatfreqs = fixed($codoncatfreqsfix1,$codoncatfreqsfix2,$codoncatfreqsfix3)\\n"</code>
						</flist>
						<group>10</group>
						<comment>
<value>Codoncatfreqs specifies the prior on frequencies of sites under purifying, neutral, and positive selection. The options are dirichlet and fixed. This parameter is relevant if the nucleotide substitution model is set to "codon" and where omega varies across sites using the models of Nielsen and Yang (1998), or Yang et al. (2000) i.e. Omegavar=Ny98 or M3. Note that the sum of the three frequencies must be 1.         
</value>
						</comment>
					</attributes>
				</parameter>
				
				<parameter type="Float">
					<name>codoncatfreqsdir1</name>
					<attributes>
						<prompt>Codoncatfreqs Dirichlet Parameter 1</prompt>
						<precond>
							<language>perl</language>
							<code>!$mrbayesblockquery &amp;&amp; $codoncatfreqsopts eq "dirichlet"</code>
						</precond>
						<format>
							<language>perl</language>
							<code>""</code>
						</format>
						<vdef>
							<value>1.0</value>
						</vdef>
						<group>10</group>
					</attributes>
				</parameter>
				
				<parameter type="Float">
					<name>codoncatfreqsdir2</name>
					<attributes>
						<prompt>Codoncatfreqs Dirichlet Parameter 2</prompt>
						<precond>
							<language>perl</language>
							<code>!$mrbayesblockquery &amp;&amp; $codoncatfreqsopts eq "dirichlet"</code>
						</precond>
						<format>
							<language>perl</language>
							<code>""</code>
						</format>
						<vdef>
							<value>1.0</value>
						</vdef>
						<group>10</group>
					</attributes>
				</parameter>
				
				<parameter type="Float">
					<name>codoncatfreqsdir3</name>
					<attributes>
						<prompt>Codoncatfreqs Dirichlet Parameter 3</prompt>
						<format>
							<language>perl</language>
							<code>""</code>
						</format>
						<precond>
							<language>perl</language>
							<code>!$mrbayesblockquery &amp;&amp; $codoncatfreqsopts eq "dirichlet"</code>
						</precond>  
						<vdef>
							<value>1.0</value>
						</vdef>
						<group>10</group>
					</attributes>
				</parameter>
				
				<parameter type="Float">
					<name>codoncatfreqsfix1</name>
					<attributes>
						<prompt>Codoncatfreqs Fixed Parameter 1</prompt>
							<precond>
							<language>perl</language>
							<code>!$mrbayesblockquery &amp;&amp; $codoncatfreqsopts eq "fixed"</code>
						</precond>
						<group>10</group>
						<format>
							<language>perl</language>
							<code>""</code>
						</format>
					</attributes>
				</parameter>
				
				<parameter type="Float">
					<name>codoncatfreqsfix2</name>
					<attributes>
						<prompt>Codoncatfreqs Fixed Parameter 2</prompt>
						<precond>
							<language>perl</language>
							<code>!$mrbayesblockquery &amp;&amp; $codoncatfreqsopts eq "fixed"</code>
						</precond>
						<format>
							<language>perl</language>
							<code>""</code>
						</format> 
						<group>10</group>
					</attributes>
				</parameter>
				
				<parameter type="Float">
					<name>codoncatfreqsfix3</name>
					<attributes>
						<prompt>Codoncatfreqs Fixed Parameter 3</prompt>
						<precond>
							<language>perl</language>
							<code>!$mrbayesblockquery &amp;&amp; $codoncatfreqsopts eq "fixed"</code>
						</precond>
						<group>10</group>
						<format>
							<language>perl</language>
							<code>""</code>
						</format>
	<!--  				<ctrls>
						<ctrl>
								<message>The sum of the fixed parameters must be 1</message>
								<language>perl</language>
								<code>$value + $codoncatfreqsfix2 + $codoncatfreqsfix1  = 1 </code>
						</ctrl>
					</ctrls> -->
					</attributes>
				</parameter>
				
				<parameter ismandatory="1" type="Excl">
					<name>statewfreqpropts</name>
					<attributes>
						<prompt>State Frequencies (Statefreqpr=); Assigning frequencies to each state is not supported</prompt>
						<precond>
								<language>perl</language>
								<code>!$mrbayesblockquery</code>
						</precond>
							<paramfile>paramfile.txt</paramfile>
			<!--  		<precond>
							<language>perl</language>
							<code>$omegavaropts eq "Ny98" || $omegavaropts eq "M3"</code>
						</precond>-->	
						<vdef>
							<value>dirichlet</value>
						</vdef>
						<vlist>
							<value>dirichlet</value>
							<label>dirichlet</label>
							<value>fixed(equal)</value>
							<label>fixed (equal)</label>
							<value>fixed(empirical)</value>
							<label>fixed (empirical)</label>
						</vlist>
						<flist>
							<value>dirichlet</value>
							<code>"prset statefreqpr = dirichlet($statewfreqprdir1)\\n"</code>
							<value>fixed (equal)</value>
							<code>"prset statefreqpr = fixed(equal)\\n"</code>
							<value>fixed (empirical)</value>
							<code>"prset statefreqpr = fixed(empirical)\\n"</code>
						</flist>
						<group>10</group>
						<comment>
<value>This parameter specifies the prior on the state frequencies. The options are dirichlet, fixed, with equal frequencies, and fixed with empirically determined frequencies.     
If you specify a single number, then the prior has all states equally probable with a variance related to the single parameter passed.                                                                                                       
</value>
						</comment>
					</attributes>
				</parameter>
				
				<parameter type="Float">
					<name>statewfreqprdir1</name>
					<attributes>
						<prompt>Statefreqs Dirichlet Parameter (A single number)</prompt>
						<precond>
							<language>perl</language>
							<code>!$mrbayesblockquery &amp;&amp; $statewfreqpropts eq "dirichlet"</code>
						</precond>  
						<vdef>
							<value>1.0</value>
						</vdef>
						<group>10</group>
					</attributes>
				</parameter>	
					
				<parameter ismandatory="1" type="Excl">
					<name>shapepropts</name>
					<attributes>
						<prompt>Gamma Shape Parameter (Shapepr=)</prompt>
						<precond>
								<language>perl</language>
								<code>!$mrbayesblockquery</code>
						</precond>
							<paramfile>paramfile.txt</paramfile>
				<!-- 		<precond>
							<language>perl</language>
							<code>$omegavaropts eq "Ny98" || $omegavaropts eq "M3"</code>
						</precond> -->
						<vdef>
							<value>uniform</value>
						</vdef>
						<vlist>
							<value>uniform</value>
							<label>uniform</label>
							<value>exponential</value>
							<label>exponential</label>
							<value>fixed</value>
							<label>fixed</label>
						</vlist>
						<flist>
							<value>dirichlet</value>
							<code>"prset shapepr = uniform($shapepruni1,$shapepruni2)\\n"</code>
							<value>exponential</value>
							<code>"prset shapepr = exponential($shapeprexp1)\\n"</code>
							<value>fixed</value>
							<code>"prset shapepr = fixed($shapeprfix1)\\n"</code>
						</flist>
						<group>10</group>
						<comment>
<value>This parameter specifies the prior on the state frequencies. The options are dirichlet, fixed, with equal frequencies, and fixed with emirically determined frequencies.     
The dirichlet prior has all states equally probable with a variance related to the single parameter passed in.                                                    
</value>
						</comment>
					</attributes>
				</parameter>
				
				<parameter type="Float">
					<name>shapepruni1</name>
					<attributes>
						<prompt>Gamma Shape Uniform Parameter 1</prompt>
						<format>
							<language>perl</language>
							<code>""</code>
						</format>
						<precond>
							<language>perl</language>
							<code>!$mrbayesblockquery &amp;&amp; $shapepropts eq "uniform"</code>
						</precond>  
						<vdef>
							<value>0.0</value>
						</vdef>
						<group>10</group>
					</attributes>
				</parameter>
				
				<parameter type="Float">
					<name>shapeprdir2</name>
					<attributes>
						<prompt>Gamma Shape Dirichlet Parameter 2</prompt>
						<format>
							<language>perl</language>
							<code>""</code>
						</format>
						<precond>
							<language>perl</language>
							<code>!$mrbayesblockquery &amp;&amp; $shapepropts eq "uniform"</code>
						</precond>  
						<vdef>
							<value>50.0</value>
						</vdef>
						<group>10</group>
					</attributes>
				</parameter>
				
				<parameter type="Float">
					<name>shapeprexp1</name>
					<attributes>
						<prompt>Gamma Shape Exponential Parameter</prompt>
						<format>
							<language>perl</language>
							<code>""</code>
						</format>
						<precond>
							<language>perl</language>
							<code>!$mrbayesblockquery &amp;&amp; $shapepropts eq "exponential"</code>
						</precond>  
						<vdef>
							<value>1.0</value>
						</vdef>
						<group>10</group>
					</attributes>
				</parameter>
				
				<parameter type="Float">
					<name>shapeprfix1</name>
					<attributes>
						<prompt>Gamma Shape Fixed Parameter</prompt>
						<format>
							<language>perl</language>
							<code>""</code>
						</format>
						<precond>
							<language>perl</language>
							<code>!$mrbayesblockquery &amp;&amp; $shapepropts eq "fixed"</code>
						</precond>  
						<vdef>
							<value>1.0</value>
						</vdef>
						<group>10</group>
					</attributes>
				</parameter>
				
				<parameter ismandatory="1" type="Excl">
					<name>pinvarpropts</name>
					<attributes>
						<prompt>Proportion of Invariable Sites (Pinvarpr=)</prompt>
						<precond>
								<language>perl</language>
								<code>!$mrbayesblockquery</code>
						</precond>
						<paramfile>paramfile.txt</paramfile>
						<vdef>
							<value>uniform</value>
						</vdef>
						<vlist>
							<value>uniform</value>
							<label>uniform</label>
							<value>fixed</value>
							<label>fixed</label>
						</vlist>
						<flist>
							<value>uniform</value>
							<code>"prset pinvarpr = uniform($pinvarpruni1,$pinvarpruni2)\\n"</code>
							<value>fixed</value>
							<code>"prset pinvarpr = fixed($pinvarprfix1)\\n"</code>
						</flist>
						<group>10</group>
						<comment>
<value>This parameter specifies the prior for the proportion of invariable sites. The options are uniform and fixed. The valid range for the parameters is between 0 and 1.
</value>
						</comment>
					</attributes>
				</parameter>
				
				<parameter type="Float">
					<name>pinvarpruni1</name>
					<attributes>
						<prompt>Invariable Sites, Uniform Parameter 1</prompt>
						<precond>
							<language>perl</language>
							<code>!$mrbayesblockquery &amp;&amp; $pinvarpropts eq "uniform"</code>
						</precond>  
						<format>
							<language>perl</language>
							<code>""</code>
						</format>
		<!--  				<ctrls>
						<ctrl>
								<message>The valid range for pinvarpr parameters is between 0 and 1</message>
								<language>perl</language>
								<code>$value &gt; 1 || $value &lt; 0</code>
						</ctrl>
					</ctrls>-->
						<vdef>
							<value>0.0</value>
						</vdef>
						<group>10</group>
					</attributes>
				</parameter>
				
				<parameter type="Float">
					<name>pinvarpruni2</name>
					<attributes>
						<prompt>Invariable Sites, Uniform Parameter 2</prompt>
						<precond>
							<language>perl</language>
							<code>!$mrbayesblockquery &amp;&amp; $pinvarpropts eq "uniform"</code>
						</precond>				
						<format>
							<language>perl</language>
							<code>""</code>
						</format>
						<vdef>
							<value>1.0</value>
						</vdef>
		  	<!--			<ctrls>
				  		<ctrl>
								<message>The valid range for pinvarpr parameters is between 0 and 1</message>
								<language>perl</language>
								<code>$value &gt; 1 || $value &lt; 0</code>
						</ctrl> 
						<ctrl>
								<message>The second parameter should be larger than the first</message>
								<language>perl</language>
								<code>$pinvarpruni1 &gt; $value</code>
						</ctrl> 
					</ctrls> -->
						<group>10</group>
					</attributes>
				</parameter>
				
				<parameter type="Float">
					<name>pinvarprfix1</name>
					<attributes>
						<prompt>Invariable Sites, Fixed Parameter</prompt>
						<precond>
							<language>perl</language>
							<code>!$mrbayesblockquery &amp;&amp; $pinvarpropts eq "fixed"</code>
						</precond>
						<format>
							<language>perl</language>
							<code>""</code>
						</format>
						<vdef>
							<value>1.0</value>
						</vdef>
						<group>10</group>
 	
					</attributes>
				</parameter>
				
				<parameter ismandatory="1" type="Excl">
					<name>ratecorrpropts</name>
					<attributes>
						<prompt>Autocorrelation Parameter for Gamma Distribution for Among SIte Variation (Ratecorrpr=)</prompt>
							<paramfile>paramfile.txt</paramfile>
							<precond>
								<language>perl</language>
								<code>!$mrbayesblockquery</code>
							</precond>
						<vdef>
							<value>uniform</value>
						</vdef>
						<vlist>
							<value>uniform</value>
							<label>uniform</label>
							<value>fixed</value>
							<label>fixed</label>
						</vlist>
						<flist>
							<value>uniform</value>
							<code>"prset ratecorrpr = uniform($ratecorrpruni1,$ratecorrpruni2)\\n"</code>
							<value>fixed</value>
							<code>"prset ratecorrpr = fixed($ratecorrprfix1)\\n"</code>
						</flist>
						<group>10</group>
						<comment>
<value>This parameter specifies the prior for the autocorrelation parameter of the autocorrelated gamma distribution for among-site rate variation. The options are uniform and fixed 
The parameter for uniform is between -1 and 1. The default setting is uniform, (-1, 1).
</value>
						</comment>
					</attributes>
				</parameter>
				
				<parameter type="Float">
					<name>ratecorrpruni1</name>
					<attributes>
						<prompt>Autocorrelation Uniform Parameter 1</prompt>
						<format>
							<language>perl</language>
							<code>""</code>
						</format>
						<precond>
							<language>perl</language>
							<code>!$mrbayesblockquery &amp;&amp; $ratecorrpropts eq "uniform"</code>
						</precond>
			<!-- 	 		<ctrls>
				 			<ctrl>
									<message>The value entered must be between -1 and 1</message>
									<language>perl</language>
									<code>$ratecorrpruni1 &lt;= 1 || &gt;= -1</code>
							</ctrl>
						</ctrls>  -->
						<vdef>
							<value>-1.0</value>
						</vdef>
						<group>10</group>
					</attributes>
				</parameter>
				
				<parameter type="Float">
					<name>ratecorrpruni2</name>
					<attributes>
						<prompt>Autocorrelation Uniform Parameter 2</prompt>
						<format>
							<language>perl</language>
							<code>""</code>
						</format>
						<precond>
							<language>perl</language>
							<code>!$mrbayesblockquery &amp;&amp; $ratecorrpropts eq "uniform"</code>
						</precond>  
						<vdef>
							<value>1.0</value>
						</vdef>
			<!-- 	 		<ctrls>
							<ctrl>
									<message>The value entered must be between -1 and 1</message>
									<language>perl</language>
									<code>$ratecorrpruni2 &lt;= 1 || &gt;= -1</code>
							</ctrl>
						</ctrls>    -->
						<group>10</group>
					</attributes>
				</parameter>
				
				<parameter type="Float">
					<name>ratecorrprfix1</name>
					<attributes>
						<prompt>Autocorrelation Fixed Parameter</prompt>
						<precond>
							<language>perl</language>
							<code>!$mrbayesblockquery &amp;&amp; $ratecorrpropts eq "fixed"</code>
						</precond>  
						<format>
							<language>perl</language>
							<code>""</code>
						</format>
						<vdef>
							<value>1.0</value>
						</vdef>
						<group>10</group>
					</attributes>
				</parameter>	
											
				<parameter ismandatory="1" type="Excl">
					<name>covswitchpropts</name>
					<attributes>
						<prompt>Covrion Switching Rates (Covswitchpr=)</prompt>
						<precond>
								<language>perl</language>
								<code>!$mrbayesblockquery</code>
						</precond>
							<paramfile>paramfile.txt</paramfile>
				<!-- 	<precond>
							<language>perl</language>
							<code>$omegavaropts eq "Ny98" || $omegavaropts eq "M3"</code>
						</precond> -->	
						<vdef>
							<value>uniform</value>
						</vdef>
						<vlist>
							<value>uniform</value>
							<label>uniform</label>
							<value>exponential</value>
							<label>exponential</label>
							<value>fixed</value>
							<label>fixed</label>
						</vlist>
						<flist>
							<value>uniform</value>
							<code>"prset covswitchpr = uniform($covswitchuni1,$covswitchuni2)\\n"</code>
							<value>exponential</value>
							<code>"prset covswitchpr = exponential($covswitchexp1)\\n"</code>
							<value>fixed</value>
							<code>"prset covswitchpr = fixed($covswitchfix1,covswitchfix2)\\n"</code>
						</flist>
						<group>10</group>
						<comment>
<value>This option sets the prior for the covarion switching rates. The options are uniform, exponential, and fixed, The covarion model has two rates: a rate from on to off       
and a rate from off to on. The rates are assumed to have independent priors that individually are either uniformly or exponentially distributed. The other option is to fix the switching rates, in which case you must specify both rates. (The first number is off to on and the second is on to off; the first should always be less than the second).                                                  
</value>
						</comment>
					</attributes>
				</parameter>
				
				<parameter type="Float">
					<name>covswitchuni1</name>
					<attributes>
						<prompt>Covarion Model Off to On Rate (Uniform)</prompt>
						<precond>
							<language>perl</language>
							<code>!$mrbayesblockquery &amp;&amp; $covswitchpropts eq "uniform"</code>
						</precond>  
						<format>
							<language>perl</language>
							<code>""</code>
						</format>
						<vdef>
							<value>0.0</value>
						</vdef>
						<group>10</group>
					</attributes>
				</parameter>
				
				<parameter type="Float">
					<name>covswitchuni2</name>
					<attributes>
						<prompt>Covarion Model On to Off Rate (Uniform)</prompt>
						<precond>
							<language>perl</language>
							<code>!$mrbayesblockquery &amp;&amp; $covswitchpropts eq "uniform"</code>
						</precond>  
						<format>
							<language>perl</language>
							<code>""</code>
						</format>
						<vdef>
							<value>100.0</value>
						</vdef>
						<group>10</group>
					<!-- 
						
					 			<message>The first parameter must be less than the second</message>
								<language>perl</language>
								<code>$covswitchuni1 &gt; $value</code>
							</ctrl>
						-->
					</attributes>
				</parameter>
				
				<parameter type="Float">
					<name>covswitchexp1</name>
					<attributes>
						<prompt>Covarion Model Exponential Parameter</prompt>
						<format>
							<language>perl</language>
							<code>""</code>
						</format>
						<precond>
							<language>perl</language>
							<code>!$mrbayesblockquery &amp;&amp; $covswitchpropts eq "exponential"</code>
						</precond>  
						<vdef>
							<value>1.0</value>
						</vdef>
						<group>10</group>
					</attributes>
				</parameter>
				
				<parameter type="Float">
					<name>covswitchfix1</name>
					<attributes>
						<prompt>Covarion Model Off to On Rate (Fixed)</prompt>
						<format>
							<language>perl</language>
							<code>""</code>
						</format>
						<precond>
							<language>perl</language>
							<code>!$mrbayesblockquery &amp;&amp; $covswitchpropts eq "fixed"</code>
						</precond>  
						<vdef>
							<value>1.0</value>
						</vdef>
						<group>10</group>
					</attributes>
				</parameter>
				
				<parameter type="Float">
					<name>covswitchfix2</name>
					<attributes>
						<prompt>Covarion Model On to Off Rate (Fixed)</prompt>
						<format>
							<language>perl</language>
							<code>""</code>
						</format>
						<precond>
							<language>perl</language>
							<code>!$mrbayesblockquery &amp;&amp; $covswitchpropts eq "fixed"</code>
						</precond>  
						<vdef>
							<value>1.0</value>
						</vdef>
						<group>10</group>
					</attributes>
				</parameter>	
						
				<parameter ismandatory="1" type="Excl">
					<name>symdirihyperpropts</name>
					<attributes>
						<prompt>Stationary frequencies for states in standard data sets (Symdirihyperpr=)</prompt>
						<precond>
								<language>perl</language>
								<code>!$mrbayesblockquery</code>
						</precond>
							<paramfile>paramfile.txt</paramfile>
<!-- relevant only for morphological data 
						<precond>
							<language>perl</language>
							<code>$omegavaropts eq "Ny98" or "M3"</code>
						</precond> -->
						<vdef>
							<value>fixed(infinity)</value>
						</vdef>
						<vlist>
							<value>uniform</value>
							<label>uniform</label>
							<value>exponential</value>
							<label>exponential</label>
							<value>fixed</value>
							<label>fixed</label>
							<value>fixed(infinity)</value>
							<label>fixed (infinity)</label>
						</vlist>
						<flist>
							<value>uniform</value>
							<code>"prset symdirihyperpr = uniform($symdiruni1,$symdiruni2)\\n"</code>
							<value>exponential</value>
							<code>"prset symdirihyperpr = exponential($symdirexp1)\\n"</code>
							<value>fixed</value>
							<code>"prset symdirihyperpr = fixed($symdirfix1)\\n"</code>
							<value>fixed (infinity)</value>
							<code>"prset symdirihyperpr = fixed(infinity)\\n"</code>
						</flist>
						<group>10</group>
						<comment>
<value>Symdirihyperpr sets the prior for the stationary frequencies of the states for morphological (standard) data. There can be as many as 10 states for standard data. However, the labelling of the states is somewhat arbitrary. For example, the state "1" for different characters does not have the same meaning. This is not true for DNA characters, for example, where a "G" has the same meaning across characters. The fact that the labelling of morphological characters is arbitrary makes it difficult to allow unequal character state frequencies. MrBayes gets around this problem by assuming that the states have a dirichlet prior, with all states having equal frequency. The variation in the dirichlet can be controlled by this parameter--symdirihyperpr.Symdirihyperpr specifies the distribution on the variance parameter of the dirichlet. Valid options are uniform, exponential, fixed with an explicit rate value, and fixed(infinity). "Fixed(infinity)" fixes the dirichlet prior such that all character states have equal frequency.
</value>
						</comment>
					</attributes>
				</parameter>
				
				<parameter type="Float">
					<name>symdiruni1</name>
					<attributes>
						<prompt>Stationary Frequency Uniform Param 1</prompt>
						<format>
							<language>perl</language>
							<code>""</code>
						</format>
						<precond>
							<language>perl</language>
							<code>!$mrbayesblockquery &amp;&amp; $symdirihyperpropts eq "uniform"</code>
						</precond>  
						<vdef>
							<value>1.0</value>
						</vdef>
						<group>10</group>
					</attributes>
				</parameter>
				
				<parameter type="Float">
					<name>symdiruni2</name>
					<attributes>
						<prompt>Stationary Frequency Uniform Param 2</prompt>
						<format>
							<language>perl</language>
							<code>""</code>
						</format>
						<precond>
							<language>perl</language>
							<code>!$mrbayesblockquery &amp;&amp; $symdirihyperpropts eq "uniform"</code>
						</precond>  
						<vdef>
							<value>1.0</value>
						</vdef>
						<group>10</group>
					</attributes>
				</parameter>
				
				<parameter type="Float">
					<name>symdirexp1</name>
					<attributes>
						<prompt>Stationary Frequency Exponential Param 1</prompt>
						<format>
							<language>perl</language>
							<code>""</code>
						</format>
						<precond>
							<language>perl</language>
							<code>!$mrbayesblockquery &amp;&amp; $symdirihyperpropts eq "exponential"</code>
						</precond>  
						<vdef>
							<value>1.0</value>
						</vdef>
						<group>10</group>
					</attributes>
				</parameter>
				
				<parameter type="Float">
					<name>symdirfix1</name>
					<attributes>
						<prompt>Stationary Frequency Fixed Param 1</prompt>
						<format>
							<language>perl</language>
							<code>""</code>
						</format>
						<precond>
							<language>perl</language>
							<code>!$mrbayesblockquery &amp;&amp; $symdirihyperpropts eq "fixed"</code>
						</precond>  
						<vdef>
							<value>1.0</value>
						</vdef>
						<group>10</group>
					</attributes>
				</parameter>	
				
				<parameter ismandatory="1" type="Excl">
					<name>topologypropts</name>
					<attributes>
						<prompt>Specify Topological Constraint Types (Topologypr=)</prompt>
							<paramfile>paramfile.txt</paramfile>
						<precond>
							<language>perl</language>
							<code>!$mrbayesblockquery &amp;&amp; $noconstraints &gt;= 1</code>
						</precond>
						<vdef>
							<value>uniform</value>
						</vdef>
						<vlist>
							<value>uniform</value>
							<label>uniform</label>
							<value>constraints</value>
							<label>constraints</label>
						</vlist>
						<flist>
							<value>uniform</value>
							<code>"prset topologypr = uniform\\n"</code>
							<value>constraints</value>
							<code>"prset topologypr = constraints($constraintnames)\\n"</code>
						</flist>
						<group>10</group>
						<comment>
<value>This parameter specifies the prior probabilities of phylogenies. The options are uniform constraints If the prior is selected to be "uniform" all possible trees are considered a priori equally probable. The constraints option allows you to specify complicated prior probabilities on trees (constraints are discussed more fully in "help constraint"). Note  that you must specify a list of constraints that you wish to be obeyed. The list can be either the constraint's number or its name. Also, note that the constraints simply tell you how much more (or less) probable individual trees are that possess the constraint than trees not possessing the constraint.                                    
</value>
						</comment>
					</attributes>
				</parameter>
				
				<parameter type="String">
				<name>constraintnames1</name>
				<attributes>
					<prompt>Enter the names or numbers of the constraints to be used, separated by commas</prompt>
					<precond>
						<language>perl</language>
						<code>!$mrbayesblockquery &amp;&amp; $topologypropts eq "constraints"</code>
					</precond>
					<format>
						<language>perl</language>
						<code>""</code>
					</format>
					<group>10</group>
				</attributes>
			</parameter>
			
				<parameter ismandatory="1" type="Excl">
					<name>brlenspropts</name>
					<attributes>
						<prompt>Probability distribution on branch lengths (Brlenspr=)</prompt>
						<precond>
								<language>perl</language>
								<code>!$mrbayesblockquery</code>
						</precond>
							<paramfile>paramfile.txt</paramfile>
<!-- relevant only for morphological data 
						<precond>
							<language>perl</language>
							<code>$omegavaropts eq "Ny98" or "M3"</code>
						</precond> -->
						<vdef>
							<value>unconstrained:exponential</value>
						</vdef>
						<vlist>
							<value>unconstrained:uniform</value>
							<label>unconstrained:uniform</label>
							<value>unconstrained:exponential</value>
							<label>unconstrained:exponential</label>
							<value>clock:uniform</value>
							<label>clock:uniform</label>
							<value>clock:birthdeath</value>
							<label>clock:birthdeath</label>
							<value>clock:coalescence</value>
							<label>clock:coalescence</label>
						</vlist>
						<flist>
							<value>unconstrained:uniform</value>
							<code>"prset brlenspr = unconstrained:uniform(0,$brlenspruni2)\\n"</code>
							<value>unconstrained:exponential</value>
							<code>"prset brlenspr = unconstrained:exponential($brlensprexp1)\\n"</code>
							<value>clock:uniform</value>
							<code>"prset brlenspr = clock:uniform\\n"</code>
							<value>clock:birthdeath</value>
							<code>"prset brlenspr = clock:birthdeath\\n"</code>
							<value>clock:coalescence</value>
							<code>"prset brlenspr = clock:coalescence\\n"</code>
						</flist>
						<group>10</group>
						<comment>
<value>Brlenspr specifies the prior probability distribution on branch lengths. The options are unconstrained:uniform, unconstrained:exponential, clock:uniform, clock:birthdeath, clock:coalescence. Trees with unconstrained branch lengths are unrooted whereas clock-constrained trees are rooted. The option after the colon specifies the details of the probability density of branch lengths. If you choose a birth-death or coalescence prior, you may want to modify the details of the parameters of those processes.
</value>
						</comment>
					</attributes>
				</parameter>
				
				<parameter ishidden="1" type="Integer">
					<name>brlenspruni1</name>
					<attributes>
						<prompt>Unconstrained Uniform Param 1 is set at 0</prompt>
						<precond>
								<language>perl</language>
								<code>!$mrbayesblockquery &amp;&amp; $brlenspropts eq "uniform"</code>
						</precond>
					</attributes>
				</parameter>
				
				<parameter type="Float">
					<name>brlenspruni2</name>
					<attributes>
						<prompt>Unconstrained Uniform Param 2</prompt>
						<format>
							<language>perl</language>
							<code>""</code>
						</format>
						<precond>
							<language>perl</language>
							<code>!$mrbayesblockquery &amp;&amp; $brlenspropts eq "uniform"</code>
						</precond>  
						<vdef>
							<value>1.0</value>
						</vdef>
						<group>10</group>
					</attributes>
				</parameter>
				
				<parameter type="Float">
					<name>brlensprexp1</name>
					<attributes>
						<prompt>Unconstrained Exponential Param</prompt>
						<format>
							<language>perl</language>
							<code>""</code>
						</format>
						<precond>
							<language>perl</language>
							<code>!$mrbayesblockquery &amp;&amp; $brlenspropts eq "unconstrained:exponential"</code>
						</precond>  
						<vdef>
							<value>10.0</value>
						</vdef>
						<group>10</group>
					</attributes>
				</parameter>
				
				<parameter ismandatory="1" type="Excl">
					<name>treeheightpropts</name>
					<attributes>
						<prompt>Distribution on Tree Height (for Clock Models) (Treeheightpr=)</prompt>
						<precond>
								<language>perl</language>
								<code>!$mrbayesblockquery</code>
						</precond>
							<paramfile>paramfile.txt</paramfile>
				<!--		<precond>
							<language>perl</language>
							<code>$brlenspropts eq "clock:birthdeath" || $brlenspropts eq "clock:uniform"</code>
						</precond> -->
						<vdef>
							<value>unconstrained:exponential</value>
						</vdef>
						<vlist>
							<value>gamma</value>
							<label>gamma</label>
							<value>exponential</value>
							<label>exponential</label>
						</vlist>
						<flist>
							<value>gamma</value>
							<code>"prset treeheightpr = gamma($treeheightsprgamma1,$treeheightsprgamma2)\\n"</code>
							<value>exponential</value>
							<code>"prset treeheightpr = exponential($treeheightsprexp1)\\n"</code>
						</flist>
						<group>10</group>
						<comment>
<value>Treeheightpr specifies the prior probability distribution on the tree height, when a clock model is specified. The options are gamma and exponential. (And, yes, we know the exponential is a special case of the gamma distribution.) The tree height is the expected number of substitutions on a single branch that extends from the root of the tree to the tips. This parameter  does not come into play for the coalescence prior. It insures that the prior probability distribution for unconstrained and birth-death models is proper.               
</value>
						</comment>
					</attributes>
				</parameter>
				
				<parameter type="Float">
					<name>treeheightsprgamma1</name>
					<attributes>
						<prompt>Gamma Param 1</prompt>
						<format>
							<language>perl</language>
							<code>""</code>
						</format>
						<precond>
							<language>perl</language>
							<code>!$mrbayesblockquery &amp;&amp; $treeheightpropts eq "gamma"</code>
						</precond>  
						<vdef>
							<value>1.0</value>
						</vdef>
						<group>10</group>
					</attributes>
				</parameter>
				
				<parameter type="Float">
					<name>treeheightsprgamma2</name>
					<attributes>
						<prompt>Unconstrained Uniform Param 2</prompt>
						<precond>
							<language>perl</language>
							<code>!$mrbayesblockquery &amp;&amp; $treeheightpropts eq "gamma"</code>
						</precond> 
						<format>
							<language>perl</language>
							<code>""</code>
						</format> 
						<vdef>
							<value>1.0</value>
						</vdef>
						<group>10</group>
					</attributes>
				</parameter>
				
				<parameter type="Float">
					<name>treeheightsprexp1</name>
					<attributes>
						<prompt>Unconstrained Exponential Param</prompt>
						<precond>
							<language>perl</language>
							<code>!$mrbayesblockquery &amp;&amp; $treeheightpropts eq "exponential"</code>
						</precond>  
						<format>
							<language>perl</language>
							<code>""</code>
						</format>
						<vdef>
							<value>1.0</value>
						</vdef>
						<group>10</group>
					</attributes>
				</parameter>
				
				<parameter ismandatory="1" type="Excl">
					<name>ratepropts</name>
					<attributes>
						<prompt>Site Specific Rates Models (Ratespr=)</prompt>
							<paramfile>paramfile.txt</paramfile>
							<precond>
								<language>perl</language>
								<code>!$mrbayesblockquery</code>
							</precond>
<!--		Conditional upon the activation of various partitions using the set command			<precond>
							<language>perl</language>
							<code>$brlenspropts eq "clock:birthdeath" || "clock:uniform"</code>
						</precond> -->
						<vdef>
							<value>fixed</value>
						</vdef>
						<vlist>
							<value>fixed</value>
							<label>fixed</label>
							<value>variable</value>
							<label>variable</label>
<!--		not ready for this yet					<value>dirichlet</value>
							<label>dirichlet</label> -->
						</vlist>
						<flist>
							<value>fixed</value>
							<code>"prset ratepr = fixed\\n"</code>
							<value>variable</value>
							<code>"prset ratepr = variable\\n"</code>
<!--		not ready for this yet					<value>dirichlet</value>
							<code>"ratepr = dirichlet($rateprdir1,etc..)\\n"</code> -->
						</flist>
						<group>10</group>
						<comment>
<value>Ratepr specifies the site specific rates model. First, you must have defined a partition of the characters. For example, you may define a partition that divides the characters by codon position, if you have DNA data. Second, you must make that partition the active one using the set command. For example, if your partition is called "by_codon", then you make that the active partition using "set partition=by_codon". Now that you have defined and activated a partition, you can specify the rate multipliers for the various partitions. The options are fixed, variable, and dirichlet. For "fixed" the rate multiplier for  that partition is set to 1 (i.e., the rate is fixed to the average rate across partitions). On the other hand, for "variable", the rate is allowed to vary across partitions subject to the constraint that the average rate of substitution across the partitions is 1. You must specify a variable rate prior for at least twopartitions, otherwise the option is not activated when calculating likelihoods. The variable option automatically associates the partition rates with a dirichlet(1,...,1) prior. The dirichlet option is an alternative way of setting a partition rate to be variable, and also gives accurate control of the shape of the prior. The parameters of the Dirichlet are listed in the order of the partitions that the ratepr is applied to. For instance, "prset applyto=(1,3,4)ratepr = dirichlet(10,40,15)" would set the Dirichlet parameter 10 to partition 1, 40 to partition 3, and 15 to partition 4.
</value>
						</comment>
					</attributes>
				</parameter>
				
				<parameter ismandatory="1" type="Excl">
					<name>speciationpropts</name>
					<attributes>
						<prompt>Speciation Rate (for Birth:Death Clock Models) (Speciationpr=)</prompt>
							<paramfile>paramfile.txt</paramfile>
						<precond>
							<language>perl</language>
							<code>!$mrbayesblockquery &amp;&amp; $brlenspropts eq "clock:birthdeath"</code>
						</precond>
						<vdef>
							<value>uniform</value>
						</vdef>
						<vlist>
							<value>uniform</value>
							<label>uniform</label>
							<value>exponential</value>
							<label>exponential</label>
							<value>fixed</value>
							<label>fixed</label>
						</vlist>
						<flist>
							<value>uniform</value>
							<code>"prset speciationpr = uniform($speciationpruni1,$speciationpruni2)\\n"</code>
							<value>exponential</value>
							<code>"prset speciationpr = exponential($speciationprexp1)\\n"</code>
							<value>fixed</value>
							<code>"prset speciationpr = fixed($speciationprfix1)\\n"</code>
						</flist>
						<group>10</group>
						<comment>
<value>Speciationpr  sets the prior on the speciation rate. The options are uniform, exponential, and fixed. This parameter is only relevant if the birth-death  process is selected as the prior on branch lengths.
</value>
						</comment>
					</attributes>
				</parameter>
				
				<parameter type="Float">
					<name>speciationpruni1</name>
					<attributes>
						<prompt>Speciationpr Uniform Param 1</prompt>
						<format>
							<language>perl</language>
							<code>""</code>
						</format>
						<precond>
							<language>perl</language>
							<code>!$mrbayesblockquery &amp;&amp; $speciationpropts eq "uniform"</code>
						</precond>  
						<vdef>
							<value>0.0</value>
						</vdef>
						<group>10</group>
					</attributes>
				</parameter>
				
				<parameter type="Float">
					<name>speciationpruni2</name>
					<attributes>
						<prompt>Speciationpr Uniform Param 2</prompt>
						<precond>
							<language>perl</language>
							<code>!$mrbayesblockquery &amp;&amp; $speciationpropts eq "uniform"</code>
						</precond> 
						<format>
							<language>perl</language>
							<code>""</code>
						</format> 
						<vdef>
							<value>10.0</value>
						</vdef>
			<!--  	 	<ctrls>
							<ctrl>
								<message>For the uniform option, the first value must be less than the second</message>
								<language>perl</language>
								<code>$speciationpruni1 &gt; $value</code>
							</ctrl>
						</ctrls>	-->
						<group>10</group>
					</attributes>
				</parameter>
				
				<parameter type="Float">
					<name>speciationprexp1</name>
					<attributes>
						<prompt>Speciationpr Exponential Param</prompt>
						<format>
							<language>perl</language>
							<code>""</code>
						</format>
						<precond>
							<language>perl</language>
							<code>!$mrbayesblockquery &amp;&amp; $speciationpropts eq "exponential"</code>
						</precond>  
						<vdef>
							<value>1.0</value>
						</vdef>
						<group>10</group>
					</attributes>
				</parameter>
				
				<parameter type="Float">
					<name>speciationprfix1</name>
					<attributes>
						<prompt>Speciationpr Fixed Param</prompt>
						<format>
							<language>perl</language>
							<code>""</code>
						</format>
						<precond>
							<language>perl</language>
							<code>!$mrbayesblockquery &amp;&amp; $speciationpropts eq "fixed"</code>
						</precond>  
						<vdef>
							<value>1.0</value>
						</vdef>
						<group>10</group>
					</attributes>
				</parameter>
				
				<parameter ismandatory="1" type="Excl">
					<name>extinctionpropts</name>
					<attributes>
						<prompt>Extinction Rate (for Birth:Death Clock Models) (Extinctionpr=)</prompt>
							<paramfile>paramfile.txt</paramfile>
						<precond>
							<language>perl</language>
							<code>!$mrbayesblockquery &amp;&amp; $brlenspropts eq "clock:birthdeath"</code>
						</precond>
						<vdef>
							<value>uniform</value>
						</vdef>
						<vlist>
							<value>uniform</value>
							<label>uniform</label>
							<value>exponential</value>
							<label>exponential</label>
							<value>fixed</value>
							<label>fixed</label>
						</vlist>
						<flist>
							<value>uniform</value>
							<code>"prset extinctionpr = uniform($extinctionpruni1,$extinctionpruni2)\\n"</code>
							<value>exponential</value>
							<code>"prset extinctionpr = exponential($extinctionprexp1)\\n"</code>
							<value>fixed</value>
							<code>"prset extinctionpr = fixed($extinctionprfix1)\\n"</code>
						</flist>
						<group>10</group>
						<comment>
<value>Extinctionpr sets the prior on the extinction rate. Valid options are uniform, exponential, and fixed.This parameter is only relevant if the birth-death process is selected as the prior on branch lengths. 
</value>
						</comment>
					</attributes>
				</parameter>
				
				<parameter type="Float">
					<name>extinctionpruni1</name>
					<attributes>
						<prompt>Extinctionpr Uniform Param 1</prompt>
						<format>
							<language>perl</language>
							<code>""</code>
						</format>
						<precond>
							<language>perl</language>
							<code> !$mrbayesblockquery &amp;&amp; $extinctionpropts eq "uniform"</code>
						</precond>  
						<vdef>
							<value>0.0</value>
						</vdef>
						<group>10</group>
					</attributes>
				</parameter>
				
				<parameter type="Float">
					<name>extinctionpruni2</name>
					<attributes>
						<prompt>Extinctionpr Uniform Param 2</prompt>
						<precond>
							<language>perl</language>
							<code>!$mrbayesblockquery &amp;&amp; $extinctionpropts eq "uniform"</code>
						</precond>  
						<format>
							<language>perl</language>
							<code>""</code>
						</format>
						<vdef>
							<value>10.0</value>
						</vdef>
				<!--  		<ctrls>
							<ctrl>
								<message>For the uniform option, the first value must be less than the second</message>
								<language>perl</language>
								<code>$extinctionpruni1 &gt; $value</code>
							</ctrl>
						</ctrls> -->
						<group>10</group>
					</attributes>
				</parameter>
				
				<parameter type="Float">
					<name>extinctionprexp1</name>
					<attributes>
						<prompt>Extinctionpr Exponential Param</prompt>
						<precond>
							<language>perl</language>
							<code>!$mrbayesblockquery &amp;&amp; $extinctionpropts eq "exponential"</code>
						</precond>  
						<format>
							<language>perl</language>
							<code>""</code>
						</format>
						<vdef>
							<value>1.0</value>
						</vdef>
						<group>10</group>
					</attributes>
				</parameter>
				
				<parameter type="Float">
					<name>extinctionprfix1</name>
					<attributes>
						<prompt>Extinctionpr Fixed Param</prompt>
						<format>
							<language>perl</language>
							<code>""</code>
						</format>
						<precond>
							<language>perl</language>
							<code>!$mrbayesblockquery &amp;&amp; $extinctionpropts eq "fixed"</code>
						</precond>  
						<vdef>
							<value>1.0</value>
						</vdef>
						<group>10</group>
					</attributes>
				</parameter>
				
				<parameter type="Float">
					<name>sampleprobopts</name>
					<attributes>
						<prompt>Fraction of Species Samples in Birth Death Analysis (SampleprobExtinctionpr=)</prompt>
							<paramfile>paramfile.txt</paramfile>
						<precond>
							<language>perl</language>
							<code>!$mrbayesblockquery &amp;&amp; $brlenspropts eq "clock:birthdeath"</code>
						</precond>
						<format>
							<language>perl</language>
							<code>"prset sampleprob = $value\\n"</code>
						</format>
						<vdef>
							<value>1.0</value>
						</vdef>
				<!--  		 <ctrls>
							<ctrl>
								<message>Please Enter a Value Greater than 0 and Less Than 1.0</message>
								<language>perl</language>
								<code>$value &lt;= 1 || $value &gt; 0</code>
							</ctrl>
						</ctrls> -->
						<group>10</group>
						<comment>
<value>Sampleprob sets the fraction of species that are sampled in the analysis. This is used with the birth death prior on trees (see Yang and Rannala, 1997).            
</value>
						</comment>
					</attributes>
				</parameter>	
				
				<parameter ismandatory="1" type="Excl">
					<name>thetapropts</name>
					<attributes>
						<prompt>Prior on the coalescence parameter (nucleic acid data) (Thetapr=)</prompt>
							<paramfile>paramfile.txt</paramfile>
						<precond>
							<language>perl</language>
							<code>!$mrbayesblockquery &amp;&amp; $brlenspropts eq "clock:coalescence"</code>
						</precond>
						<vdef>
							<value>uniform</value>
						</vdef>
						<vlist>
							<value>uniform</value>
							<label>uniform</label>
							<value>exponential</value>
							<label>exponential</label>
							<value>fixed</value>
							<label>fixed</label>
						</vlist>
						<flist>
							<value>uniform</value>
							<code>"prset thetapr = uniform($thetapruni1,$thetapruni2)\\n"</code>
							<value>exponential</value>
							<code>"prset thetapr = exponential($thetaprexp1)\\n"</code>
							<value>fixed</value>
							<code>"prset thetapr = fixed($thetaprfix1)\\n"</code>
						</flist>
						<group>10</group>
						<comment>
<value>Thetapr sets the prior on the coalescence parameter. This parameter is only relevant if the coalescence process is selected as the prior on branch lengths.           
</value>
						</comment>
					</attributes>
				</parameter>
				
				<parameter type="Float">
					<name>thetapruni1</name>
					<attributes>
						<prompt>Thetapr Uniform Param 1</prompt>
						<format>
							<language>perl</language>
							<code>""</code>
						</format>
						<precond>
							<language>perl</language>
							<code>!$mrbayesblockquery &amp;&amp; $extinctionpropts eq "uniform"</code>
						</precond>  
						<vdef>
							<value>0.0</value>
						</vdef>
						<group>10</group>
					</attributes>
				</parameter>
				
				<parameter type="Float">
					<name>thetapruni2</name>
					<attributes>
						<prompt>Thetapr Uniform Param 2</prompt>
						<precond>
							<language>perl</language>
							<code>!$mrbayesblockquery &amp;&amp; $extinctionpropts eq "uniform"</code>
						</precond>
						<format>
							<language>perl</language>
							<code>""</code>
						</format>  
						<vdef>
							<value>10.0</value>
						</vdef>
			<!--  		<ctrls>
							<ctrl>
								<message>For the uniform option, the first value must be less than the second</message>
								<language>perl</language>
								<code>$extinctionpruni1 &gt; $value</code>
							</ctrl>
						</ctrls> -->	
						<group>10</group>
					</attributes>
				</parameter>
				
				<parameter type="Float">
					<name>thetaprexp1</name>
					<attributes>
						<prompt>Thetapr Exponential Param</prompt>
						<format>
							<language>perl</language>
							<code>""</code>
						</format>
						<precond>
							<language>perl</language>
							<code>!$mrbayesblockquery &amp;&amp; $thetapropts eq "exponential"</code>
						</precond>  
						<vdef>
							<value>1.0</value>
						</vdef>
						<group>10</group>
					</attributes>
				</parameter>
				
				<parameter type="Float">
					<name>thetaprfix1</name>
					<attributes>
						<prompt>Thetapr Fixed Param</prompt>
						<format>
							<language>perl</language>
							<code>""</code>
						</format>
						<precond>
							<language>perl</language>
							<code>!$mrbayesblockquery &amp;&amp; $thetapropts eq "fixed"</code>
						</precond>  
						<vdef>
							<value>1.0</value>
						</vdef>
						<group>10</group>
					</attributes>
				</parameter>
				
			</parameters>
			
		</paragraph>
	</parameter>

<parameter type="Paragraph">
	<paragraph>
		<name>datamodifications</name>
		<prompt>Data Specifications</prompt>
<!--		<precond>
						<language>perl</language>
						<code>!$mrbayesblockquery</code>
		</precond> -->
			<parameters>

			<parameter type="String">
					<name>databreaksopts</name>
					<attributes>
						<paramfile>paramfile.txt</paramfile>
						<prompt>Specify Breaks in Sequence Data (Protein and Nucleic Acid Data only)</prompt>
						<precond>
								<language>perl</language>
								<code>!$mrbayesblockquery</code>
							</precond>
						<format>
							<language>perl</language>
							<code>"databreaks $value</code>
						</format>
						<group>20</group>
						<comment>
<value>The Databreaks command is used to specify breaks in the input data matrix. Some of the models (e.g. autocorrelated gamma model) implemented by MrBayes account for nonindependence at adjacent characters. Databreaks option specifies that two sites that are adjacent in the matrix, are actually separated by many kilobases or megabases in the genome. For example, say you have a data matrix of 3204 characters that include nucleotide data from three genes that are physically unlinked. The first gene covers characters 1 to 970, the second gene covers characters 971 to 2567, and the third gene covers characters 2568 to 3204. Just enter the last number of the contiuous sequnce, in this case, 970 and 2567, separated by spaces.
</value>
						</comment>
					</attributes>
			</parameter>
			
			<parameter type="String">
					<name>pairsopts</name>
					<attributes>
						<prompt>Specify nucleotide pairs involved in Watson-Crick pairing (pairs nucmodel=doublet only)</prompt>
						<paramfile>paramfile.txt</paramfile>
						<precond>
							<language>perl</language>
							<code>!$mrbayesblockquery &amp;&amp; $nucmodelopts eq "doublet"</code>
						</precond>
						<format>
							<language>perl</language>
							<code>"pairs $value\\n"</code>
						</format>
						<group>20</group>
						<comment>
<value>The Pairs command is used to specify pairs of nucleotides. For example, RNA sequences with a known secondary structure of stems and loops. Substitutions in nucleotides involved in a Watson-Crick pairing in stems are not strictly independent; a change in one changes the probability of a change in the partner. A solution to this problem is to expand the model around the pair of nucleotides in the stem. Pairs allows you to do this. The correct usage is to enter the numbers of a base-pairforming nucleotide pair, separated by a semicolon: for example:30:56. To include multiplepairs, separate the enteredvalues by commas: 31:55, 32:54, 33:53, 34:52, 35:51, 36:50. This specifies pairings between nucleotides 30 and 56, 31 and 55, etc. Onlynucleotide data (DNA or RNA) may be paired using this command. Note that in order for the program to actually implement a "doublet" model involving a 16 X 16 rate matrix, you must specify that the structure of        
the model is 16 X 16 using "lset nucmodel=doublet".
</value>
						</comment>
					</attributes>
			</parameter>
			
<!-- this setup doesnt yet allow the user to enter a range of values, it just allows the user to provide one. This can be fixed, if needed. But for now, specifying this parameter entry on the nexus file is much faster.
			<parameter ismandatory="1" type="Excl">
					<name>ctypeopts</name>
					<attributes>
						<prompt>Ctype ordering specifier</prompt>
						<vlist>
							<value>unordered:</value>
							<label>unordered</label>
							<value>ordered:</value>
							<label>ordered</label>
							<value>irreversible:</value>
							<label>irreversible</label>
						</vlist>
						<group>20</group>
						<comment>
<value>Ctype sets the character ordering for standard-type data, usage is: ctype &lt;ordering&gt;:&lt;characters&gt; Ordering options are: unordered-movement directly from one state to another is allowed in an instant of time. ordered - movement is only allowed between adjacent characters, for example, between 0 &gt;-&lt; 1 and 1 &lt;-&gt; 2 for a three state character ordered as 0 - 1 - 2. irreversible - rates of change for losses are 0. The characters to which the ordering is applied is specified in manner that is identical to commands such as "include" or "exclude". For example, ctype ordered: 10 23 45  defines characters 10, 23, and 45 to be of type ordered. Similarly, ctype irreversible: 54-67  71-92 defines characters 54 to 67 and characters 71 to 92 to be of type irreversible. You can use the "." to denote the last character, and "all" to denote all of the characters. Finally, you can use the specifier "\" to apply the ordering to every n-th character or you can use predefined charsets to specify the character. Only one ordering can be used on any specific application of ctype. If you want to apply different orderings to different characters, then you need to use ctype multiple times. For example, ctype ordered: 1-50  ctype irreversible: 51-100 sets characters 1 to 50 to be ordered and characters 51 to 100 to be irreversible. The ctype command is only sensible with morphological (here called "standard") characters. The program ignores attempts to apply character orderings to other types of characters, such as DNA characters.          
</value>
						</comment>
					</attributes>
			</parameter> 

			<parameter type="String">
				<name>ctype1range</name>
					<attributes>
						<prompt>Ctype range</prompt>
						<format>
							<language>perl</language>
							<code>(defined $value )? " ctype $ctypeopts = $value" : \\n""</code>
						</format>
						<group>20</group>
					</attributes>
			</parameter> -->
			
		</parameters>
		
	</paragraph>
</parameter>


<parameter type="Paragraph">
	<paragraph>
		<name>Charset</name>
		<prompt>Character Sets</prompt>
<!--		<precond>
			<language>perl</language>
			<code>!$mrbayesblockquery</code>
		</precond> -->
		<parameters>
			
			<parameter type="Excl">
				<name>nocharsets</name>
				<attributes>
					<prompt>How many character sets would you like to define? See the note below.</prompt>
					<precond>
						<language>perl</language>
						<code>!$mrbayesblockquery</code>
					</precond>
					<paramfile>paramfile.txt</paramfile>
					
					<format>
						<language>perl</language>
						<code>""</code>
					</format>
					<vlist>
					<value>0</value>
					<label>0</label>
					<value>1</value>
					<label>1</label>
					<value>2</value>
					<label>2</label>
					<value>3</value>
					<label>3</label>
					<value>4</value>
					<label>4</label>
					<value>5</value>
					<label>5</label>
					<value>6</value>
					<label>6</label>
					<value>7</value>
					<label>7</label>
					<value>8</value>
					<label>8</label>
					</vlist>
					<vdef>
						<value>0</value>
					</vdef>
		<!--			<ctrls>
						<ctrl>
							<message>The number of character sets must be between 1 and 8. See the note below.</message>
							<language>perl</language>
							<code>$value &gt; 8 || $value &lt; 1</code>
						</ctrl>
					</ctrls>-->
					<group>30</group>
					<comment>
						<value>You can specify up to 8 character sets here. You can experiment here, but if you get serious, you should really do this in the MrBayes Command block of a Nexus file. For more information see the help section below.</value>
					</comment>
				</attributes>
			</parameter>
			
			<parameter type="String">
				<name>charset1</name>
				<attributes>
					<prompt>Name for character set 1</prompt>
					<paramfile>paramfile.txt</paramfile>
					<precond>
						<language>perl</language>
						<code>!$mrbayesblockquery &amp;&amp; $nocharsets &gt;= 1</code>
					</precond>
					<format>
						<language>perl</language>
						<code>""</code>
					</format>
					<group>30</group>
					<comment>
<value>Charset defines a character set. You must specify the name of the charset you wish to create, and the first and last positions of that set. Both parameters are entered into the forms
provided, for up to 8 charsets.  The character set name is entered in the frst box; it cannot have any spaces in it. The character range is entered second, you enter the first character position, and last charcer position, separated by a hyphen. You can use "." to indicate the last character. In addition, the forward slash (\)  can be used to tell the program to assign every third (or second, or fifth, or whatever) character to the character set. For example, "charset first_pos = 1-720\3" defines a character set called "first_pos" that includes every third site from 1 to 720.             
</value>
					</comment>
				</attributes>
			</parameter>
			
			<parameter type="String">
				<name>charset1range</name>
					<attributes>
						<prompt>Character set 1 range</prompt>
						<precond>
							<language>perl</language>
							<code>!$mrbayesblockquery &amp;&amp; $nocharsets &gt;= 1</code>
						</precond>
						<paramfile>paramfile.txt</paramfile>
						<format>
							<language>perl</language>
							<code>(defined $value )? " charset $charset1 = $value\\n": ""</code>
						</format>
						<group>30</group>
					</attributes>
			</parameter>
			
			<parameter type="String">
				<name>charset2</name>
				<attributes>
					<prompt>Name for character set 2</prompt>
					<paramfile>paramfile.txt</paramfile>
					<precond>
						<language>perl</language>
						<code>!$mrbayesblockquery &amp;&amp; $nocharsets &gt;= 2</code>
					</precond>
					<format>
						<language>perl</language>
						<code>""</code>
					</format>
					<group>30</group>
				</attributes>
			</parameter>
			
			<parameter type="String">
				<name>charset2range</name>
					<attributes>
						<prompt>Character set 2 range</prompt>
						<precond>
							<language>perl</language>
							<code>!$mrbayesblockquery &amp;&amp; $nocharsets &gt;= 2</code>
						</precond>
						<paramfile>paramfile.txt</paramfile>
						<format>
							<language>perl</language>
							<code>(defined $value )? " charset $charset2 = $value\\n" : ""</code>
						</format>
						<group>30</group>
					</attributes>
			</parameter>
			
			<parameter type="String">
				<name>charset3</name>
				<attributes>
					<prompt>Name for character set 3</prompt>
					<paramfile>paramfile.txt</paramfile>					
					<precond>
						<language>perl</language>
						<code>!$mrbayesblockquery &amp;&amp; $nocharsets &gt;= 3</code>
					</precond>
					<format>
						<language>perl</language>
						<code>""</code>
					</format>
					<group>30</group>
				</attributes>
			</parameter>
			
			<parameter type="String">
				<name>charset3range</name>
					<attributes>
						<prompt>Character set 3 range</prompt>
						<precond>
							<language>perl</language>
							<code>!$mrbayesblockquery &amp;&amp; $nocharsets &gt;= 3</code>
						</precond>
						<paramfile>paramfile.txt</paramfile>
						<format>
							<language>perl</language>
							<code>(defined $value )? " charset $charset3 = $value\\n" : ""</code>
						</format>
						<group>30</group>
					</attributes>
			</parameter>
			
			<parameter type="String">
				<name>charset4</name>
				<attributes>
					<prompt>Name for character set 4</prompt>
					<paramfile>paramfile.txt</paramfile>
					<precond>
						<language>perl</language>
						<code>!$mrbayesblockquery &amp;&amp; $nocharsets &gt;= 4</code>
					</precond>
					<format>
						<language>perl</language>
						<code>""</code>
					</format>
					<group>30</group>
				</attributes>
			</parameter>
			
			<parameter type="String">
				<name>charset4range</name>
					<attributes>
						<prompt>Character set 4 range</prompt>
						<precond>
							<language>perl</language>
							<code>!$mrbayesblockquery &amp;&amp; $nocharsets &gt;= 4</code>
						</precond>
						<paramfile>paramfile.txt</paramfile>
						<format>
							<language>perl</language>
							<code>(defined $value )? " charset $charset4 = $value\\n" : ""</code>
						</format>
						<group>30</group>
					</attributes>
			</parameter>
			
			<parameter type="String">
				<name>charset5</name>
				<attributes>
					<prompt>Name for character set 5</prompt>
					<precond>
						<language>perl</language>
						<code>!$mrbayesblockquery &amp;&amp; $nocharsets &gt;= 5</code>
					</precond>
					<format>
						<language>perl</language>
						<code>""</code>
					</format>
					<group>30</group>
				</attributes>
			</parameter>
			
			<parameter type="String">
				<name>charset5range</name>
					<attributes>
						<prompt>Character set 5 range</prompt>
						<precond>
							<language>perl</language>
							<code>!$mrbayesblockquery &amp;&amp; $nocharsets &gt;= 5</code>
						</precond>
						<paramfile>paramfile.txt</paramfile>
						<format>
							<language>perl</language>
							<code>(defined $value )? " charset $charset5 = $value\\n" : ""</code>
						</format>
						<group>30</group>
					</attributes>
			</parameter>
			
			<parameter type="String">
				<name>charset6</name>
				<attributes>
					<prompt>Name for character set 6</prompt>
					<precond>
						<language>perl</language>
						<code>!$mrbayesblockquery &amp;&amp; $nocharsets &gt;= 6</code>
					</precond>
					<format>
						<language>perl</language>
						<code>""</code>
					</format>
					<group>30</group>
				</attributes>
			</parameter>
			
			<parameter type="String">
				<name>charset6range</name>
					<attributes>
						<prompt>Character set 6 range</prompt>
						<precond>
							<language>perl</language>
							<code>!$mrbayesblockquery &amp;&amp; $nocharsets &gt;= 6</code>
						</precond>
						<paramfile>paramfile.txt</paramfile>
						<format>
							<language>perl</language>
							<code>(defined $value )? " charset $charset6 = $value\\n" : ""</code>
						</format>
						<group>30</group>
					</attributes>
			</parameter>

			<parameter type="String">
				<name>charset7</name>
				<attributes>
					<prompt>Name for character set 7</prompt>
					<precond>
						<language>perl</language>
						<code>!$mrbayesblockquery &amp;&amp; $nocharsets &gt;= 7</code>
					</precond>
					<format>
						<language>perl</language>
						<code>""</code>
					</format>
					<group>30</group>
				</attributes>
			</parameter>
			
			<parameter type="String">
				<name>charset7range</name>
					<attributes>
						<prompt>Character set 7 range</prompt>
						<precond>
							<language>perl</language>
							<code>!$mrbayesblockquery &amp;&amp; $nocharsets &gt;= 7</code>
						</precond>
						<paramfile>paramfile.txt</paramfile>
						<format>
							<language>perl</language>
							<code>(defined $value )? " charset $charset7 = $value\\n" : ""</code>
						</format>
						<group>30</group>
					</attributes>
			</parameter>
			
			<parameter type="String">
				<name>charset8</name>
				<attributes>
					<prompt>Name for character set 8</prompt>
					<precond>
						<language>perl</language>
						<code>!$mrbayesblockquery &amp;&amp; $nocharsets &gt;= 8</code>
					</precond>
					<format>
						<language>perl</language>
						<code>""</code>
					</format>
					<group>30</group>
				</attributes>
			</parameter>
			
			<parameter type="String">
				<name>charset8range</name>
					<attributes>
						<prompt>Character set 8 range</prompt>
						<precond>
							<language>perl</language>
							<code>!$mrbayesblockquery &amp;&amp; $nocharsets &gt;= 8</code>
						</precond>
						<paramfile>paramfile.txt</paramfile>
						<format>
							<language>perl</language>
							<code>(defined $value )? " charset $charset8 = $value\\n" : ""</code>
						</format>
						<group>30</group>
					</attributes>
			</parameter>
			
			<parameter type="String">
				<name>excludeopts</name>
				<attributes>
					<prompt>Exclude these characters from the analysis </prompt>
					<precond>
								<language>perl</language>
								<code>!$mrbayesblockquery</code>
							</precond>
					<paramfile>paramfile.txt</paramfile>
					<format>
						<language>perl</language>
						<code>"exclude $value\\n"</code>
					</format>
					<group>30</group>
					<comment>
<value>Exclude removes specific character positions from the analysis. Enter one of the following into the form provided : a set of individual character position numbers separated by spaces (2, 3, 10, 11, 12, 13, 14, and 22); a range of numbers, by giving the starting and finishing position, separated by a hyphen ( 1-100 ). Note the backslah can be used to exclude every nth character (1-100\3), the name of a character set, or "all". A mixture is also allowed (2 3 10-14 22).              
</value>
					</comment>
				</attributes>
			</parameter>
			
<!-- removed 
			<parameter type="Switch">
			<name>ispartitioned</name>
			<attributes>
				<prompt>Check this switch for partitioned data</prompt>
					<format>
						<language>perl</language>
						<code>($value)? "":""</code>
					</format>
					<vdef>
						<value>0</value>
					</vdef>
					<group>30</group>
				</attributes>
			</parameter>

			<parameter type="Integer">
				<name>numberpartitions</name>
				<attributes>
					<prompt>How Many Partitions?</prompt>
					<precond>
						<language>perl</language>
						<code>$ispartitioned</code>
					</precond>
					<format>
						<language>perl</language>
						<code>($value)? "":""</code>
					</format>
					<vdef>
						<value>1</value>
					</vdef>
					<ctrls>
						<ctrl>
							<message>The web interface supports up to 4 partitions, but the MrBayes block can be used to specify an unlimited number</message>
							<language>perl</language>
							<code>$numberpartitions &gt; 4</code>
						</ctrl>
					</ctrls>
					<group>30</group>
				</attributes>
			</parameter>

			<parameter type="String">
					<name>partition1name</name>
					<attributes>
						<prompt>Name for Partition1</prompt>
						<precond>
							<language>perl</language>
							<code>$numberpartitions &gt;= 1</code>
						</precond>
						<format>
							<language>perl</language>
							<code>""</code>
						</format>
						<comment>
<value>Partition allows you to specify a character partition. You must enter a partition name the number of parts (eg charsets) in the partition, and the names or numbers of those charsets, separated by commas. The sites in each partition are defined using the charset command. You can specify a partition without using charset as follows:                           
Name: partition by_codon number of parts: 3 and then the exact positions of interest as a set of lists, defined by commas: 1 4 6 9 12,2 5 7 10 13,3 6 8 11 14.Thismight makes sense for eploration, but     
defining the partition as a line in the mrbayes block seems much more efficient. Note that the program will fail if any characters in your matrix are not assigned to one of the partitions. You must excluding characters from the analysis explicitly, using the "exclude" option. 
</value>
						</comment>
					</attributes>
			</parameter>

			<parameter type="Integer">
					<name>partition1numparts</name>
					<attributes>
						<prompt>How many charsets in Partition1</prompt>
						<precond>
							<language>perl</language>
							<code>$numberpartitions &gt;= 1</code>
						</precond>
						<format>
							<language>perl</language>
							<code>""</code>
						</format>
					</attributes>
			</parameter>

			<parameter type="String">
					<name>partition1parts</name>
					<attributes>
						<prompt>Charsets in Partition1 (enter Charset names separated by commas)</prompt>
						<precond>
							<language>perl</language>
							<code>$numberpartitions &gt;= 1</code>
						</precond>
						<format>
							<language>perl</language>
							<code>"partition $partition1name = $partition1numparts:$value\\n"</code>
						</format>
					</attributes>
			</parameter>

			<parameter type="String">
					<name>partition2name</name>
					<attributes>
						<prompt>Name for Partition2</prompt>
						<precond>
							<language>perl</language>
							<code>$numberpartitions &gt;= 2</code>
						</precond>
						<format>
							<language>perl</language>
							<code>""</code>
						</format>
					</attributes>
			</parameter>

			<parameter type="Integer">
					<name>partition2numparts</name>
					<attributes>
						<prompt>How many charsets in Partition2</prompt>
						<precond>
							<language>perl</language>
							<code>$numberpartitions &gt;= 2</code>
						</precond>
						<format>
							<language>perl</language>
							<code>""</code>
						</format>
					</attributes>
			</parameter>

			<parameter type="String">
					<name>partition2parts</name>
					<attributes>
						<prompt>Charsets in Partition2 (enter Charset names separated by commas)</prompt>
						<precond>
							<language>perl</language>
							<code>$numberpartitions &gt;= 2</code>
						</precond>
						<format>
							<language>perl</language>
							<code>"partition $partition2name = $partition2numparts:$value\\n"</code>
						</format>
					</attributes>
			</parameter>

			<parameter type="String">
					<name>partition3name</name>
					<attributes>
						<prompt>Name for Partition3</prompt>
						<precond>
							<language>perl</language>
							<code>$numberpartitions &gt;= 3</code>
						</precond>
						<format>
							<language>perl</language>
							<code>""</code>
						</format>
					</attributes>
			</parameter>

			<parameter type="Integer">
					<name>partition3numparts</name>
					<attributes>
						<prompt>How many charsets in Partition3</prompt>
						<precond>
							<language>perl</language>
							<code>$numberpartitions &gt;= 3</code>
						</precond>
						<format>
							<language>perl</language>
							<code>""</code>
						</format>
					</attributes>
			</parameter>

			<parameter type="String">
					<name>partition3parts</name>
					<attributes>
						<prompt>Charsets in Partition3 (enter Charset names separated by commas)</prompt>
						<precond>
							<language>perl</language>
							<code>$numberpartitions &gt;= 3</code>
						</precond>
						<format>
							<language>perl</language>
							<code>"partition $partition3name = $partition3numparts:$value\\n"</code>
						</format>
					</attributes>
			</parameter>

			<parameter type="String">
					<name>partition4name</name>
					<attributes>
						<prompt>Name for Partition4</prompt>
						<precond>
							<language>perl</language>
							<code>$numberpartitions &gt;= 4</code>
						</precond>
						<format>
							<language>perl</language>
							<code>""</code>
						</format>
					</attributes>
			</parameter>

			<parameter type="Integer">
					<name>partition4numparts</name>
					<attributes>
						<prompt>How many charsets in Partition4</prompt>
						<precond>
							<language>perl</language>
							<code>$numberpartitions &gt;= 4</code>
						</precond>
						<format>
							<language>perl</language>
							<code>""</code>
						</format>
					</attributes>
			</parameter>

			<parameter type="String">
					<name>partition4parts</name>
					<attributes>
						<prompt>Charsets in Partition4 (enter Charset names for this partition, separated by commas)</prompt>
						<precond>
							<language>perl</language>
							<code>$numberpartitions &gt;= 4</code>
						</precond>
						<format>
							<language>perl</language>
							<code>"partition $partition4name = $partition4numparts:$value\\n"</code>
						</format>
					</attributes>
			</parameter>

			<parameter type="String">
						<name>setpartitionpopts</name>
						<attributes>
						<precond>
							<language>perl</language>
							<code>$numberpartitions &gt;= 1</code>
						</precond>
							<prompt>Specify A Partition Scheme for the Analysis</prompt>
							<format>
								<language>perl</language>
								<code>"set partition=$value\\n"</code>
							</format>
							<comment>
<value>Set is used to override the default data partitioning. If you used "partition" to create and name a preferredpartitioning scheme, you specify use of that partition by providing the partitioning schem id or its number. You can also specify the default partition by typing set partition=default or set partition=1.
</value>
							</comment>
						</attributes>	
				</parameter> 

			<parameter ismandatory="1" type="Excl">
					<name>linkunlink</name>
					<attributes>
						<prompt>Link or unlink model parameters across all partitions?</prompt>
						<precond>
							<language>perl</language>
							<code>$ispartitioned</code>
						</precond>
						<vlist>
							<value>Link</value>
							<label>Link</label>
							<value>Unlink</value>
							<label>Unlink</label>
						</vlist>
						<format>
							<language>perl</language>
							<code>"$value $linkingopts </code>
						</format>
					</attributes>
			</parameter>

			<parameter type="List">
					<name>linkingopts</name>
					<attributes>
						<prompt>Select Model parameters to link or unlink across data partitions</prompt>
						<format>
							<language>perl</language>
							<code>"link=\"$value\"'</code>
						</format>
						<precond>
							<language>perl</language>
							<code>$ispartitioned</code>
						</precond>
						<vdef>
							<value>all</value>
						</vdef>
						<vlist>
							<value>all</value>
							<label>all</label>
							<value>Tratio</value>
							<label>Partition 1</label>
							<value>Revmat </value>
							<label>Substitution rates of GTR model</label>
							<value>Omega</value>
							<label>Nonsynonymous/synonymous rate ratio </label>
							<value>Statefreq</value>
							<label>Character state frequencie</label>
							<value>Shape</value>
							<label>Gamma shape parameter</label>
							<value>Pinvar</value>
							<label>Proportion of invariable sites</label>
							<value>Correlation</value>
							<label>Correlation parameter of autodiscrete gamma</label>
							<value>Switchrates</value>
							<label>Switching rates for covarion model</label>
							<value>Brlens</value>
							<label>Branch lengths of tree </label>
							<value>Topology</value>
							<label>Topology of tree</label>
							<value>Speciationrates</value>
							<label>Speciation rates for birth-death process</label>
							<value>Extinctionrates</value>
							<label>Extinction rates for birth-death process</label>
							<value>Theta</value>
							<label>Parameter for coalescence process</label>
							<value>Growthrate</value>
							<label>Growth rate of coalescence process</label>
						</vlist>
						<group>30</group>
						<comment>
<value>Link specifies linkage of model parameters across partitions of the data. For example, link shape=(all) links the gamma shape parameter across all partitions of the data.
</value>
						</comment>
					</attributes>
				</parameter> -->
				
		</parameters>
		
	</paragraph>
</parameter>		
		
<parameter type="Paragraph">
	<paragraph>
		<name>mcmcparams</name>
		<prompt>Parameters for MCMC</prompt>
<!--*******************************************************************************************
All of the parameters in this section must be preceded by the string mcmc
***********************************************************************************************-->
<!--		<precond>
						<language>perl</language>
						<code>!$mrbayesblockquery</code>
		</precond> -->
			<parameters>
			
				<parameter type="Integer">
					<name>ngenval</name>
					<attributes>
						<prompt>Number of Generations (Ngen=)</prompt>
						<precond>
							<language>perl</language>
							<code>!$mrbayesblockquery</code>
						</precond>
						<paramfile>paramfile.txt</paramfile>
						<format>
							<language>perl</language>
<!--removed $allcomps value becuase it crashed the program-->
							<code>"mcmc ngen=$value filename=infile.nex seed=$seed swapseed=$swapseed nruns=$nrunsval nchains=$nchainsval temp=$tempval $reweightvalstring swapfreq=$swapfreqval nswaps=$nswapsval samplefreq=$samplefreqval $mcmcdiagnval minpartfreq=$minpartfreqval $allchainsval $relburninval burnin=$burninval burninfrac=$burninfracval $stopruleval $startingtreeval stopval=$stopval $sbrlensval nperts=$npertsval $ordertaxaval\\n"</code>
						</format>
<!--mcmc  Stopval=0.01 sblrensval=Yes -->
						<vdef>
							<value>5000</value>
						</vdef>
						<ctrls>
							<ctrl>
								<message>Please enter a value for ngen of at least 5000 generations</message>
								<language>perl</language>
								<code>$ngenval &lt; 5000</code>
							</ctrl>
						</ctrls>
						<group>50</group>
						<comment>
<value>Ngen sets the number of cycles for the MCMC algorithm. This should be a big number as you want the chain to first reach stasis, and then remain there for enough time to take lots of samples.
</value>
						</comment>
					</attributes>
				</parameter>
				
<!--			<parameter type="Switch">
					<name>useseed</name>
					<attributes>
						<prompt>Specify a Seed?</prompt>
						<precond>
								<language>perl</language>
								<code>!$mrbayesblockquery</code>
							</precond>
						<format>
							<language>perl</language>
							<code>""</code>
						</format>
						<comment>
<value>Sets the seed number for the random number generator. The random number seed is initialized haphazardly at the beginning of each MrBayes session. This option allows you to set the seed to some specific value, thereby allowing you to exactly repeat an analysis. If the analysis uses swapping between cold and heated chains, you must also set the swap seed (see below) to exactly repeat the analysis.
</value>
						</comment>
					</attributes>
				</parameter> -->
				
				<parameter type="Integer">
					<name>seed</name>
					<attributes>
						<prompt>Seed=</prompt>
							<paramfile>paramfile.txt</paramfile>
						<precond>
							<language>perl</language>
							<code>!$mrbayesblockquery</code>
						</precond>
						<vdef>
							<value>1116355510</value>
						</vdef>
						<format>
							<language>perl</language>
							<code>""</code>
						</format>
						<group>50</group>
						<comment>
<value>Sets the seed number for the random number generator. The random number seed is initialized haphazardly at the beginning of each MrBayes session. This option allows you to set the seed to some specific value, thereby allowing you to exactly repeat an analysis. If the analysis uses swapping between cold and heated chains, you must also set the swap seed (see below) to exactly repeat the analysis.
</value>
						</comment>
					</attributes>
				</parameter>
				<parameter type="Integer">
					<name>swapseed</name>
					<attributes>
						<prompt>Swapseed=</prompt>
							<paramfile>paramfile.txt</paramfile>
						<precond>
							<language>perl</language>
							<code>!$mrbayesblockquery</code>
						</precond>
						<vdef>
							<value>1116355510</value>
						</vdef>
						<format>
							<language>perl</language>
							<code>" "</code>
						</format>
						<group>50</group>
						<comment>
<value>Sets the seed used for generating the swapping sequence when Metropolis-coupled heated chains are used. By deafult, this seed is generated at the beginning of each MrBayes session. This option allows you to set the seed to some specific value, thereby allowing you to exactly repeat a swap sequence.                     
</value>
						</comment>
					</attributes>
				</parameter>

				<parameter type="Integer">
					<name>nrunsval</name>
					<attributes>
						<prompt>Number of Runs (nruns=)</prompt>
						<precond>
							<language>perl</language>
							<code>!$mrbayesblockquery</code>
						</precond>
						<paramfile>paramfile.txt</paramfile>
						<format>
							<language>perl</language>
							<code>" "</code>
						</format>
						<vdef>
							<value>2</value>
						</vdef>
						<group>50</group>
						<comment>
<value>Nruns sets the number of independent analyses started simultaneously.  Only values of 2 and 4 are permitted.                      
</value>
						</comment>
						<ctrls>
							<ctrl>
								<message>Nruns must be either 2 or 4</message>
								<language>perl</language>
								<code>$nrunsval ne 2 &amp;&amp;$nrunsval ne 4 </code>
							</ctrl>
							<ctrl>
								<message>nruns x nchains must be a multiple of 4 and must be less than or equal to 16.</message>
								<language>perl</language>
								<code>((($nrunsval * $nchainsval) % 4) != 0) || ($nrunsval * $nchainsval &gt; 17) </code>
							</ctrl>
						</ctrls>
					</attributes>
				</parameter>

				<parameter type="Integer">
					<name>nchainsval</name>
					<attributes>
						<prompt>Number of Chains to Run (nchains=)</prompt>
						<precond>
							<language>perl</language>
							<code>!$mrbayesblockquery</code>
						</precond>
						<paramfile>paramfile.txt</paramfile>
						<format>
							<language>perl</language>
							<code>""</code>
						</format>
						<vdef>
							<value>4</value>
						</vdef>
						<group>50</group>
						<comment>
<value>   Nchains specifies how many chains are run for each analysis for the MCMCMC variant. The default is 4: 1 cold chain and 3 heated chains. If Nchains is set to 1, MrBayes will use regular MCMC sampling, without heating.
</value>
						</comment>
						<ctrls>
							<ctrl>
								<message>Nchains must 1 or greater.  Default is 4.</message>
								<language>perl</language>
								<code>$nchainsval &lt; 1</code>
							</ctrl>
							<ctrl>
								<message>nruns x nchains must be a multiple of 4 and must be less than or equal to 16.</message>
								<language>perl</language>
								<code>((($nrunsval * $nchainsval) % 4) != 0) || ($nrunsval * $nchainsval &gt; 17) </code>
							</ctrl>
						</ctrls>
					</attributes>
				</parameter>

				<parameter type="Float">
					<name>tempval</name>
					<attributes>
						<prompt>Temperature parameter (temp=)</prompt>
						<precond>
							<language>perl</language>
							<code>!$mrbayesblockquery</code>
						</precond>
						<paramfile>paramfile.txt</paramfile>
						<format>
							<language>perl</language>
							<code>" "</code>
						</format>
						<vdef>
							<value>0.200</value>
						</vdef>
						<group>50</group>
						<comment>
<value>Temp  is the temperature parameter for heating the chains. The higher the temperature, the more likely the heated chains are tomove between isolated peaks in the posterior distribution.     However, excessive heating may lead to very low acceptance rates for swaps between different chains. Before changing the default setting, however, note that the acceptance rates of swaps tend to fluctuate during the burn-in phase of the run.
</value>
						</comment>
					</attributes>
				</parameter>
<!-- dont understand this paramter, implement if requested
				<parameter type="Switch">
					<name>reweightval</name>
					<attributes>
						<prompt>Reweight the Characters (reweight=)?</prompt>
						<precond>
							<language>perl</language>
							<code>!$mrbayesblockquery</code>
						</precond>
						<vdef>
							<value>0</value>
						</vdef>
						<format>
							<language>perl</language>
							<code>""</code>
						</format>
						<comment>
<value>Reweight requires three numbers: the percentage of characters to decrease in weight, the percentage of characters to increase in weight, and the increment. An increase/decrease in weight is acheived by replicating/removing a character in the matrix. This is only done to non-cold chains.                                          
</value>
						</comment>
					</attributes>
				</parameter>

				<parameter  ishidden="1" type="String">
					<name>reweightvalstring</name>
					<attributes>
						<precond>
							<language>perl</language>
							<code>!$mrbayesblockquery &amp;&amp; $reweightval</code>
						</precond>
						<vdef>
							<value>reweight=($reweightparam1,$reweightparam2)</value>
						</vdef>
					</attributes>
				</parameter>		
				
				<parameter type="Float">
					<name>reweightval1</name>
					<attributes>
						<prompt>Reweight parameter 1</prompt>
						<precond>
							<language>perl</language>
							<code>!$mrbayesblockquery &amp;&amp; $reweightvalstring</code>
						</precond>
						<format>
							<language>perl</language>
							<code>""</code>
						</format>
						<vdef>
							<value>0.00</value>
						</vdef>
					</attributes>
				</parameter>
				
				<parameter type="Float">
					<name>reweightval2</name>
					<attributes>
						<prompt>Reweight parameter 2</prompt>
						<precond>
							<language>perl</language>
							<code>!$mrbayesblockquery &amp;&amp; $reweightvalstring</code>
						</precond>
						<vdef>
							<value>0.00</value>
						</vdef>
						<format>
							<language>perl</language>
							<code>""</code>
						</format>
					</attributes>
				</parameter> -->
						
				<parameter type="Integer">
					<name>swapfreqval</name>
					<attributes>
						<prompt>How often should swap of states be attempted</prompt>
						<precond>
								<language>perl</language>
								<code>!$mrbayesblockquery</code>
							</precond>
						<format>
							<language>perl</language>
							<code>""</code>
						</format>
						<vdef>
							<value>1</value>
						</vdef>
						<comment>
<value>Swapfreq specifies how often swaps of states between chains are attempted. You must be running at least two chains for this option to be relevant. The default is Swapfreq=1, resulting in Nswaps (see below) swaps being tried each generation of the run. If Swapfreq is set to 10, then Nswaps swaps will be tried every tenth generation of the run.                       
</value>
						</comment>
					</attributes>
				</parameter> 				
				<parameter type="Integer">
					<name>nswapsval</name>
					<attributes>
						<prompt>How many swaps should be tried per generation</prompt>
						<precond>
								<language>perl</language>
								<code>!$mrbayesblockquery</code>
							</precond>
						<format>
							<language>perl</language>
							<code>""</code>
						</format>
						<vdef>
							<value>1</value>
						</vdef>
						<comment>
<value>Nswaps sets the number of swaps tried for each swapping generation of the chain (see also Swapfreq).                                     
</value>
						</comment>
					</attributes>
				</parameter> 				
				<parameter type="Integer">
					<name>samplefreqval</name>
					<attributes>
						<prompt>How often should the Markov chain be sampled?</prompt>
						<precond>
							<language>perl</language>
							<code>!$mrbayesblockquery</code>
						</precond>
						<paramfile>paramfile.txt</paramfile>
						<format>
							<language>perl</language>
							<code>""</code>
						</format>
						<vdef>
							<value>1000</value>
						</vdef>
						<group>50</group>
						<comment>
<value>Samplefreq specifies how often the Markov chain is sampled. You can sample the chain every cycle, but this results in very large output files. Thinning the chain is a way of making these files smaller and making the samples more independent.
</value>
						</comment>
					</attributes>
				</parameter>				
				<parameter ismandatory="1" type="Excl">
					<name>mcmcdiagnval</name>
					<attributes>
						<prompt>Write acceptance ratios of moves and swaps to file?</prompt>
						<precond>
							<language>perl</language>
							<code>!$mrbayesblockquery</code>
						</precond>
						<vdef>
							<value>mcmcdiagn=Yes</value>
						</vdef>
						<vlist>
							<value>mcmcdiagn=Yes</value>
							<label>Yes</label>
							<value>mcmcdiagn=No</value>
							<label>No</label>
						</vlist>
						<comment>
<value>Mcmcdiagn determines whether acceptance ratios of moves and swaps will be printed to file. The file will be named similarly to the .p' and '.t' files, but will have the ending '.mcmc'. If more than one independent analysis is run simultaneously (see Nruns below), convergence diagnostics for tree topology will also be printed to this file. The convergence diagnostic used is the average standard deviation in partition frequency values across independent analyses. The Burnin setting (see below) determines how many samples will be discarded as burnin before calculating the partition frequencies. The Minpartfreq setting (see below) determines the minimum partition frequency required for a partition to be included in the calculation. As the independent analyses approach stationarity (converge), the value of the diagnostic is expected to approach zero.          
</value>
						</comment>
					</attributes>
				</parameter>
				<parameter type="Float">
					<name>minpartfreqval</name>
					<attributes>
						<prompt>Minimum frequency for a partition to be included (minpartfreq)</prompt>
						<precond>
							<language>perl</language>
							<code>!$mrbayesblockquery</code>
						</precond>
						<paramfile>paramfile.txt</paramfile>
						<format>
							<language>perl</language>
							<code>""</code>
						</format>
						<vdef>
							<value>0.1</value>
						</vdef>
						<group>50</group>
						<comment>
<value>Minpartfreq sets the minimum frequency required for a partition to be included in the calculation of the topology convergence diagnostic. The partition is included if the minimum frequency is reached in at least one of the independent tree samples that are compared.                                                         
</value>
						</comment>
					</attributes>
				</parameter> 
				<parameter ismandatory="1" type="Excl">
					<name>allchainsval</name>
					<attributes>
						<paramfile>paramfile.txt</paramfile>
						<prompt>Record acceptance ratios for all chains?</prompt>
						<precond>
							<language>perl</language>
							<code>!$mrbayesblockquery</code>
						</precond>
						<vdef>
							<value>allchains=No</value>
						</vdef>
						<vlist>
							<value>allchains=Yes</value>
							<label>Yes</label>
							<value>allchains=No</value>
							<label>No</label>
						</vlist>
						<comment>
<value>Allchains: when set to YES, acceptance ratios for moves are recorded for all chains, cold or heated. By default, only the acceptance ratios for the cold chain are recorded.             
</value>
						</comment>
					</attributes>
				</parameter>
<!-- setting to yes crashes the program			
				<parameter ismandatory="1" type="Excl">
					<name>allcompsval</name>
					<attributes>
						<prompt>Calculate convergence diagnostics over all pairwise comparisons?</prompt>
						<precond>
							<language>perl</language>
							<code>!$mrbayesblockquery</code>
						</precond>
						<vdef>
							<value>allcomps=Yes</value>
						</vdef>
						<vlist>
							<value>allcomps=Yes</value>
							<label>Yes</label>
							<value>allcomps=No</value>
							<label>No</label>
						</vlist>
						<comment>
<value>Allcomps: when set to YES, topological convergence diagnostics are calculated over all pairwise comparisons of runs. If it is set to NO, only the overall value is reported.        
</value>
						</comment>
					</attributes>
				</parameter>	-->
						
				<parameter ismandatory="1" type="Excl">
					<name>relburninval</name>
					<attributes>
						<prompt>Discard a proportion of the sampled values as burnin when calculating the convergence diagnostic?</prompt>
						<precond>
							<language>perl</language>
							<code>!$mrbayesblockquery</code>
						</precond>
						<format>
							<language>perl</language>
							<code>""</code>
						</format>
						<vdef>
							<value>relburnin=Yes</value>
						</vdef>
						<vlist>
							<value>relburnin=Yes</value>
							<label>Yes</label>
							<value>relburnin=No</value>
							<label>No</label>
						</vlist>
						<comment>
<value> Relburnin: If set to YES, a proportion of the sampled values will be discarded as burnin when calculating the convergence diagnostic. The proportion to be discarded is set with Burninfrac.  By default, the Relburnin option is set to NO, resulting in a specific number of samples being discarded instead. This number is set by Burnin (see below).
</value>
						</comment>
					</attributes>
				</parameter> 

								<parameter type="Float">
					<name>burninfracval</name>
					<attributes>
						<prompt>Specify the fraction of the sampled values discarded as burnin</prompt>
						<paramfile>paramfile.txt</paramfile>
						<precond>
							<language>perl</language>
							<code>!$mrbayesblockquery &amp;&amp; $relburninval eq "relburnin=Yes"</code>
						</precond>
						<format>
							<language>perl</language>
							<code>""</code>
						</format>
						<vdef>
							<value>0.25</value>
						</vdef>
						<comment>
<value>BurninFrac specifies fraction of samples that will be discarded when convergence diagnostics are calculated. The value of this option is only relevant when Relburnin is set to YES. Example: A value for this option of 0.25 means that 25 percent of the samples will be discarded.
</value>
						</comment>
					</attributes>
				</parameter> 	
					
				<parameter type="Integer">
					<name>burninval</name>
					<attributes>
						<prompt>Specify the number of sampled values discarded as burnin</prompt>
						<paramfile>paramfile.txt</paramfile>
						<precond>
							<language>perl</language>
							<code>!$mrbayesblockquery &amp;&amp; $relburninval eq "relburnin=No"</code>
						</precond>
						<format>
							<language>perl</language>
							<code>""</code>
						</format>
						<vdef>
							<value>0</value>
						</vdef>
						<group>50</group>
						<comment>
<value>Burnin specifies the number of samples (not generations) that will be discarded when convergence diagnostics are calculated. The value of this option is only relevant when Relburnin is set to NO.                                                    
</value>
						</comment>
					</attributes>
				</parameter>					
							
			<parameter ismandatory="1" type="Excl">
					<name>stopruleval</name>
					<attributes>
						<prompt>Stop early if the convergence diagnostic falls below the stop value?</prompt>
						<precond>
							<language>perl</language>
							<code>!$mrbayesblockquery &amp;&amp; $mcmcdiagnval eq "mcmcdiagn=Yes"</code>
						</precond>
						<vdef>
							<value>stoprule=Yes</value>
						</vdef>
						<vlist>
							<value>stoprule=Yes</value>
							<label>Yes</label>
							<value>stoprule=No</value>
							<label>No</label>
						</vlist>
						<comment>
<value>Stoprule: if set to NO, then the chain is run the number of generations determined by Ngen. If it is set to YES, and topological convergence diagnostics are calculated (Mcmcdiagn is set to YES), then the chain will be stopped before the pre-determined number of generations if the convergence diagnostic falls below the stop value.                                    
</value>
						</comment>
					</attributes>
				</parameter>
				
			<parameter type="Float">
					<name>stopval</name>
					<attributes>
						<prompt>Stop early if the convergence diagnostic falls below the stop value?</prompt>
							<paramfile>paramfile.txt</paramfile>
					 	<precond>
							<language>perl</language>
							<code>!$mrbayesblockquery &amp;&amp; $mcmcdiagnval eq "Yes" &amp;&amp; $nrun &gt; "1"</code>
						</precond> 
						<format>
							<language>perl</language>
							<code>""</code>
						</format>
						<vdef>
							<value>0.01</value>
						</vdef>
						<group>50</group>
						<comment>
<value>Stopval: the critical value for the topological convergence diagnostic. Only used when Stoprule and Mcmcdiagn are set to yes, and more than one analysis is run simultaneously (Nruns greater than 1).
</value>
						</comment>
					</attributes>
				</parameter>
				
<!--   Filename     The name of the files that will be generated. Two files are 

generated: "Filename.t" and "Filename.p". The .t file contains the trees whereas the .p file contains the sampled values of the parameters. The default params are temp.out.p and temp.out.t -->
	
<!-- implemneted assuming user tree is implemen ted as well -->
				
				<parameter ishidden="1" ismandatory="1" type="String">
					<name>startingtreeval</name>
					<attributes>
<!--						<prompt>Random or User Selected Starting Trees?</prompt> -->
						<precond>
							<language>perl</language>
							<code>!$mrbayesblockquery &amp;&amp; $Usertreesel</code>
						</precond>
						<paramfile>paramfile.txt</paramfile>
						<format>
							<language>perl</language>
							<code>""</code>
						</format>
						<vdef>
							<value>startingtree=random</value>
						</vdef>
<!--						<vlist>
							<value>startingtree=random</value>
							<label>random</label>
							<value>startingtree=user</value>
							<label>user</label> 
						</vlist>-->
						<group>50</group>
						<comment>
<value>Startingtree specifies whether the starting tree for the chain is randomly selected or user-defined. It might be a good idea to start from randomly chosen trees; convergence seems likely if independently run chains, each of which started from different random trees, converge to the same answer.
</value>
						</comment>
					</attributes>
				</parameter> 
				
				<parameter type="Integer">
					<name>npertsval</name>
					<attributes>
						<prompt>Number of random perturbations to apply to user starting tree.</prompt>
						<precond>
							<language>perl</language>
							<code>!$mrbayesblockquery &amp;&amp; $startingtreeval eq "startingtree=user"</code>
						</precond>
						<format>
							<language>perl</language>
							<code>""</code>
						</format>
						<vdef>
							<value>0</value>
						</vdef>
						<comment>
<value>Nperts is the number of random perturbations to apply to the user starting tree. This allows you to have something between completely random and user-defined trees start the chain.                                                     
</value>
						</comment>
					</attributes>
				</parameter>

				
			<parameter ismandatory="1" type="Excl">
					<name>sbrlensval</name>
					<attributes>
						<prompt>Save branch length information?</prompt>
						<precond>
							<language>perl</language>
							<code>!$mrbayesblockquery</code>
						</precond>
						<paramfile>paramfile.txt</paramfile>
						<vdef>
							<value>Savebrlens=Yes</value>
						</vdef>
						<vlist>
							<value>Savebrlens=Yes</value>
							<label>Yes</label>
							<value>Savebrlens=No</value>
							<label>No</label>
						</vlist>
						<group>50</group>
					</attributes>
				</parameter>
				
				<parameter ismandatory="1" type="Excl">
					<name>ordertaxaval</name>
					<attributes>
						<prompt>Should taxa be ordered before trees are printed to file?</prompt>
						<precond>
							<language>perl</language>
							<code>!$mrbayesblockquery</code>
						</precond>
						<paramfile>paramfile.txt</paramfile>
						<vdef>
							<value>Ordertaxa=Yes</value>
						</vdef>
						<vlist>
							<value>Ordertaxa=Yes</value>
							<label>Yes</label>
							<value>Ordertaxa=No</value>
							<label>No</label>
						</vlist>
						<format>
							<language>perl</language>
							<code>""</code>
						</format>
						<group>50</group>
						<comment>
<value>Ordertaxa determines whether taxa should be ordered before trees are printed to file. If set to 'Yes', terminals in the sampled trees will be reordered to match the order of the taxa in thedata matrix as closely as possible. By default, trees will be printed without reordering of taxa.
</value>
						</comment>
					</attributes>
				</parameter>
				
		</parameters>
		
	</paragraph>
</parameter>




<parameter type="Paragraph">
	<paragraph>
		<name>outputopts</name>
		<prompt>Output/Reporting Options</prompt>
<!--		<precond>
			<language>perl</language>
			<code>!$mrbayesblockquery</code>
		</precond> -->
			<parameters>
			
							<parameter type="Paragraph">
								<paragraph>
									<name>sumtintro</name>
									<prompt>Report parameters</prompt>
									<comment>
<value>    Report allows you to control how the posterior distribution is reported. For rate parameters, it allows you to choose among several popular parameterizations. The report command also allows you to request printing of some model aspects that are usually not reported. For instance, if a node is constrained in the analysis, MrBayes can print the probabilities of the ancestral states at that node. Similarly, if there is rate variation in the model, MrBayes can print the inferred site rates, and if there is omega variation, MrBayes can print the inferred omega (positive selection) values foreach codon. In a complex model with several partitions, each partition is controlled separately using the same 'Applyto' mechanism as in the 'Lset' and  'Prset' commands.                                                              
Options:                                                                       
Applyto   allows you to apply the report commands to specific partitions. This command should be the first in the list of commands specified in 'report'.                                   
For example,  report applyto=(1,2) tratio=ratio 
					 report applyto=(3) tratio=dirichlet                            
would result in the transition and transversion rates of the first and second partitions in the model being reported as a ratio and the transition and transversion rates of the third partition being reported as proportions of the rate sum (the Dirichlet parameterization).                                      

Tratio    -- This specifies the report format for the transition and transversion rates of a nucleotide substitution model with nst=2. If 'ratio' is selected, the rates will be reported as a ratio (transition rate/transversion rate). If 'dirichlet' is selected, the transition and transversion rates will instead be reported as proportions of the rate sum. For example, if the transition rate is three times the transversion rate and 'ratio' is selected, this will reported as a single value, '3.0'. If 'dirichlet' is selected instead, the same rates will be reported using two values, '0.75 0.25'. The sum of the Dirichlet values is always 1. Although the Dirichlet format may be unfamiliar to some users, it is more convenient for specifying priors than the ratio  format. 
                                                         
Revmat    -- This specifies the report format for the substitution rates of a GTR substitution model for nucleotide or amino acid data. If 'ratio' is selected, the rates will be reported scaled to the G-T rate (for nucleotides) or the Y-V rate (for amino acids). If 'dirichlet' is specified instead, the rates are reported as proportions of the rate sum. For instance, assume that the C-T rate is twice the A-G rate and four times the transversion rates, which are equal. If the report format is set to 'ratio', this would be reported as '1.0 2.0 1.0 1.0 4.0 1.0' since the rates are reported in the order rAC, rAG, rAT, rCG, rCT, rGT and scaled relative to the last rate, the G-T rate. If 'dirichlet' is selected instead, the same rates would have been reported as '0.1 0.2  0.1 0.1 0.4 0.1' since the rates are now scaled so that they sumto 1.0. The Dirichlet format is the parameterization used for formulating priors on the rates.                                  

Ratemult  -- This specifies the report format used for the rate multiplier of different model partitions. Three formats are available. If 'scaled' is selected, then rates are scaled such that the mean rate per site across partitions is 1.0. If 'ratio' is chosen, the rates are scaled relative to the rate of the first partition. Finally, if 'dirichlet' is chosen, the rates are given as proportions of the rate sum. The latter is the format used when formulating priors on the rate multiplier.

Ancstates -- If this option is set to 'yes', MrBayes will print the probability of the ancestral states at all constrained nodes. Typically, you are interested in the ancestral states of only a few characters and only at one node in the tree. To perform such an analysis, first define and enforce a topology constraint using 'constraint' and 'prset topologypr = constraints (...)'.Then put the character(s) of interest in a separate partition and set MrBayes to report the ancestral states for that partition. For instance, if the characters of interest are in partition 2, use 'report applyto=(2) ancstates=yes' to force MrBayes to print the probability of the ancestral states of those characters at the constrained node to the '.p' file. 
                           
Siterates  If this option is set to 'yes' and the relevant model has rate variation across sites, the mean site rate in the posterior will be reported for each site to the '.p' file.
                       
Possel     If this option is set to 'yes' and the relevant model has omega variation across sites, the mean omega value for each model site (codon in this case) will be written to the '.p' file.            

</value>
									</comment>						
										<parameters>
<!--The parameters are sub commands of the report option-->										
											<parameter ismandatory="1" type="Excl">
												<name>tratioval</name>
												<attributes>
													<prompt>Report format for the transition and transversion rates of a nucleotide substitution model with nst=2</prompt>
													<paramfile>paramfile.txt</paramfile>
														<vdef>
															<value>ratio</value>
														</vdef>
														<precond>
															<language>perl</language>
															<code>!$mrbayesblockquery &amp;&amp; $nstopts eq 2</code>
														</precond>
														<format>
															<language>perl</language>
															<code>"report tratio=$value\\n"</code>
														</format>
														<vlist>
															<value>ratio</value>
															<label>ratio</label>
															<value>dirichlet</value>
															<label>dirichlet</label>
															</vlist>
															<group>45</group>
												</attributes>
											</parameter>
											
											<parameter ismandatory="1" type="Excl">
												<name>revmatopts</name>
												<attributes>
													<prompt>Report format for substitution rates of a GTR substitution model for nucleotide or amino acid data</prompt>
													<precond>
														<language>perl</language>
														<code>!$mrbayesblockquery</code>
													</precond>
													<paramfile>paramfile.txt</paramfile>
														<vdef>
															<value>dir</value>
														</vdef>
										<!--  		<precond>
														<language>perl</language>
														<code>$nstopts eq 6 || $aamodelpropts eq "fixed(gtr)"</code>
													</precond> -->
													<format>
														<language>perl</language>
														<code>"report revmat=$value\\n"</code>
													</format>
													<vlist>
														<value>ratio</value>
														<label>ratio</label>
														<value>dirichlet</value>
														<label>dirichlet</label>
													</vlist>
													<group>45</group>
												</attributes>
											</parameter>
											
	<!-- not relvant, since partitions arent supported										<parameter ismandatory="1" type="Excl">
												<name>ratemultopts</name>
												<attributes>
													<prompt>Report format for the rate multiplier of different model partitions</prompt>
													<precond>
														<language>perl</language>
														<code>!$mrbayesblockquery</code>
													</precond>
													<paramfile>paramfile.txt</paramfile>
													<vdef>
															<value>dirichlet</value>
													</vdef>
													<precond>
														<language>perl</language>
														<code>!$mrbayesblockquery &amp;&amp; $ispartitioned</code>
													</precond>
													<format>
														<language>perl</language>
														<code>"report ratemult=$value\\n"</code>
													</format>
													<vlist>
														<value>scaled</value>
														<label>scaled</label>
														<value>ratio</value>
														<label>ratio</label>
														<value>dir</value>
														<label>dirichlet</label>
													</vlist>
													<group>45</group>
												</attributes>
											</parameter> -->
											
											<parameter type="Switch">
												<name>reportancstateopts</name>
												<attributes>
													<prompt>Report the probability of ancestral states at all constrained nodes</prompt>
													<paramfile>paramfile.txt</paramfile>
													<vdef>
														<value>0</value>
													</vdef>
													<precond>
														<language>perl</language>
														<code>!$mrbayesblockquery &amp;&amp; $topologypropts eq "constraint"</code>
													</precond>  
														<format>
															<language>perl</language>
															<code>($value)? "report Ancstates=Yes\\n":"report Ancstates=No\\n"</code>
														</format>
														<group>45</group>
												</attributes>
											</parameter>
											
											<parameter type="Switch">
												<name>reportsiterateopts</name>
												<attributes>
													<prompt>Report mean site rate in the posterior</prompt>
													<precond>
														<language>perl</language>
														<code>!$mrbayesblockquery</code>
													</precond>
													<paramfile>paramfile.txt</paramfile>
													<vdef>
														<value>0</value>
													</vdef>
												<!--<precond>
														<language>perl</language>
														<code>$rateopts eq "gamma" || $rateopts eq "adgamma" || $rateopts eq "propinv" || $rateopts eq "invgamma"</code>
													</precond> --> 
													<format>
														<language>perl</language>
														<code>($value)? "report Siterates=Yes\\n":"report Siterates=No\\n"</code>
													</format>
													<group>45</group>
												</attributes>
											</parameter>
											
											<parameter type="Switch">
												<name>reportposselopts</name>
												<attributes>
													<prompt>Write Mean Omega Values</prompt>
													<paramfile>paramfile.txt</paramfile>
													<vdef>
														<value>0</value>
													</vdef>
													<precond>
														<language>perl</language>
														<code>!$mrbayesblockquery &amp;&amp; $nucmodelopts eq "codon"</code>
													</precond>  
													<format>
														<language>perl</language>
														<code>($value)? "report possel=Yes\\n":"report possel=No\\n"</code>
													</format>
													<group>45</group>
												</attributes>
											</parameter>
											
										</parameters>
										
									</paragraph>
								</parameter>
<!--The parameters are sub commands of the sumt option-->										
								<parameter type="Paragraph">
									<paragraph>
									<name>sumtintro</name>
									<prompt>Set Sumt parameters</prompt>
									<comment>
<value> Sumt command is used to produce summary statistics for trees sampled during a Bayesian MCMC analysis. You can either summarize trees from one individual analysis, or trees coming from several independent analyses. In either case, all the sampled trees are read in and the proportion of the time any single taxon bipartition is found is counted. The proportion of the time that the bipartition is found is an approximation of the posterior probability of the bipartition. (A taxon bipartition is defined by removing a branch on the tree, dividing the tree into those taxa to the left and right  of the removed branch.) The branchlength of the bipartition is also recorded, if branch lengths have been saved to file. The result is a list of taxon bipartitions, the frequency with which they were found, the posterior probability of the bipartition and the mean and variance of the lengthof the branch (if bl's were recorded). 

The partition information is output to a file with the suffix ".parts" and a consensus tree is also printed to a file with the suffix ".con". The consensus tree is either a 50 percent majority rule tree or a majority rule tree showing all compatible partitions. If branch lengths have been recorded during the run, the ".con" file will contain a consensus tree with branch lengths and interior nodes labelled with support values. This tree can be viewed in a program such as TreeView. Finally, MrBayes produces a file with the ending ".trprobs" that contains a  list of all the trees that were found during the MCMC analysis, sorted by their probabilities. This list of trees can be used to construct a credible set of trees. For example, if you want to construct a 95 percent credible set of trees, you include all of those trees whose cumulated probability is less than or equal to 0.95. If you are analyzing a large set of taxa, you may actually want to skip the calculation of tree probabilities entirely by setting "Calctreeprobs" to NO.                                                       

When calculating summary statistics you probably want to skip those trees that were sampled in the initial part of the run, the so-called burn-in period. The number of skipped samples is controlled by the "burnin" setting. The default is 0 but you typically want to override this setting. If you are summarizing the trees sampled in several independent analyses, such as those resulting from setting the "Nruns" option of the "Mcmc" command to a value larger than 1, MrBayes will also calculate convergence diagnostics for the sampled topologies and branch lengths. These values can help you determine whether it is likely that your chains have converged. 

The "Sumt" command expands the "Filename" according to the current values of the "Nruns" and "Ntrees" options. For instance, if both "Nruns" and "Ntrees" are set to 1, "Sumt" will try to open a file named "Filename.t". If "Nruns" is set to 2 and "Ntrees" to 1, then "Sumt" will open two files, Filename.run1.t and Filename.run2.t, etc. By default, the "Filename" option will be set such that "Sumt" automatically summarizes all the results from your immediately preceding "Mcmc"  command. You can also use the "Sumt" command to summarize tree samples inolder analyses. If you want to do that, remember to first read in a matrix so that MrBayes knows what taxon names to expect in the trees. Then set the  "Nruns", "Ntrees" and "Filename" options appropriately.

Options:                              
Burnin  -- Determines the number of samples that will be discarded from the input file before calculating summary statistics. If there are several input files, the same number of sampleswill be discarded from each. Note that the burnin is set separately for the 'sumt', 'sump', and 'mcmc' commands.                                               
Ntrees   -- Determines how many trees there are in the sampled model. If 'Ntrees' is greater then 1 then the names of the files are derived from 'Filename' by adding '.tree1.t', '.tree2.t', etc. If Nruns=1 and Ntrees=1 (see below), then only '.t' is added to 'Filename'.  
Displaygeq   -- The minimum probability of partitions to display.
Contype       -- Type of consensus tree. 'Halfcompat' results in a 50 majority rule tree, 'Allcompat' adds all compatible groups to such a tree.                                                       
Calctreeprobs -- Determines whether tree probabilities should be calculated.                           

</value>
									</comment>
															
						<parameters>
						
							<parameter type="Integer">
								<name>sumtburnin</name>
								<attributes>
									<prompt>Sumt Burnin Value</prompt>
									<precond>
										<language>perl</language>
										<code>!$mrbayesblockquery</code>
									</precond>
									<paramfile>paramfile.txt</paramfile>
									<vdef>
										<value>0</value>
									</vdef>
									<format>
										<language>perl</language>
										<code>"sumt burnin=$value nruns=$sumtnruns ntrees=$sumtntrees displaygeq=$sumtdisplaygeq $sumtcontype \\n"</code>
									</format>
									<group>70</group>
								</attributes>
							</parameter>
							
							<parameter type="Integer">
								<name>sumtnruns</name>
								<attributes>
									<prompt>How many .t files should be summarized (Sumt nruns=)</prompt>
									<precond>
										<language>perl</language>
										<code>!$mrbayesblockquery</code>
									</precond>
									<paramfile>paramfile.txt</paramfile>
									<vdef>
										<value>2</value>
									</vdef>
									<format>
										<language>perl</language>
										<code>""</code>
									</format>
									<group>70</group>
									<comment>
										<value>Sumt Nruns Determines how many '.t' files from independent analyses will be summarized. If Nruns > 1 then the names of the files are derived from 'Filename' by adding '.run1.t', '.run2.t', etc. If Nruns=1 and Ntrees=1 (see below), then only '.t' is added to 'Filename'.                                          
</value>
									</comment>
								</attributes>
							</parameter>
							
							<parameter type="Integer">
								<name>sumtntrees</name>
								<attributes>
									<prompt>How many trees should be in the Sumt model</prompt>
									<precond>
										<language>perl</language>
										<code>!$mrbayesblockquery</code>
									</precond>
									<paramfile>paramfile.txt</paramfile>
									<vdef>
										<value>1</value>
									</vdef>
									<format>
										<language>perl</language>
										<code>""</code>
									</format>
									<group>70</group>
									<comment>
<value>Sumt Ntrees  determines how many trees there are in the sampled model. If 'Ntrees' > 1 then the names of the files are derived from 'Filename' by adding '.tree1.t', '.tree2.t', etc. If there are both multiple trees and multiple runs, the filenames will be 'Filename.tree1.run1.t', 'Filename.tree1.run2.t', etc.</value>
									</comment>
								</attributes>
							</parameter>

<!--  The Filename parameter is not supported. Filename specifies the name of the file(s) to be summarized. This is the base of the file name, to which endings are added according to the current settings of the 'Nruns' and 'Ntrees' options.     -->	
						
							<parameter type="Float">
								<name>sumtdisplaygeq</name>
								<attributes>
									<prompt>Minimum probability of partitions to display in Sumt (0.05 = 95%)</prompt>
									<precond>
										<language>perl</language>
										<code>!$mrbayesblockquery</code>
									</precond>
									<paramfile>paramfile.txt</paramfile>
									<vdef>
										<value>0.05</value>
									</vdef>
									<format>
										<language>perl</language>
										<code>""</code>
									</format>
									<group>70</group>
								</attributes>
							</parameter>
							
							<parameter ismandatory="1" type="Excl">
								<name>sumtcontype</name>
								<attributes>
									<prompt>Type of consensus tree</prompt>
									<paramfile>paramfile.txt</paramfile>
									<vdef>
										<value>contype=Halfcompat</value>
									</vdef>
									<format>
										<language>perl</language>
										<code>""</code>
									</format>
									<group>70</group>
									<precond>
										<language>perl</language>
										<code>!$mrbayesblockquery &amp;&amp; $sumtcalctreeprobs</code>
									</precond>
									<vlist>
										<value>contype=Halfcompat</value>
										<label>50% Majority Rule</label>
										<value>contype=Allcompat</value>
										<label>All Compatible Groups</label>
									</vlist>
									<comment>
<value>Contype sets the type of consensus tree. The choices are 50 per cent majority rule tree, and one where all compatible groups are added to the tree.</value>
									</comment>
								</attributes>
							</parameter>
							
<!-- this paramater is not found by the app -->					
<!--							<parameter type="Switch">
								<name>sumtcalctreeprobs</name>
								<attributes>
									<prompt>Calculate Tree Probabilities</prompt>
									<precond>
										<language>perl</language>
										<code>!$mrbayesblockquery</code>
									</precond>
									<paramfile>paramfile.txt</paramfile>
									<vdef>
										<value>1</value>
									</vdef>
									<format>
										<language>perl</language>
										<code>($value)? "sumt calctreeprobs = Yes\\n":"sumt calctreeprobs = No\\n"</code>
									</format>
									<group>70</group>
								</attributes>
							</parameter> -->
							
							<parameter ismandatory="1" type="Excl">
								<name>sumtshowtreeprobs</name>
								<attributes>
									<prompt>Show Tree Probabilities</prompt>
									<precond>
										<language>perl</language>
										<code>!$mrbayesblockquery</code>
									</precond>
									<paramfile>paramfile.txt</paramfile>
									<vdef>
										<value>showtreeprobs=No</value>
									</vdef>
										<vlist>
										<value>showtreeprobs=Yes</value>
										<label>Yes</label>
										<value>showtreeprobs=No</value>
										<label>No</label>
									</vlist>
									<format>
										<language>perl</language>
										<code>""</code>
									</format>
									<group>70</group>
								</attributes>
							</parameter>		
						</parameters>
					</paragraph>
				</parameter>
<!--The parameters are sub commands of the sump option -->						
				<parameter type="Paragraph">
					<paragraph>
						<name>sumpintro</name>
						<prompt>Set Sump parameters</prompt>
						<comment>
<value>Sump specifies how information is summarized, and written to a parameter file. During MCMC analysis, MrBayes prints the sampled parameter values to a tab delimited text file. By default, the name of the parameter file is assumed to be the name of the last matrix-containing nexus file, but with a '.p' extension. You can set 'Sump' to summarize the information in any other parameter file by setting the 'filename' option to the appropriate file name. The 'Sump' command does not require a matrix to be read in first. When you invoke the 'Sump' command, three items are output (1) a generation plot of the likelihood values; (2) estimates of the marginal likelihood of the model; and (3) a table with the mean, variance, and 95 percent credible interval for the sampled parameters. Each of these items can be switched on or off using the options 'Plot', 'Marglike', and 'Table'. By default, all three items are output but only to the screen. If output to a file is also desired, set 'Printtofile' to 'Yes'. The name of the output file is specified by setting the 'Outputname' option. When a new matrix is read in or when the 'Mcmc' output filename or 'Sump' input filename is changed, the 'Sump' outputname is changed as well. If you want to output to another file than the default, make sure you specify the outputname every time you invoke 'Sump'. If the specified outputfile already exists, you will   
be prompted about whether you like to overwrite it or append to it. When you run several independent analyses simultaneously in MrBayes, the 'Nruns' and 'Filename' options are automatically set such that 'Sump' will summarize all the resulting output files.                                                             
                                     
                                                                                  
Default settings:    Burnin:0; Nruns:1; Filename:temp.p.p; Printtofile:No; Outputname:temp.p.stat; Plot:Yes; Marglike:Yes; Table:Yes                                  
</value>
						</comment> 
						<parameters>
						
                            <parameter type="Integer">
							<name>sumpburnin</name>
								<attributes>
									<prompt>Sump Burnin Value</prompt>
									<precond>
										<language>perl</language>
										<code>!$mrbayesblockquery</code>
									</precond>
									<paramfile>paramfile.txt</paramfile>
									<vdef>
										<value>0</value>
									</vdef>
									<format>
										<language>perl</language>
										<code>"sump burnin=$value nruns=$sumpnruns printtofile=yes outputname=sumpoutput.out $sumpplot $sumpmarglike $sumptable\\n"</code>
									</format>
									<group>60</group>
									<comment>
<value>Burnin determines the number of samples that will be discarded from the input file before calculating summary statistics. If there are several input files, the same number of samples will 				be discarded from each.</value>
									</comment>
								</attributes>
						</parameter>
						
							<parameter type="Integer">
							<name>sumpnruns</name>
								<attributes>
									<prompt>How many '.p' files from independent analyses will be summarized (sump Nruns=)</prompt>
									<precond>
										<language>perl</language>
										<code>!$mrbayesblockquery</code>
									</precond>
									<paramfile>paramfile.txt</paramfile>
									<vdef>
										<value>2</value>
									</vdef>
									<format>
										<language>perl</language>
										<code>""</code>
									</format>
									<group>60</group>
									<comment>
<value>Sump nruns determines how many '.p' files from independent analyses that will be summarized. If Nruns > 1 then the names of the files are derived from 'Filename' by adding '.run1.p', '.run2.p', etc. If Nruns=1, then the single file name is obtained by adding '.p' to 'Filename'.                                     
</value>
									</comment>
								</attributes>
						</parameter>
						
<!--		comined into burnin					<parameter ishidden="1" type="Excl">
								<name>sumpfileyes</name>
								<attributes>
									<format>
										<language>perl</language>
										<code>"printtofile=Yes"</code>
									</format>
									<paramfile>paramfile.txt</paramfile>
									<group>60</group>
								</attributes>
							</parameter>
								
							<parameter ishidden="1" type="Excl">
								<name>sumpfile</name>
								<attributes>
									<format>
										<language>perl</language>
										<code>"sump \\n"</code>
									</format>
									<paramfile>paramfile.txt</paramfile>
									<group>60</group>
								</attributes>
							</parameter> -->
								
							<parameter ismandatory="1" type="Excl">
								<name>sumpplot</name>
								<attributes>
									<prompt>Prepare a likelihood plot</prompt>
									<precond>
										<language>perl</language>
										<code>!$mrbayesblockquery</code>
									</precond>
									<paramfile>paramfile.txt</paramfile>
									<vdef>
										<value>plot=Yes</value>
									</vdef>
									<vlist>
										<value>plot=Yes</value>
										<label>Yes</label>
										<value>plot=No</value>
										<label>No</label>
									</vlist>
									<format>
										<language>perl</language>
										<code>""</code>
									</format>
									<group>60</group>
								</attributes>
							</parameter>
							
							<parameter ismandatory="1" type="Excl">
								<name>sumpmarglike</name>
								<attributes>
									<prompt>Calculate estimates of marginal model likelihoods</prompt>
									<precond>
										<language>perl</language>
										<code>!$mrbayesblockquery</code>
									</precond>
									<paramfile>paramfile.txt</paramfile>
									<vdef>
										<value>marglike=Yes</value>
									</vdef>
									<vlist>
										<value>marglike=Yes</value>
										<label>Yes</label>
										<value>marglike=No</value>
										<label>No</label>
									</vlist>
									<format>
										<language>perl</language>
										<code>""</code>
									</format>
									<group>60</group>
								</attributes>
							</parameter>
							
						<parameter ismandatory="1" type="Excl">
								<name>sumptable</name>
								<attributes>
									<prompt>Prepare a table summarizing the parameter value samples</prompt>
									<precond>
										<language>perl</language>
										<code>!$mrbayesblockquery</code>
									</precond>
									<paramfile>paramfile.txt</paramfile>
									<vdef>
										<value>table=Yes</value>
									</vdef>
									<vlist>
										<value>table=Yes</value>
										<label>Yes</label>
										<value>table=No</value>
										<label>No</label>
									</vlist>
									<format>
										<language>perl</language>
										<code>""</code>
									</format>
									<group>60</group>
								</attributes>
							</parameter> 
								
						</parameters>                                                                                
					</paragraph>
				</parameter>
			</parameters>
	</paragraph>
</parameter>
</parameters>
</pise>


