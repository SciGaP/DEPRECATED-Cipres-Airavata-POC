package  org.ngbw.cipresrest.webresource;

import javax.ws.rs.core.Response;
import javax.ws.rs.core.Response.Status;
import javax.ws.rs.ext.ExceptionMapper;
import javax.ws.rs.ext.Provider;
import javax.ws.rs.WebApplicationException;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

import org.ngbw.restdatatypes.ErrorData;

/*
	This is my jersey catch all exception mapper.
	Without this, html error messages, generated by jersey, are returned on unmapped WebApplicationExceptions.
	There are cases where jersey itself throws WebApplicationExceptions.  

	This mapper is called if the WebApplicationException doesn't have an entity body, eg
	if created with new WebApplicationException("string" or status).  However if we, or
	jersey creates a WebApplicationException and builds it with an entity body, it seems
	that this mapper isn't used.  Can't do anyting about cases where jersey may create
	a WebApplicationException with a text body, but we should never do that in our code.

	Thus client apps may need to be able to handle an occassional text, or html, not xml, response.
*/
@Provider
public class WebApplicationExceptionMapper implements ExceptionMapper<WebApplicationException> 
{
	private static final Log log = LogFactory.getLog(WebApplicationExceptionMapper.class.getName());

	public Response toResponse(WebApplicationException e)
	{
		log.error(e.toString(), e);


		// note that this will throw an exception (I think) if entity() is passed
		// a null string, and in that case tomcat throws a 500 with some html text.
		// Throwable.toString is never null. Throwable.getMessage may be null.
		return Response.
				status(e.getResponse().getStatus()).
				type("application/xml").
				entity(new ErrorData("" + e.toString(), 24)).
				build();
	}
}
